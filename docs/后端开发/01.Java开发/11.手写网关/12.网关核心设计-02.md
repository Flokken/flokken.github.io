---
title: 网关核心设计-02
date: 2024-03-13
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - 手写网关
---

## Http请求参数解析

HTTP 接口请求的参数需要解析成可以匹配到 RPC 接口的入参信息，所以通常为了方便控制一般只支持 RPC 接口单个对象入参，**并且不允许同名不同参数的重载方法出现**，这些会在 RPC 方法注册阶段进行报错提醒。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240313193714584.png" alt="image-20240313193714584" style="zoom:67%;" />

- 从网络请求到会话，需要对 GET/POST 的请求，以及请求的参数类型 Content-Type 做细化的参数解析操作。
- 同时按照 RPC 泛化调用的入参方式，将解析的参数封装处理



数据源服务核心链路关系

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240313194217685.png" alt="image-20240313194217685" style="zoom:67%;" />



> cn.bugstack.gateway.socket.agreement.RequestParser

```java
if (HttpMethod.GET == method) {
    Map<String, Object> parameterMap = new HashMap<>();
    QueryStringDecoder decoder = new QueryStringDecoder(request.uri());
    decoder.parameters().forEach((key, value) -> parameterMap.put(key, value.get(0)));
    return parameterMap;
} else if (HttpMethod.POST == method) {
    switch (contentType) {
        case "multipart/form-data":
            Map<String, Object> parameterMap = new HashMap<>();
            HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(request);
            decoder.offer(request);
            decoder.getBodyHttpDatas().forEach(data -> {
                Attribute attr = (Attribute) data;
                try {
                    parameterMap.put(data.getName(), attr.getValue());
                } catch (IOException ignore) {
                }
            });
            return parameterMap;
        case "application/json":
            ByteBuf byteBuf = request.content().copy();
            if (byteBuf.isReadable()) {
                String content = byteBuf.toString(StandardCharsets.UTF_8);
                return JSON.parseObject(content);
            }
            break;
        default:
            throw new RuntimeException("未实现的协议类型 Content-Type：" + contentType);
    }
}
```

- 获取类型后，按照 GET/POST 分别做解析处理
- 其中，Post方法还根据contentype做不同处理
  - 网关中最常用的就是 POST 请求 + application/json 的方式

### 不同RPC泛化调用

对照不同的接口类型，其实是需要不同的参数传递，**其实就是泛化调用的invoke需要传递解析好的参数**

**基本类型 + 单参**

**接口**

```java
public String sayHi(String str) {
  return "hi " + str + " by api-gateway-test-provider";
}
```

**调用**

```java
Object result = genericService.$invoke("sayHi", new String[]{"java.lang.String"}, new Object[]{"world"});
```

**对象类型 + 单参**

**接口**

```java
public String insert(XReq req) {
    return "hi " + JSON.toJSONString(req) + " by api-gateway-test-provider";
}

```

**调用**

```java
Map<String, Object> params = new HashMap<>();
params.put("uid", "10001");
params.put("name", "小傅哥");

Object user = genericService.$invoke("insert", new String[]{"cn.bugstack.gateway.rpc.dto.XReq"}, new Object[]{params});
```

**对象类型 + 多参**

> 网关中一般不会用到

**接口**

```java
public String test(String str, XReq req) {
    return "hi " + str + JSON.toJSONString(req) + " by api-gateway-test-provider";
}
```

**调用**

```java
Map<String, Object> params01 = new HashMap<>();
params01.put("str", "10001");

Map<String, Object> params02 = new HashMap<>();
params02.put("uid", "10001");
params02.put("name", "小傅哥");

Object user = genericService.$invoke("test", new String[]{"java.lang.String", "cn.bugstack.gateway.rpc.dto.XReq"}, new Object[]{params01.values().toArray()[0], params02});
```

### 会话中消息封装

> cn.bugstack.gateway.session.defaults.DefaultGatewaySession

```java
public Object get(String methodName, Map<String, Object> params) {
    Connection connection = dataSource.getConnection();
    HttpStatement httpStatement = configuration.getHttpStatement(uri);
    String parameterType = httpStatement.getParameterType();
    /*
     * 调用服务
     * 封装参数 PS：为什么这样构建参数，可以参考测试案例；cn.bugstack.gateway.test.RPCTest
     * 01(允许)：java.lang.String
     * 02(允许)：cn.bugstack.gateway.rpc.dto.XReq
     * 03(拒绝)：java.lang.String, cn.bugstack.gateway.rpc.dto.XReq —— 不提供多参数方法的处理
     * */
    return connection.execute(methodName,
            new String[]{parameterType},
            new String[]{"ignore"},
            SimpleTypeRegistry.isSimpleType(parameterType) ? params.values().toArray() : new Object[]{params});
}

@Override
public Object post(String methodName, Map<String, Object> params) {
    return get(methodName, params);
}
```

- 在网关会话的调用中，按照参数的类型封装请求信息。

### 测试

```java
public void test_gateway() throws InterruptedException, ExecutionException {
    // 1. 创建配置信息加载注册
    Configuration configuration = new Configuration();
    HttpStatement httpStatement01 = new HttpStatement(
            "api-gateway-test",
            "cn.bugstack.gateway.rpc.IActivityBooth",
            "sayHi",
            "java.lang.String",
            "/wg/activity/sayHi",
            HttpCommandType.GET);

    HttpStatement httpStatement02 = new HttpStatement(
            "api-gateway-test",
            "cn.bugstack.gateway.rpc.IActivityBooth",
            "insert",
            "cn.bugstack.gateway.rpc.dto.XReq",
            "/wg/activity/insert",
            HttpCommandType.POST);

    configuration.addMapper(httpStatement01);
    configuration.addMapper(httpStatement02);

    // 2. 基于配置构建会话工厂
    DefaultGatewaySessionFactory gatewaySessionFactory = new DefaultGatewaySessionFactory(configuration);
    // 3. 创建启动网关网络服务
    GatewaySocketServer server = new GatewaySocketServer(gatewaySessionFactory);
    Future<Channel> future = Executors.newFixedThreadPool(2).submit(server);
    Channel channel = future.get();
    if (null == channel) throw new RuntimeException("netty server start error channel is null");
    while (!channel.isActive()) {
        logger.info("netty server gateway start Ing ...");
        Thread.sleep(500);
    }
    logger.info("netty server gateway start Done! {}", channel.localAddress());
    Thread.sleep(Long.MAX_VALUE);
}
```

### STAR总结

Situation：Http调用可能具有参数，所以我们应该增加对于参数解析

Task：

- HTTP的GET、POST请求类型，以及POST的请求体中的Content-Type，都决定了入参的形式，因此需要制定对应的入参解析、处理方式 
-  将解析后入参作为RPC泛化调用的入参

Action：

**参数解析**

- 在自定义的channel处理器接收到HTTP请求后，对HTTP请求参数进行解析
-  +RequestParser，用于处理请求，获取FullHttpRequest中的HttpMethod是GET还是POST。
-   如果是GET，使用Netty的解析器将入参解析为Map 
-  如果是POST请求，则需要获取、判断ContentType，如果ContentType是multipart/form-data，解析成Map；如果ContentType是application/json，解析成对象
-   网关中常用POST+application/json，后面会在Headers中加token，避免网关接口被外部滥用 

**在会话中封装参数**

- 基于上面提到的3种接口请求类型，在网关会话DefaultGatewaySession中调用RPC泛化服务时，对入参进行统一处理 

- +SimpleTypeRegistry类型注册器：用于判断parameterType，**如果是注册器中有的类型，则将入参转为数组；如果是Map类型则用Object数组包装一下**

- post请求暂时还是调用get方法实现（后续要改） 

  封装入参之后，执行服务调用

**测试验证**

- 用postman测试GET请求：  将请求参数封装至Params中，并要在Headers中添加Content-Type。其实Content-Type对于GET请求是无用的，但在代码中并未做区分。 所以测试验证时，要么改RequestParser#getContentType中的逻辑，要么在请求的Headers加上Content-Type，请求网关

- 测试POST请求： 要在Headers中添加Content-Type=application/json，并在Body中以JSON的方式添加参数，请求网关

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/FlQokrHt7HVgGe4gS49T5QS031Pv)

## 封装数据源调用并引入执行器

会话流程中还有些内容过于冗余，这些内容就是对数据源(RPC)的调用时入参和出参的封装，它们应该被提取到一个专门的类来处理，这样才能更加方便的管理。**会话的职责是负责串联上下文，执行器的职责是负责对数据源的调用信息处理**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240313200740640.png" alt="image-20240313200740640" style="zoom: 67%;" />

- 添加 executor 执行器模块，封装对数据源(RPC)的调用，以及处理相关的入参、出参信息。同时这里还会把网关的调用结果进行封装到一个标准的类中，类里包括了code码、info描述，以及 data 结果信息。

执行器流程核心关系如下所示

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240313200925042.png" alt="image-20240313200925042" style="zoom:67%;" />

- 执行器需要接受rpc调用的参数，执行任务或返回结果封装

### 实习执行器

**定义接口**

```java
public interfaceExecutor{
	GatewayResultexec(HttpStatement httpStatement,Map<String,Object>params) throws Exception;
}
```

- 定义一个执行器接口，所有的会话请求都通过执行器完成。

**定义结果**

```java
publicclassGatewayResult{

    private Stringcode;
    private Stringinfo;
    private Objectdata;

protected GatewayResult(String code,String info,Object data){
    this.code=code;
    this.info=info;
    this.data=data;
}

public static GatewayResultbuildSuccess(Object data){
	return newGatewayResult("0000","调用成功",data);
}

public static GatewayResultbuildError(Object data){
	return newGatewayResult("0001","调用失败",data);
}

}
```

- 这个在微服务项目以及各种需要调用接口的项目中很常见，封装一个结果类，来告诉调用方调用情况和调用结果。

**抽象封装**

```java
```

- 将会话章节处理的信息，这里封装到执行器中来完成。

### **会话调用**

**构建执行器**

> cn.bugstack.gateway.session.defaults.DefaultGatewaySessionFactory

```java
```

- 在开启会话时，创建对应的执行器，并把执行器传递给会话中使用。

**会话调用执行器**

> cn.bugstack.gateway.session.defaults.DefaultGatewaySession

```java

```

- 在会话方法中调用执行器提供的方法，返回结果。

### 网络调用

> cn.bugstack.gateway.socket.handlers.GatewayServerHandler

```java
```

- 在网络请求中包括；解析请求参数、调用会话服务、封装返回结果，这三个大块。

### STAR总结

Situation：之前章节的网关会话中，包含了使用SimpleTypeRegistry封装入参、调用数据源连接对象等操作，需要将这部分抽取，方便后续管理 

Task：

- 会话是专门用来串联上下文，应该减少具体逻辑 。需要引入执行器模块，专门用来封装入参、调用数据源连接对象 
-  在执行器模块中还引入了结果类，用于统一封装服务返回的结果
- 优化GatewayServerHandler，将入参处理放入RequestParser，将服务返回结果都放入ResponseParser处理，使得处理器各子功能更清晰明了，方便后续维护 

Action：

**执行器模块**

- +Executor：新增接口，声明exec方法
- +BaseExecutor：实现Executor接口的exec方法声明，将原来会话中的参数封装的逻辑移入这里，调用抽象方法doExec
- +SimpleExecutor：继承BaseExecutor实现抽象方法doExec，将原来网关会话中的调用数据源连接对象DubboConnection的逻辑移入这里 
- +GatewayResult：新增结果类，定义了data、code、info属性，包装服务返回的结果，便于统一结果

**会话**

- 在DefaultGatewaySessionFactory中开启会话时，使用Configuration创建执行器，并将数据源连接对象注入执行器，将执行器注入网关会话DefaultGatewaySession，以便后续使用 
- 当调用RPC泛化服务代理对象时，会调用网关会话DefaultGatewaySession执行服务请求，此时就调用上面定义的执行器完成服务请求操作，并接受服务结果，用GatewayResult包装 

**处理器**

- 将GatewayServerHandler自定义网关处理器中的逻辑封装为3各模块：解析请求参数、调用会话服务、封装返回结果并反馈给客户端
- 解析请求参数的逻辑都并入RequestParser
-  封装返回结果并反馈给客户端的逻辑都并入ResponseParser 

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/FtKFSXX411Uu87NbTi50JBmv_oXk)

## 权限校验实现

在我们的实现的**API网关**中，当接收 HTTP 请求以后，开始调用对应的 RPC 接口前，其实还应该做一步权限验证。也就是说你当前调用的 HTTP 接口是否含带了我授予的 Token ，并且在有效期内。

> Question:Netty协议转换指的是转换Http协议为哪种协议?
>
> Answer：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240313212621406.png" alt="image-20240313212621406" style="zoom:67%;" />

- 关于网关中权限的校验会使用到 Shiro + Jwt，同时还要提供单独的 Handler 来处理 Netty 中的通信对信息的校验处理。但鉴于这部分属于两块功能，所以本章只先完成关于 Shiro + Jwt 部分。
- Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单。对比于 Spring Security，可能没有做的功能强大，但是在实际工作时并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。



**执行器流程核心关系**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240313214629541.png" alt="image-20240313214629541" style="zoom:80%;" />

- Shiro、Jwt 是两套东西，Shiro 是安全验证框架，Jwt 是（JSON Web Tokens）是一套 JSON 网络令牌，一个轻便的安全跨平台传输格式，定义了一个紧凑的自包含的方式在不同实体之间安全传输信息（JSON格式）。

>- **https://jwt.io/**
>- **https://shiro.apache.org/**

### Shiro案例

```ini
[users]
xiaofuge=123
xiaobai=456
```

**案例**

```java
// 1. 获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager
Factory<org.apache.shiro.mgt.SecurityManager> factory =
        new IniSecurityManagerFactory("classpath:test-shiro.ini");

// 2. 得到SecurityManager实例 并绑定给SecurityUtils
org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();
SecurityUtils.setSecurityManager(securityManager);

// 3. 得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）
Subject subject = SecurityUtils.getSubject();

// 4. 默认提供的验证方式；UsernamePasswordToken
UsernamePasswordToken token = new UsernamePasswordToken("xiaofuge", "1234");

try {
    //5.1、登录，即身份验证
    subject.login(token);
} catch (AuthenticationException e) {
    //5.2、身份验证失败
    System.out.println("身份验证失败");
}
System.out.println(subject.isAuthenticated() ? "验证成功" : "验证失败");

// 6. 退出
subject.logout();
```

- 用于验证用户 xiaofuge 的密码 123，如果是1234 会提示验证失败。

### **Jwt 使用案例**

**编码**

```java
public static String encode(String issuer, long ttlMillis, Map<String, Object> claims) {
    if (null == claims) {
        claims = new HashMap<>();
    }
    // 签发时间（iat）：荷载部分的标准字段之一
    long nowMillis = System.currentTimeMillis();
    Date now = new Date(nowMillis);
    // 签发操作
    JwtBuilder builder = Jwts.builder()
            // 荷载部分
            .setClaims(claims)
            // 签发时间
            .setIssuedAt(now)
            // 签发人；类似 userId、userName
            .setSubject(issuer)
            // 设置生成签名的算法和秘钥
            .signWith(SignatureAlgorithm.HS256, signingKey);
    if (ttlMillis >= 0) {
        long expMillis = nowMillis + ttlMillis;
        Date exp = new Date(expMillis);
        // 过期时间（exp）：荷载部分的标准字段之一，代表这个 JWT 的有效期。
        builder.setExpiration(exp);
    }
    return builder.compact();
}
```

**解码**

```java
public static Claims decode(String token) {
    return Jwts.parser()
            // 设置签名的秘钥
            .setSigningKey(signingKey)
            // 设置需要解析的 jwt
            .parseClaimsJws(token)
            .getBody();
}

```

测试

```java
@Test
public void test_awt() {
    String issuer = "xiaofuge";
    long ttlMillis = 7 * 24 * 60 * 60 * 1000L;
    Map<String, Object> claims = new HashMap<>();
    claims.put("key", "xiaofuge");
    // 编码
    String token = JwtUtil.encode(issuer, ttlMillis, claims);
    System.out.println(token);
    // 解码
    Claims parser = JwtUtil.decode(token);
    System.out.println(parser.getSubject());
}

```

### 认证服务

网关不仅仅是用户名密码验证，也会在后续扩展一些其他的网络请求信息或者授权操作，所以我们需要单独提供一个 AuthenticationToken 和 AuthorizingRealm 验证领域的实现类

```java
public class AuthService implements IAuth {
    private Subject subject;
    public AuthService() {
        // 1. 获取 SecurityManager 工厂，此处使用 shiro.ini 配置文件初始化 SecurityManager
        Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
        // 2. 得到 SecurityManager 实例 并绑定给 SecurityUtils
        SecurityManager securityManager = factory.getInstance();
        SecurityUtils.setSecurityManager(securityManager);
        // 3. 得到 Subject 及 Token
        this.subject = SecurityUtils.getSubject();
    }
    
    @Override
    public boolean validate(String id, String token) {
        try {
            // 身份验证
            subject.login(new GatewayAuthorizingToken(id, token));
            // 返回结果
            return subject.isAuthenticated();
        } finally {
            // 退出
            subject.logout();
        }
    }
}
```

### STAR总结

Situation:引入shiro+jwt做权限认证

Task:

- 网关在接收到HTTP请求后，需要对这个请求做权限验证，再去请求下游服务接口 
- 权限验证，就是判断HTTP请求中是否携带了网关授予的Token，用来验证HTTP请求是否有效等，确保HTTP请求全流程安全可行 
-  引入Apache Shiro+Jwt做权限校验

> 其实方案还有很多比如redis+token，session+cookie
>
> 以及详细Jwt和shiro，可以看这里https://wx.zsxq.com/dweb2/index/topic_detail/584511815524844

Action:

-  在shiro.ini文件中添加全局变量[main]，将自定义的GatewayAuthorizingRealm作为SecurityManager指定的Realm，就是指定其为默认数据库 
- 使用JwtUtil构建一个token 
-  调用自定义的GatewayAuthorizingRealm解析token，如果JwtUtil的秘钥signingKey无法解析token， 则说明令牌无效，抛AuthenticationException，权限验证不通过

引入认证服务的网关

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/FnD3YXrEoCdBhHkfKrQrY2v1D77m)

Redis+token

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/FqN1xxJkrnmX-kvFCUAes3h5YJ51)

session+cookie

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/FjrPiCdW_Fh5rjUmYr548AcYwu-A)

## 网关会话鉴权处理

前面引入了 Shiro + JWT作为鉴权工具，本节需要 处理网络会话请求中对接口访问信息的一个鉴权处理。

一次网络请求经过 Netty 处理可以分为三段；消息接收、请求鉴权、消息处理。

这样就由原来我们只是在接收消息后直接把消息协议转换后请求到 RPC 服务，转换为多添加二层来处理简单的消息接收和请求鉴权。这里的请求鉴权就是基于引入的 Shrio + JWT 完成。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240313222618076.png" alt="image-20240313222618076" style="zoom:67%;" />

为了满足消息的处理和鉴权，本章需要再引入2个Netty消息处理的Handler；AuthorizationHandler、ProtocolDataHandler

- 【新增】AuthorizationHandler 做接口的鉴权
- 【新增】ProtocolDataHandler 做协议数据的处理
- 【修改】GatewayServerHandler 原有网络协议处理类，作为第一个Netty通信管道中的处理类，只做简单参数解析，保存到管道中后即可放行。—— 后续再有一些需要优先处理的逻辑也会放到这个 GatewayServerHandler 类里完成。