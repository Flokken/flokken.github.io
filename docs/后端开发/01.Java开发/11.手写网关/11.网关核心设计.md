---
title: 网关核心设计
date: 2024-03-11
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - 手写网关
---

## Http请求会话处理

### STAR总结

**Situation:**网关可以管理对应路径下的http请求，所以本节需要实现这个过程

**Task:**使用Netty框架创建一个Http服务器，，完成会话服务和对应处理

**Action**：新建SessionServerHandler类用于处理session， 新建一个SessionServer对Http请求响应



**API网关**的存在帮我们解决了需要搭建 SpringMVC 的包装 RPC 接口的过程，只需要把 RPC 接口注册到网关，**在经过 HTTP 访问就能直达 RPC 调用并返回结果**

HTTP请求到**API网关**，网关再去调用到对应的RPC服务，那么这样一个流程一次请求，小傅哥把它抽象为是做了一次**会话**操作

<img src="C:/Users/28788/AppData/Roaming/Typora/typora-user-images/image-20240311143257669.png" alt="image-20240311143257669" style="zoom: 67%;" />



核心实现类如下

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/FmjtN5DTGqoN7YBJdQEGTPw2zDAF" alt="img" style="zoom:50%;" />

- SessionServer 是用于启动 Netty 服务的，相当于你启动 Socket 的过程。而 Netty 的启动配置除了端口外，**还需要把对应数据的处理一并初始化到Channel管道中**，也就是对应的 SessionChannelInitializer 类的功能。
- 在 SessionChannelInitializer 类中包装了 HTTP Get/Post 协议的解析，同时还包括我们自己要完成的网络请求。也就是 SessionServerHandler 部分的内容。其实如果你了解一些Netty，那么把重点放到 SessionServerHandler 的实现即可，因为整个 Netty 的创建就相当于是一个模板结构，是固定的使用方式

**网络协议**

Netty 的通信会为每个连接上来的用户建立一条 Channle 管道（对应的 ChannelID 唯一），并在管道中插入一道道板子，这些板子可以是；编码器、解码器、流量整形、SSL、自定义服务处理等各类模块。通过这样的方式，让我们可以扩展各类功能。

HttpObjectAggregator 用于处理除了 GET 请求外的 POST 请求时候的对象信息，否则只有上面的信息，是拿不到 POST 请求的。*这就很像不断的在管道中添加板子，不同的板子处理不同的功能*

最后一个 SessionServerHandler 是**我们自己实现的会话处理**，用于拿到HTTP网络请求后，处理我们自己需要的业务逻辑。

```java
public class SessionChannelInitializer extends ChannelInitializer<SocketChannel> {
    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        ChannelPipeline line = channel.pipeline();
        line.addLast(new HttpRequestDecoder());
        line.addLast(new HttpResponseEncoder());
        line.addLast(new HttpObjectAggregator(1024 * 1024));
        line.addLast(new SessionServerHandler());
    }
}
```

**数据处理**

首先定义一个数据处理器基类

```java
public abstract class BaseHandler<T> extends SimpleChannelInboundHandler<T> {

    @Override
    //当channel接受到数据时，就调用session处理
    protected void channelRead0(ChannelHandlerContext ctx, T msg) throws Exception {
        session(ctx, ctx.channel(), msg);
    }

    protected abstract void session(ChannelHandlerContext ctx, final Channel channel, T request);

}

```

会话的核心处理在于接收到数据以后，比如根据请求的地址 `http://localhost/c/queryUserInfo` ... 解析，拿到对应的方法做后续的调用。目前没有服务所以不调用

```java
public  class SessionServerHandler extends BaseHandler<FullHttpRequest> {

    private final Logger logger = LoggerFactory.getLogger(SessionServerHandler.class);

    @Override
    protected void session(ChannelHandlerContext ctx, final Channel channel, FullHttpRequest request) {
        logger.info("网关接收请求 uri：{} method：{}", request.uri(), request.method());

        // 返回信息处理
        DefaultFullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
        // 返回信息控制
        response.content().writeBytes(JSON.toJSONBytes("你访问路径被网关管理了 URI：" + request.uri(), SerializerFeature.PrettyFormat));
        // 头部信息设置
        HttpHeaders heads = response.headers();
        // 返回内容类型
        heads.add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON + "; charset=UTF-8");
        // 响应体的长度
        heads.add(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
        // 配置持久连接
        heads.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);
        // 配置跨域访问
        heads.add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, "*");
        heads.add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, "*");
        heads.add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, "GET, POST, PUT, DELETE");
        heads.add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");

        channel.writeAndFlush(response);
    }

}
```

- DefaultFullHttpResponse 相当于就是在构建 HTTP 会话所需的协议信息，包括头信息、编码、响应体长度、跨域访问等。
- 这些信息中还包括了我们要向网页端返回的数据，也就是 response.content().writeBytes(...) 中写入的数据内容。

**服务创建**

Netty 本身就是一个 **Socket NIO 的包装**，所以也要包括对服务的启动处理，这里我们**实现 Callable 接口**，让服务在线程池中启动。

- EventLoopGroup 分别启动的是你的连接等待和数据处理，之后这里的 childHandler 添加的就是会话的初始信息。
- 当这些信息创建完成，绑定端口启动服务即可。**Netty服务器就会监听这个端口，处理这个端口来的Http请**求。

```java
public class SessionServer  implements Callable<Channel> {
    private final Logger logger = LoggerFactory.getLogger(SessionServer.class);

    private final EventLoopGroup boss = new NioEventLoopGroup(1);
    private final EventLoopGroup work = new NioEventLoopGroup();
    //EventLoopGroup是Netty提供的用以处理IO操作的多线程事件循环。
    // Netty为IO操作提供了两种EventLoopGroup，boss用于服务端接收客户端的连接，work用于进行Socket数据的读写。
    private io.netty.channel.Channel channel;
    @Override
    public Channel call() throws Exception {
        ChannelFuture channelFuture = null;
        try {
            ServerBootstrap b = new ServerBootstrap();
            //是服务端应用程序的启动助手，可以直接用它进行服务端Channel的初始化和启动
            b.group(boss, work)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childHandler(new SessionChannelInitializer());

            //绑定端口，等待绑定完成
            channelFuture = b.bind(new InetSocketAddress(7397)).syncUninterruptibly();
            this.channel = channelFuture.channel();
        } catch (Exception e) {
            logger.error("socket server start error.", e);
        } finally {
            if (null != channelFuture && channelFuture.isSuccess()) {
                logger.info("socket server start done.");
            } else {
                logger.error("socket server start error.");
            }
        }
        return channel;
    }
}
```

- 这里绑定了`7397`端口，所以所有这个端口下的请求都会交给网关（**本质是Netty服务器**）处理

**功能测试**

测试网关是否能管理对应路径下的Http请求

1. 创建 SessionServer 会话服务，交给线程池启动并检测服务的启动结果，当启动成功后开始网络请求；
2. 在浏览器输入：`http://localhost:7397/queryUserInfo` （任意名字，只要是这个端口即可）

```java
15:35:03.739 [main] INFO com.inet.gateway.test.ApiTest - NettyServer启动服务完成 /0:0:0:0:0:0:0:0:7397
15:35:19.037 [nioEventLoopGroup-3-2] DEBUG io.netty.buffer.AbstractByteBuf - -Dio.netty.buffer.checkAccessible: true
15:35:19.037 [nioEventLoopGroup-3-2] DEBUG io.netty.buffer.AbstractByteBuf - -Dio.netty.buffer.checkBounds: true
15:35:19.039 [nioEventLoopGroup-3-2] DEBUG io.netty.util.ResourceLeakDetectorFactory - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@1af3602
15:35:19.086 [nioEventLoopGroup-3-1] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.maxCapacityPerThread: 4096
15:35:19.086 [nioEventLoopGroup-3-1] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.ratio: 8
15:35:19.086 [nioEventLoopGroup-3-1] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.chunkSize: 32
15:35:19.086 [nioEventLoopGroup-3-1] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.blocking: false
15:35:19.098 [nioEventLoopGroup-3-1] INFO com.inet.gateway.session.handlers.SessionServerHandler - 网关接收请求 uri：/queryUserInfo method：GET
15:35:19.433 [nioEventLoopGroup-3-1] INFO com.inet.gateway.session.handlers.SessionServerHandler - 网关接收请求 uri：/favicon.ico method：GET
15:35:23.350 [nioEventLoopGroup-3-1] INFO com.inet.gateway.session.handlers.SessionServerHandler - 网关接收请求 uri：/queryUser method：GET
15:35:23.433 [nioEventLoopGroup-3-1] INFO com.inet.gateway.session.handlers.SessionServerHandler - 网关接收请求 uri：/favicon.ico method：GET

```

## 代理RPC泛化调用