---
title: Redis实战02
date: 2023-06-24
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Redis
---

> 黑马点评实战篇2

## 优惠券秒杀

业务介绍：每个店铺都可以发布优惠券：

![image-20230624095719242](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624095719242.png)

当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中**，而订单表如果使用数据库自增ID就存在一些问题**：

* **id的规律性太明显**
* **受单表数据量的限制**

场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。

场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。

### 全局ID生成器

**全局ID生成器**，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：



![image-20230624095734451](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624095734451.png)

#### 策略

**全局唯一ID策略**

- UUID
- Redis自增
- snowflake算法
- 数据库自增



> 这里使用redis拼接信息来当id

为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是在其之上拼接一些其它信息：

ID的组成部分：符号位：1bit，永远为0

![image-20230624100054596](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624100054596.png)

时间戳：31bit，以秒为单位，可以使用69年

序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID

优势：

- 每天一个key，方便统计
- ID是时间戳+计数器

util中新建RedisIdWorker

生成器

~~~java

@Component
public class RedisIdWorker {
    //开始时间戳
    private static final long BEGIN_TIMESTAMP= 1672531200;
    private static final int COUNT_BITS = 32;
    @Resource
    private  StringRedisTemplate stringRedisTemplate;

    public  Long nextId(String keyPrefix){
        //1生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        Long timestamp = nowSecond - BEGIN_TIMESTAMP;

        //2生成序列号
        //序列号生成利用redis的自增拼接时间是业务name实现
        String date =now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        //这里报可能产生空指针（因为这是自增key，但可能redis没有这个key），但由于当key不存在时，redis会自动创建一个，所以不会有空指针
        long count = stringRedisTemplate.opsForValue().increment("icr"+keyPrefix+":"+date);
        //拼接,利用位运算,这里之所以用或，是因为初始都是0，所以用或刚好
        return timestamp<<COUNT_BITS|count;
    }

    public static  void main(String args[]){
        //输入一个时间来生成时间戳
       LocalDateTime time=LocalDateTime.of(2023,1,1,0,0,0);
       //然后得到这个时间对应的秒数
       Long second = time.toEpochSecond(ZoneOffset.UTC);
        System.out.println(second);

    }
}

~~~

**并发测试**

~~~java
    @Resource
    private RedisIdWorker redisIdWorker;

    //测试并发要用的线程池
    private ExecutorService es = Executors.newFixedThreadPool(500);

    @Test
    void testIdWorker() throws InterruptedException {
        //并发生成id测试，这里是用300个线程生成3万个id
        CountDownLatch latch = new CountDownLatch(300);
        Runnable task = () ->{
            for(int i = 0;i<100;i++){
                long id = redisIdWorker.nextId("order");
                System.out.println("id = "+id);
            }
            latch.countDown();
        };
        long begin =System.currentTimeMillis();
        for(int i = 0;i<300;i++){
            es.submit(task);
        }

        latch.await();
        long end = System.currentTimeMillis();
        System.out.println("time="+(end-begin));
    }
~~~

补充：

关于countdownlatch

countdownlatch名为信号枪：**主要的作用是同步协调在多线程的等待于唤醒问题**

我们如果没有CountDownLatch ，**那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch**

CountDownLatch 中有两个最重要的方法

1、countDown

2、await

**await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行**，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。

### 优惠券秒杀下单

### 添加优惠卷

每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：

![image-20230624104833996](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624104833996.png)

**tb_voucher：优惠券的基本信息，优惠金额、使用规则等**
**tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息**

平价卷由于优惠力度并不是很大，所以是可以任意领取

而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段

> 注意，这里很坑，**只有当voucher的type为1时才是秒杀优惠券，并且前端只做了秒杀优惠券的抢购**

#### 实现

秒杀下单应该思考的内容：

下单时需要判断两点：

* 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
* 库存是否充足，不足则无法下单

下单核心逻辑分析：

**当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件**

**比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。**

![image-20230624111316392](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624111316392.png)

\VoucherOrderController配置要接口

~~~java
    @Resource
    private IVoucherOrderService voucherOrderService;
    @PostMapping("seckill/{id}")
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {

        return voucherOrderService.seckillVoucher(voucherId);
    }
~~~

在VoucherOrderServiceImple中新建方法

~~~java
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Override
    @Transactional
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId){
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if(voucher.getBeginTime().isAfter(LocalDateTime.now())){
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if(voucher.getEndTime().isBefore(LocalDateTime.now())){
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if(voucher.getStock()<1){
            return  Result.fail("库存不足！");
        }
        //5扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                .eq("voucher_id",voucherId).update();
        if (!success){
            return Result.fail("库存不足!");
        }
        //6创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        Long userId = UserHolder.getUser().getId();
        voucherOrder.setUserId(userId);

        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        // 返回结果
        return Result.ok(orderId);
    }
~~~

#### 超卖

但是上面的代码有问题，因为我们这是并发访问的线程。

> **也称为并发安全问题**

如下所示，如果一个线程在按照这种顺序访问，会把库存弄成负数

![image-20230624152138763](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624152138763.png)

**超卖问题是典型的多线程安全问题，解决方法可以是加锁**

![image-20230624152345309](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624152345309.png)

##### **悲观锁**

 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等

##### **乐观锁**

  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，**如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。**

![image-20230624153543587](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624153543587.png)

实现

~~~java
    //5扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                //.eq("voucher_id",voucherId).eq("stock",voucher.getStock())//where id=？ and stock = ...
                //这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败
                .eq("voucher_id",voucherId).gt("stock",voucher.getStock())//where id=？ and stock = ...
                .update();
        if (!success){
            return Result.fail("库存不足!");
        }
~~~

> CAS法比较的是相等，但这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败

**这里也体现了乐观锁的缺点，成功率低**

###### 测试

**这里使用就Jmeter测试时，一定要注意这个接口需要验证信息！**

需要先在这里面从前端中，把请求头参数加上，后端校验成功了才能正常测试

![image-20230624163808832](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624163808832.png)

![image-20230624164036093](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624164036093.png)

![image-20230624163704700](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624163704700.png)

##### 一人一单业务实现

优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单

![image-20230624164124494](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624164124494.png)

VoucherOrderServiceImpl  

可以这样做

~~~java
  // 5.一人一单逻辑
    // 5.1.用户id
    Long userId = UserHolder.getUser().getId();
    int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
    // 5.2.判断是否存在
    if (count > 0) {
        // 用户已经购买过了
        return Result.fail("用户已经购买过一次！");
    }
~~~

**但是这样做仍然有并发访问安全的问题，**比如一开始的时候，数据库，没有记录，此时假设100个线程都在执行这段代码，就会导致这里面产生了100订单记录。

所以仍然要加锁，**并且这里我们要对从查询到新增订单这一大段代码加锁（**因为业务应该是连续的一个原子操作，即一个用户只能买一次下单）

所以先封装这段逻辑

###### 加锁（重）

> 这部分对锁，事务，以及执行顺序有很好的示例**
>
> 还有spring的事务代理失效的问题等等
>
> synchronized,java同步锁关键字**



**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，**而现在是插入数据，所以我们需要使用悲观锁操作**

**注意：**在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁

```java
@Transactional
public synchronized Result createVoucherOrder(Long voucherId) {

	Long userId = UserHolder.getUser().getId();
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
}
```

，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制**锁粒度** 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：
intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法

> 根据查看源码得知，toString方法会new一个string对象，所以哪怕对于同一个id，其对应的对象地址也不一样，所以要用到intern（）方法，使得对于同样的id得到同样的对象地址
>
> 之所以要这样，是因为我们希望对于同一个id，应该只有一个锁，如果不用intern()方法，那实际上是对每个线程都加锁（因为id对应的string地址不一样）

```java
@Transactional
public  Result createVoucherOrder(Long voucherId) {
	Long userId = UserHolder.getUser().getId();
	synchronized(userId.toString().intern()){
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
    }
}
```

但是以上代码还是存在问题，**问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：**

在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度

> 也就是说，我们在调用方法的时候加锁，而不是在方法内部加锁了

![image-20230624174004533](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624174004533.png)

但是以上做法依然有问题，因为你调用的方法，**其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务**

> 这个是spring 的transaction注解的代理失效的几种情况之一

~~~java
 @Transactional
    public Result createVoucherOrder(Long voucherId)
@Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId)
~~~

我们看到，seckillVouche方法中是没有Transactional注解的，这this.的方式调用的，这个方法的事务是不会生效的。**这个时候，就要想到spring的对象代理了，我们需要获得原始的事务对象， 来操作事务**

> 解决

添加依赖

~~~xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>
~~~

application中添加开启代理暴露

~~~java
@EnableAspectJAutoProxy(exposeProxy = true)
~~~

VoucherOrderServiceImpl  

~~~java
  synchronized (userId.toString().intern()){
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
~~~

因此最终代码为：

~~~java

@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;


    @Transactional
    public Result createVoucherOrder(Long voucherId){//synchronized,java同步锁关键字
        // 5.一人一单逻辑
        // 5.1.用户id
        Long userId = UserHolder.getUser().getId();
       // synchronized (userId.toString().intern()){
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        //6扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                //.eq("voucher_id",voucherId).eq("stock",voucher.getStock())//where id=？ and stock = ...
                //这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败
                .eq("voucher_id",voucherId).gt("stock",0)//where id=？ and stock = ...
                .update();
        if (!success){
            return Result.fail("库存不足!");
        }
        //7创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        voucherOrder.setUserId(userId);

        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        // 返回结果
        return Result.ok(orderId);
        //}
    }
    @Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId) {
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足！");
        }
        Long userId = UserHolder.getUser().getId();
        synchronized (userId.toString().intern()){
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
    }

}

~~~

测试

200个线程并发买（用一个登录id）

最后只有一条记录（一个用户只能买一个），成功

> 注意jmeter的的登录头要看看过期没，这个端口要登录凭证的，我们

![image-20230624175143734](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175143734.png)

#### 集群

通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。

1.我们将服务启动两份，端口分别为8081和8082：

##### 复制服务，启动两个实例来模拟集群

![image-20230624175650551](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175650551.png)

![image-20230624175711440](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175711440.png)

2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：

~~~~properties

worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/json;

    sendfile        on;
    
    keepalive_timeout  65;

    server {
        listen       8080;
        server_name  localhost;
        # 指定前端项目所在的位置
        location / {
            root   html/hmdp;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }


        location /api {  
            default_type  application/json;
            #internal;  
            keepalive_timeout   30s;  
            keepalive_requests  1000;  
            #支持keep-alive  
            proxy_http_version 1.1;  
            rewrite /api(/.*) $1 break;  
            proxy_pass_request_headers on;
            #more_clear_input_headers Accept-Encoding;  
            proxy_next_upstream error timeout;  
            #proxy_pass http://127.0.0.1:8081;
            proxy_pass http://backend;
        }
    }

    upstream backend {
        server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;
        server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;
    }  
}

~~~~

> 配置文件说明
>
> 假设访问`localhsot:8080/api/voucher/list/1`,此时nginx也运行在8080端口，他就会把地址转发到  /api下的 `proxy_pass http://backend`，此时 upstream backend会在把请求均衡到其下面的两个服务。

将服务都启动之后，连续访问`localhsot:8080/api/voucher/list/1`两次,如果服务启动成功，那么两个服务的控制台都应该打印一次查询日志

![image-20230629153943098](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629153943098.png)

> 因为nginx默认轮询方式均载

#####  并发访问秒杀优惠券接口测试	

在同步锁内部打上断点如下，然后debug模式启动

![image-20230629160552287](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160552287.png)

postman同时开启两个接口访问`http://localhost:8080/api/voucher-order/seckill/7`

![image-20230629160814317](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160814317.png)

> 记得加Authorization

**此时可以发现。两个服务都进入了锁内部，此时已经有了线程安全问题**

![image-20230629160450912](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160450912.png)

![image-20230629160514355](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160514355.png)

**然后我们放行，最后发现同一用户购买了两次**

> 注意这里一个个放行是不会出现这个情况的，因为一个个放行还是相当于异步，可以一个个都调试到查询count=0那里放行，就会出现下面的问题

![image-20230629161715592](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629161715592.png)

##### 一人一单并发安全问题

为什么锁会失效？因为刚才用的同步锁是相对于jvm内部而言的（jvm用其内部的锁监视器来控制锁），但是一个对于一个单独的服务来说，他们各自有自己的jvm，**此时就会导致锁失效，进而导致线程安全问题**

> 由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。

![image-20230629162120914](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629162120914.png)

### 分布式锁

分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。

**分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路**

分布式锁应该具有以下特点（基本特征）：

- 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思

- 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行

- 高可用：程序不易崩溃，时时刻刻都保证较高的可用性

- 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能

- 安全性：安全也是程序中必不可少的一环

常见的分布式锁有三种

- Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见

- Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁？（主要从可用性考虑）

- Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案（主要从一致性考虑）

![image-20230629162827784](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629162827784.png)

#### Redis实现分布式锁

实现分布式锁时需要实现的两个基本方法：

* 获取锁：

  * 互斥：确保只能有一个线程获取锁

  > 命令
  >
  > `SET Lock thread1 NX EX 10`  添加一个锁，**NX是互斥，EX是设置超时时间**。**如果重复执行，成功返回true，失败返回nil（说明已经有一个锁并且存活）**
  >
  > `ttl lock`查看lock的存活时间

  * 非阻塞：尝试一次，成功返回true，失败返回false
  * 阻塞式：尝试失败后不会返回，而是等待

* 释放锁：

  * 手动释放
  * 超时释放：获取锁时添加一个超时时间

  `DEl key`删除某个锁

##### 分布式锁实现1

util包下创建

~~~java
public interface ILock {

    /**
     * 尝试获取锁
     * @param timeoutSec 锁持有的超时时间，过期后自动释放
     * @return
     */
    boolean tryLock(long timeoutSec);


    /**
     * 释放锁
     */
    void unlock();
}
~~~

然后实现SimpleRedisILock

~~~java

import org.springframework.data.redis.core.StringRedisTemplate;

import java.util.concurrent.TimeUnit;

public class SimpleRedisILock implements ILock{

    private String name;
    private StringRedisTemplate stringRedisTemplate;

    public SimpleRedisILock(String name, StringRedisTemplate stringRedisTemplate) {
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    private static final String KEY_PREFIX="lock";

    @Override
    public boolean tryLock(long timeoutSec) {

        //获取进程id
        long threadId = Thread.currentThread().getId();
        //获取锁
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX+name,threadId+"",timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    //这里为什么不返回success?因为Boolean转换为boolean会有自动拆箱的过程，可能出问题2
    //还有就是threadId+""会自动转换类型为String，这里起这样一个作用

    @Override
    public void unlock() {
        stringRedisTemplate.delete(KEY_PREFIX+name);

    }
}

~~~

> 注意：
>
> 为什么不返回success?因为Boolean转换为boolean会有自动拆箱的过程，可能出问题2
> threadId+""会自动转换类型为String，这里起这样一个作用

修改业务代码VoucherOrderServiceImpl（改动在第4步之后）

~~~java
	@Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId) {
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足！");
        }
        Long userId = UserHolder.getUser().getId();
		
        //创建锁对象并获取锁
        SimpleRedisILock lock = new SimpleRedisILock("order:"+userId,stringRedisTemplate);
        //获取锁
        boolean isLock = lock.tryLock(1200);
        //判断是否成功
        if(!isLock){
            //获取失败，返回错误或重试
            return Result.fail("不允许重复下单");
        }
        try{
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
        finally {
            //释放锁
            lock.unlock();
        }
    }
}
~~~

> 注意，这里为什么传userId？因为要控制锁的粒度（范围越小性能越好），针对我们的业务需求，不同的用户对应不同的锁，所以传userId

###### Redis分布式锁误删情况

持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明

解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。

![image-20230629174341944](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629174341944.png)

###### 改进分布式锁

Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：https://www.runoob.com/lua/lua-tutorial.html，**这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性**，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。

这里重点介绍Redis提供的调用函数，语法如下：

```lua
redis.call('命令名称', 'key', '其它参数', ...)
```

例如，我们要执行set name jack，则脚本是这样：

```lua
# 执行 set name jack
redis.call('set', 'name', 'jack')
```

例如，我们要先执行set name Rose，再执行get name，则脚本如下：

```lua
# 先执行 set name jack
redis.call('set', 'name', 'Rose')
# 再执行 get name
local name = redis.call('get', 'name')
# 返回
return name
```

写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下

例如，我们要执行 redis.call('set', 'name', 'jack') 这个脚本，语法如下：

如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：

接下来我们来回一下我们释放锁的逻辑：

释放锁的业务流程是这样的

​	1、获取锁中的线程标示

​	2、判断是否与指定的标示（当前线程标示）一致

​	3、如果一致则释放锁（删除）

​	4、如果不一致则什么都不做

如果用Lua脚本来表示则是这样的：

最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样

```lua
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示
-- 获取锁中的标示，判断是否与当前线程标示一致
if (redis.call('GET', KEYS[1]) == ARGV[1]) then
  -- 一致，则删除锁
  return redis.call('DEL', KEYS[1])
end
-- 不一致，则直接返回
return 0
```

