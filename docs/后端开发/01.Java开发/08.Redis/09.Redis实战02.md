---
title: Redis实战02
date: 2023-06-24
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Redis
---

> 黑马点评实战篇2

## 优惠券秒杀

业务介绍：每个店铺都可以发布优惠券：

![image-20230624095719242](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624095719242.png)

当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中**，而订单表如果使用数据库自增ID就存在一些问题**：

* **id的规律性太明显**
* **受单表数据量的限制**

场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。

场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。

### 全局ID生成器

**全局ID生成器**，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：



![image-20230624095734451](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624095734451.png)

#### 策略

**全局唯一ID策略**

- UUID
- Redis自增
- snowflake算法
- 数据库自增



> 这里使用redis拼接信息来当id

为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是在其之上拼接一些其它信息：

ID的组成部分：符号位：1bit，永远为0

![image-20230624100054596](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624100054596.png)

时间戳：31bit，以秒为单位，可以使用69年

序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID

优势：

- 每天一个key，方便统计
- ID是时间戳+计数器

util中新建RedisIdWorker

生成器

~~~java

@Component
public class RedisIdWorker {
    //开始时间戳
    private static final long BEGIN_TIMESTAMP= 1672531200;
    private static final int COUNT_BITS = 32;
    @Resource
    private  StringRedisTemplate stringRedisTemplate;

    public  Long nextId(String keyPrefix){
        //1生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        Long timestamp = nowSecond - BEGIN_TIMESTAMP;

        //2生成序列号
        //序列号生成利用redis的自增拼接时间是业务name实现
        String date =now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        //这里报可能产生空指针（因为这是自增key，但可能redis没有这个key），但由于当key不存在时，redis会自动创建一个，所以不会有空指针
        long count = stringRedisTemplate.opsForValue().increment("icr"+keyPrefix+":"+date);
        //拼接,利用位运算,这里之所以用或，是因为初始都是0，所以用或刚好
        return timestamp<<COUNT_BITS|count;
    }

    public static  void main(String args[]){
        //输入一个时间来生成时间戳
       LocalDateTime time=LocalDateTime.of(2023,1,1,0,0,0);
       //然后得到这个时间对应的秒数
       Long second = time.toEpochSecond(ZoneOffset.UTC);
        System.out.println(second);

    }
}

~~~

**并发测试**

~~~java
    @Resource
    private RedisIdWorker redisIdWorker;

    //测试并发要用的线程池
    private ExecutorService es = Executors.newFixedThreadPool(500);

    @Test
    void testIdWorker() throws InterruptedException {
        //并发生成id测试，这里是用300个线程生成3万个id
        CountDownLatch latch = new CountDownLatch(300);
        Runnable task = () ->{
            for(int i = 0;i<100;i++){
                long id = redisIdWorker.nextId("order");
                System.out.println("id = "+id);
            }
            latch.countDown();
        };
        long begin =System.currentTimeMillis();
        for(int i = 0;i<300;i++){
            es.submit(task);
        }

        latch.await();
        long end = System.currentTimeMillis();
        System.out.println("time="+(end-begin));
    }
~~~

补充：

关于countdownlatch

countdownlatch名为信号枪：**主要的作用是同步协调在多线程的等待于唤醒问题**

我们如果没有CountDownLatch ，**那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch**

CountDownLatch 中有两个最重要的方法

1、countDown

2、await

**await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行**，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。

### 优惠券秒杀下单

每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：

![image-20230624104833996](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624104833996.png)

**tb_voucher：优惠券的基本信息，优惠金额、使用规则等**
**tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息**

平价卷由于优惠力度并不是很大，所以是可以任意领取

而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段

> 注意，这里很坑，**只有当voucher的type为1时才是秒杀优惠券，并且前端只做了秒杀优惠券的抢购**

#### 实现

秒杀下单应该思考的内容：

下单时需要判断两点：

* 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
* 库存是否充足，不足则无法下单

下单核心逻辑分析：

**当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件**

**比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。**

![image-20230624111316392](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624111316392.png)

\VoucherOrderController配置要接口

~~~java
    @Resource
    private IVoucherOrderService voucherOrderService;
    @PostMapping("seckill/{id}")
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {

        return voucherOrderService.seckillVoucher(voucherId);
    }
~~~

在VoucherOrderServiceImple中新建方法

~~~java
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Override
    @Transactional
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId){
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if(voucher.getBeginTime().isAfter(LocalDateTime.now())){
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if(voucher.getEndTime().isBefore(LocalDateTime.now())){
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if(voucher.getStock()<1){
            return  Result.fail("库存不足！");
        }
        //5扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                .eq("voucher_id",voucherId).update();
        if (!success){
            return Result.fail("库存不足!");
        }
        //6创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        Long userId = UserHolder.getUser().getId();
        voucherOrder.setUserId(userId);

        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        // 返回结果
        return Result.ok(orderId);
    }
~~~

#### 超卖

但是上面的代码有问题，因为我们这是并发访问的线程。

> **也称为并发安全问题**

如下所示，如果一个线程在按照这种顺序访问，会把库存弄成负数

![image-20230624152138763](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624152138763.png)

**超卖问题是典型的多线程安全问题，解决方法可以是加锁**

![image-20230624152345309](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624152345309.png)

##### **悲观锁**

 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等

##### **乐观锁**

  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，**如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。**

![image-20230624153543587](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624153543587.png)

实现

~~~java
    //5扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                //.eq("voucher_id",voucherId).eq("stock",voucher.getStock())//where id=？ and stock = ...
                //这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败
                .eq("voucher_id",voucherId).gt("stock",voucher.getStock())//where id=？ and stock = ...
                .update();
        if (!success){
            return Result.fail("库存不足!");
        }
~~~

> CAS法比较的是相等，但这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败

**这里也体现了乐观锁的缺点，成功率低**

###### 测试

**这里使用就Jmeter测试时，一定要注意这个接口需要验证信息！**

需要先在这里面从前端中，把请求头参数加上，后端校验成功了才能正常测试

![image-20230624163808832](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624163808832.png)

![image-20230624164036093](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624164036093.png)

![image-20230624163704700](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624163704700.png)

##### 一人一单业务实现

优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单

![image-20230624164124494](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624164124494.png)

VoucherOrderServiceImpl  

可以这样做

~~~java
  // 5.一人一单逻辑
    // 5.1.用户id
    Long userId = UserHolder.getUser().getId();
    int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
    // 5.2.判断是否存在
    if (count > 0) {
        // 用户已经购买过了
        return Result.fail("用户已经购买过一次！");
    }
~~~

**但是这样做仍然有并发访问安全的问题，**比如一开始的时候，数据库，没有记录，此时假设100个线程都在执行这段代码，就会导致这里面产生了100订单记录。

所以仍然要加锁，**并且这里我们要对从查询到新增订单这一大段代码加锁（**因为业务应该是连续的一个原子操作，即一个用户只能买一次下单）

所以先封装这段逻辑

###### 加锁（重）

> 这部分对锁，事务，以及执行顺序有很好的示例**
>
> 还有spring的事务代理失效的问题等等
>
> synchronized,java同步锁关键字**



**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，**而现在是插入数据，所以我们需要使用悲观锁操作**

**注意：**在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁

```java
@Transactional
public synchronized Result createVoucherOrder(Long voucherId) {

	Long userId = UserHolder.getUser().getId();
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
}
```

，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制**锁粒度** 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：
intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法

> 根据查看源码得知，toString方法会new一个string对象，所以哪怕对于同一个id，其对应的对象地址也不一样，所以要用到intern（）方法，使得对于同样的id得到同样的对象地址
>
> 之所以要这样，是因为我们希望对于同一个id，应该只有一个锁，如果不用intern()方法，那实际上是对每个线程都加锁（因为id对应的string地址不一样）

```java
@Transactional
public  Result createVoucherOrder(Long voucherId) {
	Long userId = UserHolder.getUser().getId();
	synchronized(userId.toString().intern()){
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
    }
}
```

但是以上代码还是存在问题，**问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：**

在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度

> 也就是说，我们在调用方法的时候加锁，而不是在方法内部加锁了

![image-20230624174004533](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624174004533.png)

但是以上做法依然有问题，因为你调用的方法，**其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务**

> 这个是spring 的transaction注解的代理失效的几种情况之一

~~~java
 @Transactional
    public Result createVoucherOrder(Long voucherId)
@Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId)
~~~

我们看到，seckillVouche方法中是没有Transactional注解的，这this.的方式调用的，这个方法的事务是不会生效的。**这个时候，就要想到spring的对象代理了，我们需要获得原始的事务对象， 来操作事务**

> 解决

添加依赖

~~~xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>
~~~

application中添加开启代理暴露

~~~java
@EnableAspectJAutoProxy(exposeProxy = true)
~~~

VoucherOrderServiceImpl  

~~~java
  synchronized (userId.toString().intern()){
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
~~~

因此最终代码为：

~~~java

@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;


    @Transactional
    public Result createVoucherOrder(Long voucherId){//synchronized,java同步锁关键字
        // 5.一人一单逻辑
        // 5.1.用户id
        Long userId = UserHolder.getUser().getId();
       // synchronized (userId.toString().intern()){
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        //6扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                //.eq("voucher_id",voucherId).eq("stock",voucher.getStock())//where id=？ and stock = ...
                //这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败
                .eq("voucher_id",voucherId).gt("stock",0)//where id=？ and stock = ...
                .update();
        if (!success){
            return Result.fail("库存不足!");
        }
        //7创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        voucherOrder.setUserId(userId);

        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        // 返回结果
        return Result.ok(orderId);
        //}
    }
    @Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId) {
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足！");
        }
        Long userId = UserHolder.getUser().getId();
        synchronized (userId.toString().intern()){
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
    }

}

~~~

测试

200个线程并发买（用一个登录id）

最后只有一条记录（一个用户只能买一个），成功

> 注意jmeter的的登录头要看看过期没，这个端口要登录凭证的，我们

![image-20230624175143734](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175143734.png)

#### 集群

通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。

1.我们将服务启动两份，端口分别为8081和8082：

##### 复制服务，启动两个实例来模拟集群

![image-20230624175650551](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175650551.png)

![image-20230624175711440](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175711440.png)

2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：

~~~~properties

worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/json;

    sendfile        on;
    
    keepalive_timeout  65;

    server {
        listen       8080;
        server_name  localhost;
        # 指定前端项目所在的位置
        location / {
            root   html/hmdp;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }


        location /api {  
            default_type  application/json;
            #internal;  
            keepalive_timeout   30s;  
            keepalive_requests  1000;  
            #支持keep-alive  
            proxy_http_version 1.1;  
            rewrite /api(/.*) $1 break;  
            proxy_pass_request_headers on;
            #more_clear_input_headers Accept-Encoding;  
            proxy_next_upstream error timeout;  
            #proxy_pass http://127.0.0.1:8081;
            proxy_pass http://backend;
        }
    }

    upstream backend {
        server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;
        server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;
    }  
}

~~~~

> 配置文件说明
>
> 假设访问`localhsot:8080/api/voucher/list/1`,此时nginx也运行在8080端口，他就会把地址转发到  /api下的 `proxy_pass http://backend`，此时 upstream backend会在把请求均衡到其下面的两个服务。

将服务都启动之后，连续访问`localhsot:8080/api/voucher/list/1`两次,如果服务启动成功，那么两个服务的控制台都应该打印一次查询日志

![image-20230629153943098](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629153943098.png)

> 因为nginx默认轮询方式均载

#####  并发访问秒杀优惠券接口测试	

在同步锁内部打上断点如下，然后debug模式启动

![image-20230629160552287](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160552287.png)

postman同时开启两个接口访问`http://localhost:8080/api/voucher-order/seckill/7`

![image-20230629160814317](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160814317.png)

> 记得加Authorization

**此时可以发现。两个服务都进入了锁内部，此时已经有了线程安全问题**

![image-20230629160450912](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160450912.png)

![image-20230629160514355](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629160514355.png)

**然后我们放行，最后发现同一用户购买了两次**

> 注意这里一个个放行是不会出现这个情况的，因为一个个放行还是相当于异步，可以一个个都调试到查询count=0那里放行，就会出现下面的问题

![image-20230629161715592](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629161715592.png)

##### 一人一单并发安全问题

为什么锁会失效？因为刚才用的同步锁是相对于jvm内部而言的（jvm用其内部的锁监视器来控制锁），但是一个对于一个单独的服务来说，他们各自有自己的jvm，**此时就会导致锁失效，进而导致线程安全问题**

> 由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。

![image-20230629162120914](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629162120914.png)

### 分布式锁

分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。

**分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路**

分布式锁应该具有以下特点（基本特征）：

- 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思

- 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行

- 高可用：程序不易崩溃，时时刻刻都保证较高的可用性

- 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能

- 安全性：安全也是程序中必不可少的一环

常见的分布式锁有三种

- Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见

- Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁？（主要从可用性考虑）

- Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案（主要从一致性考虑）

![image-20230629162827784](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629162827784.png)

#### Redis实现分布式锁

实现分布式锁时需要实现的两个基本方法：

* 获取锁：

  * 互斥：确保只能有一个线程获取锁

  > 命令
  >
  > `SET Lock thread1 NX EX 10`  添加一个锁，**NX是互斥，EX是设置超时时间**。**如果重复执行，成功返回true，失败返回nil（说明已经有一个锁并且存活）**
  >
  > `ttl lock`查看lock的存活时间

  * 非阻塞：尝试一次，成功返回true，失败返回false
  * 阻塞式：尝试失败后不会返回，而是等待

* 释放锁：

  * 手动释放
  * 超时释放：获取锁时添加一个超时时间

  `DEl key`删除某个锁

##### 分布式锁实现

util包下创建

~~~java
public interface ILock {

    /**
     * 尝试获取锁
     * @param timeoutSec 锁持有的超时时间，过期后自动释放
     * @return
     */
    boolean tryLock(long timeoutSec);


    /**
     * 释放锁
     */
    void unlock();
}
~~~

然后实现SimpleRedisILock

~~~java

import org.springframework.data.redis.core.StringRedisTemplate;

import java.util.concurrent.TimeUnit;

public class SimpleRedisILock implements ILock{

    private String name;
    private StringRedisTemplate stringRedisTemplate;

    public SimpleRedisILock(String name, StringRedisTemplate stringRedisTemplate) {
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    private static final String KEY_PREFIX="lock";

    @Override
    public boolean tryLock(long timeoutSec) {

        //获取进程id
        long threadId = Thread.currentThread().getId();
        //获取锁
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX+name,threadId+"",timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    //这里为什么不返回success?因为Boolean转换为boolean会有自动拆箱的过程，可能出问题2
    //还有就是threadId+""会自动转换类型为String，这里起这样一个作用

    @Override
    public void unlock() {
        stringRedisTemplate.delete(KEY_PREFIX+name);

    }
}

~~~

> 注意：
>
> 为什么不返回success?因为Boolean转换为boolean会有自动拆箱的过程，可能出问题2
> threadId+""会自动转换类型为String，这里起这样一个作用

修改业务代码VoucherOrderServiceImpl（改动在第4步之后）

~~~java
	@Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId) {
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足！");
        }
        Long userId = UserHolder.getUser().getId();
		
        //创建锁对象并获取锁
        SimpleRedisILock lock = new SimpleRedisILock("order:"+userId,stringRedisTemplate);
        //获取锁
        boolean isLock = lock.tryLock(1200);
        //判断是否成功
        if(!isLock){
            //获取失败，返回错误或重试
            return Result.fail("不允许重复下单");
        }
        try{
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
        finally {
            //释放锁
            lock.unlock();
        }
    }
}
~~~

> 注意，这里为什么传userId？因为要控制锁的粒度（范围越小性能越好），针对我们的业务需求，不同的用户对应不同的锁，所以传userId

###### Redis分布式锁误删情况

持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，**而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明**

> 最主要原因就是线程1没有判断那个锁是不是自己的，所以应该在获取的时候锁上加一个标识，释放的时候根据标识判断线程是否自己所属

解决方案：**解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除**，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。

![image-20230629174341944](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230629174341944.png)

###### 改进分布式锁

改进点：

1 获取锁时存入value,线程id与uuid的拼接（线程id容易重复）

2释放锁时判断锁标识与当前标识

~~~java
  private static final String KEY_PREFIX="lock";

    private static final String ID_PREFIX = UUID.randomUUID()+"-";

    @Override
    public boolean tryLock(long timeoutSec) {

        //获取进程id
        String threadId =ID_PREFIX+ Thread.currentThread().getId();
        //获取锁
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX+name,threadId,timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    //这里为什么不返回success?因为Boolean转换为boolean会有自动拆箱的过程，可能出问题

    @Override
    public void unlock() {
        //获取线程标识
        String threadId =ID_PREFIX+ Thread.currentThread().getId();
        //获取锁的标识
        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX+name);
        if(threadId.equals(id)) {
            stringRedisTemplate.delete(KEY_PREFIX + name);
        }

    }
~~~

###### 原子性问题

上面的改进仍然可能存在问题，因为存在一种可能，线程1正要释放锁时产生了阻塞（比如因为垃圾回收机制），**并且他阻塞过程中引起了Redis锁的超时释放机制，并且此时线程2又去获取到了锁；然后线程1终于不堵塞了，但是把锁删了，**再次引起了线程安全问题。

**核心矛盾是要保证判断锁标识与释放锁是原子性操作，就能避免上述问题**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630094514335.png" style="zoom:80%">

###### Redis Lua 实现原子操作

> https://www.runoob.com/lua/lua-tutorial.html

Redis提供了Lua脚本功能，**在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性**。**这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性**，这样就可以实现拿锁比锁删锁是一个原子性动作了

这里重点介绍Redis提供的调用函数，语法如下：

```lua
redis.call('命令名称', 'key', '其它参数', ...)
```

例如，我们要执行set name jack，则脚本是这样：

```lua
# 执行 set name jack
redis.call('set', 'name', 'jack')
```

例如，我们要先执行set name Rose，再执行get name，则脚本如下：

```lua
# 先执行 set name jack
redis.call('set', 'name', 'Rose')
# 再执行 get name
local name = redis.call('get', 'name')
# 返回
return name
```

写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下

![image-20230630100113808](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630100113808.png)

例如，我们要执行 redis.call('set', 'name', 'jack') 这个脚本，语法如下：

![image-20230630100123628](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630100123628.png)

**如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：**

![image-20230630100448599](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630100448599.png)

>在Redis中，当使用 EVAL 命令执行 Lua 脚本时，可以通过传递参数将数据传递给脚本。这些参数可以分为两种类型：KEYS 和 ARGV解释如下：

1. KEYS 数组：
   - KEYS 数组包含传递给脚本的所有 Redis 键（key）参数。
   - Redis 键参数被解释为字符串，**并按照它们在 EVAL 命令中出现的顺序放入 KEYS 数组中**。
   - 在脚本中，可以使用 KEYS 数组来访问传递的 Redis 键参数。可以通过索引访问 KEYS 数组中的特定键，就像在 Lua 中访问数组一样。
2. ARGV 数组：
   - ARGV 数组包含传递给脚本的除 Redis 键参数之外的所有其他参数。
   - 这些参数可以是字符串、数字或其他数据类型，**并按照它们在 EVAL 命令中出现的顺序放入 ARGV 数组中。**
   - 在脚本中，可以使用 ARGV 数组来访问传递的其他参数。可以通过索引访问 ARGV 数组中的特定参数，就像在 Lua 中访问数组一样。

~~~lua
local key1 = KEYS[1]
local key2 = KEYS[2]
local arg1 = ARGV[1]
local arg2 = ARGV[2]

-- 在脚本中访问存入的参数
-- ...

~~~



**现在把上面比较锁和删除锁的逻辑用lua脚本表示如下**：

```lua
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示
-- 获取锁中的标示，判断是否与当前线程标示一致
if (redis.call('GET', KEYS[1]) == ARGV[1]) then
  -- 一致，则删除锁
  return redis.call('DEL', KEYS[1])
end
-- 不一致，则直接返回
return 0
```

**利用Redis Lua改进分布式锁**

> 解决超时误删问题

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630101606609.png"/>

在resource下写unlock脚本

~~~lua
if(redis.call('get',KEYS[1]) == ARGV[1]) then
    return redis.call('del',KEYS[1])
end
return 0
~~~

改进

~~~java
private static final DefaultRedisScript<Long>UNLOCK_SCRIPT;
static {
    UNLOCK_SCRIPT = new DefaultRedisScript<>();
    UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
    UNLOCK_SCRIPT.setResultType(Long.class);
}
@Override
public void unlock(){
    //调用lua脚本逻辑写在静态代码块里，以免每次都去加载lua脚本
    stringRedisTemplate.execute(
        UNLOCK_SCRIPT,
        Collections.singletonList(KEY_PREFIX+name),
        ID_PREFIX+Thread.currentThread().getId()
    );
}
~~~

###### 总结

基于Redis的分布式锁实现思路：

* 利用set nx ex获取锁，并设置过期时间，保存线程标示
* 释放锁时先判断线程标示是否与自己一致，一致则删除锁
  * 特性：
    * 利用set nx满足互斥性
    * 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性
    * 利用Redis集群保证高可用和高并发特性（更进一步）



#### 分布式锁-redission

基于setnx实现的分布式锁存在下面的问题：

- **重入问题**：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，

  比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。

- **不可重试**：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。

- **超时释放：**我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是超时释放的锁也可能存在安全隐患

- **主从一致性：** 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。

Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。

**也就是Redission封装了相关的Redis相关的操作集合，并且可以解决setnx来实现锁的问题**

>https://github.com/redisson/redisson

##### Quick-Start

引入依赖：

```java
<dependency>
	<groupId>org.redisson</groupId>
	<artifactId>redisson</artifactId>
	<version>3.13.6</version>
</dependency>
```

配置Redisson客户端：（这里主要是为了配置reddsion，yaml里配置的那个是配置spring继承的redis）

```java
@Configuration
public class RedissonConfig {
    @Bean
    public RedissonClient redissonClient(){
        // 配置
        Config config = new Config();
        config.useSingleServer().setAddress("redis://10.245.142.233:6379");
               /// .setPassword("123321");  有密码加上
        // 创建RedissonClient对象
        return Redisson.create(config);
    }
}
```

如何使用Redission的分布式锁,主要用到下面两个

```java
//获取锁(可重入)，指定锁的名称
RLock lock = redissonClient.getLock("anyLock");
//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位
boolean isLock = lock.tryLock(1,10,TimeUnit.SECONDS);
```

在 VoucherOrderServiceImpl

注入RedissonClient

```java
@Resource
private RedissonClient redissonClient;

@Override
public Result seckillVoucher(Long voucherId) {
       ///....和之前一样，下面才有改动
        Long userId = UserHolder.getUser().getId();
        //SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);
    	//改用分布式锁
        RLock lock = redissonClient.getLock("lock:order:" + userId);
        //获取锁对象
      	//tryLock三个参数，重试间隔时间，超时释放时间，时间单位
        //无参表示立刻重试，默认超时时间释放 	
        boolean isLock = lock.tryLock();
		//加锁失败
        if (!isLock) {
            return Result.fail("不允许重复下单");
        }
        try {
            //获取代理对象(事务)
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(voucherId);
        } finally {
            //释放锁
            lock.unlock();
        }
 }
```

##### 可重入锁

首先，可重入锁指的是同一个线程，当他获取锁之后，能够再次获取这个锁

> 我们之前用setnx是不能实现可重入锁的,以之前的流程，对于同一个线程的method2，获取锁会失败

**reddsion可以实现可重入锁**，在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，**假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1，同样的，当这个线程里的方法释放锁的时候，需也是state的值-1** 

![image-20230630162128616](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630162128616.png)

对于上面的流程比较复制，**为了保持操作原子性 ，reddision里也是用lua脚本实现的。**

对于获取锁和释放锁都是对应脚本实现，例如释放锁，**下面是Redission释放锁源码中的脚本**，其中的publish相当于广播一条消息，就是我把这个锁释放了

![image-20230630165342281](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630165342281.png)

>**KEYS[1] ： 锁名称**
>
>ARGV[1]：  锁失效时间
>
>ARGV[2]：  id + ":" + threadId; 锁的小key
>
>exists: 判断数据是否存在  name：是lock是否存在,如果==0，就表示当前这把锁不存在

##### 锁重试和WatchDog机制

Reddision通过tryLock()方法来实现锁的重试机制,其内部使用了看门狗和续约逻辑，主要得读源码，**leaseTime是重试等待时间，**

![image-20230630171207274](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630171207274.png)

>https://www.bilibili.com/video/BV1cr4y1671t/?p=67&spm_id_from=pageDriver&vd_source=d005def162a369d30cf8c241225a9395

##### 总结

Redission分布式锁原理

- 可重入：利用hash结构记录线程id和重入次数
- 可重试：利用信号量和Pub,Sub功能实现等待、唤醒、获取锁失败的重试机制
- 超时续约：时利用watchDog，每隔一段时间(releaseTime/3),重置超时时间（expire）,

##### Reddsion主从一致性

为了提高redis的可用性，我们会搭建Redis集群，现在以主从为例

此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。

![image-20230630215602045](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630215602045.png)

为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。

![image-20230630215615604](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630215615604.png)

那么MutiLock 加锁原理是什么呢？

当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.

 	![1653553093967](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653553093967.png)

![image-20230701100448879](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230701100448879.png)

### 秒杀逻辑优化

这是之前的秒杀下单逻辑，可以发现其逻辑是一个线程完成，其中有查询，减库存等操作数据库的操作比较耗时，所以高并发情况下，性能并没有那么好。



![image-20230630222402394](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630222402394.png)

优化逻辑：

我们将耗时比较短的逻辑判断放入到redis中，**这里是是否库存足够，比如是否一人一单，这样的操作**，

**只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功，** 

**再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，**这样程序就比较快，而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池

> 拓展，为什么不让其中的子任务分开写，比如查询订单，减库存等用不同线程执行？

![image-20230630222644370](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630222644370.png)

整体逻辑如下：

当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作

当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。

![image-20230630222853517](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230630222853517.png)

#### 实现

>key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些

#### 秒杀优化-Redis完成秒杀资格判断

需求：

* **新增秒杀优惠券的同时，将优惠券信息保存到Redis中**

* **基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功**

* 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列

* 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能


VoucherServiceImpl

```java
@Override
@Transactional
public void addSeckillVoucher(Voucher voucher) {
    // 保存优惠券
    save(voucher);
    // 保存秒杀信息
    SeckillVoucher seckillVoucher = new SeckillVoucher();
    seckillVoucher.setVoucherId(voucher.getId());
    seckillVoucher.setStock(voucher.getStock());
    seckillVoucher.setBeginTime(voucher.getBeginTime());
    seckillVoucher.setEndTime(voucher.getEndTime());
    seckillVoucherService.save(seckillVoucher);
    // 保存秒杀库存到Redis中
    //SECKILL_STOCK_KEY 这个变量定义在RedisConstans中
    //private static final String SECKILL_STOCK_KEY ="seckill:stock:"
    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());
}
```

完整lua表达式

```lua
-- 1.参数列表
-- 1.1.优惠券id
local voucherId = ARGV[1]
-- 1.2.用户id
local userId = ARGV[2]
-- 1.3.订单id
local orderId = ARGV[3]

-- 2.数据key
--Lua 的字符串连接操作符 ..可以拼接字符串
-- 2.1.库存key
local stockKey = 'seckill:stock:' .. voucherId
-- 2.2.订单key
local orderKey = 'seckill:order:' .. voucherId

-- 3.脚本业务
-- 3.1.判断库存是否充足 get stockKey
if(tonumber(redis.call('get', stockKey)) <= 0) then
    -- 3.2.库存不足，返回1
    return 1
end
-- 3.2.判断用户是否下单 SISMEMBER orderKey userId
if(redis.call('sismember', orderKey, userId) == 1) then
    -- 3.3.存在，说明是重复下单，返回2
    return 2
end
-- 3.4.扣库存 incrby stockKey -1
redis.call('incrby', stockKey, -1)
-- 3.5.下单（保存用户）sadd orderKey userId
redis.call('sadd', orderKey, userId)
-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...
redis.call('xadd', 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)
return 0
```

当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了

VoucherOrderServiceImpl

```java
@Override
public Result seckillVoucher(Long voucherId) {
    //获取用户
    Long userId = UserHolder.getUser().getId();
    long orderId = redisIdWorker.nextId("order");
    // 1.执行lua脚本
    Long result = stringRedisTemplate.execute(
            SECKILL_SCRIPT,
            Collections.emptyList(),
            voucherId.toString(), userId.toString(), String.valueOf(orderId)
    );
    int r = result.intValue();
    // 2.判断结果是否为0
    if (r != 0) {
        // 2.1.不为0 ，代表没有购买资格
        return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
    }
    //TODO 保存阻塞队列
    // 3.返回订单id
    return Result.ok(orderId);
}
```

####  秒杀优化-基于阻塞队列实现秒杀优化

阻塞队列：

当这个queue中没有元素时，会阻塞，等到有元素时才被唤醒执行

基于上一节，完成下面的需求

* 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列

* 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能

VoucherOrderServiceImpl

~~~java
/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author 虎哥
 * @since 2021-12-22
 */
@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Resource
    private RedissonClient redissonClient;

    private static final DefaultRedisScript<Long> SECKILL_SCRIPT ;
    static {
        SECKILL_SCRIPT = new DefaultRedisScript<>();
        SECKILL_SCRIPT.setLocation(new ClassPathResource("sekill.lua"));
        SECKILL_SCRIPT.setResultType(Long.class);
    }

    //阻塞队列
    private BlockingQueue<VoucherOrder>orderTasks = new ArrayBlockingQueue<>(1024*1024);
    //单个线程线程池
    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();

    //异步处理线程池

    //在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的
    @PostConstruct
    private void init() {
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    }

// 用于线程池处理的任务
// 当初始化完毕后，就会去从对列中去拿信息
    private class VoucherOrderHandler implements Runnable {

        @Override
        public void run() {
            while (true) {
                try {
                    // 1.获取队列中的订单信息
                    VoucherOrder voucherOrder = orderTasks.take();
                    // 2.创建订单
                    handleVoucherOrder(voucherOrder);
                } catch (Exception e) {
                    log.error("处理订单异常", e);
                }
            }
        }

        private void handleVoucherOrder(VoucherOrder voucherOrder) {
            //1.获取用户
            Long userId = voucherOrder.getUserId();
            // 2.创建锁对象
            RLock lock = redissonClient.getLock("lock:order" + userId);
            // 3.尝试获取锁
            boolean isLock = lock.tryLock();
            // 4.判断是否获得锁成功
            if (!isLock) {
                // 获取锁失败，直接返回失败或者重试
                log.error("不允许重复下单！");
                return;
            }
            try {
                //注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效
                //也是这里，因为又开了一个线程，所以后面proxy放在外面
                proxy.createVoucherOrder(voucherOrder);
            } finally {
                // 释放锁
                lock.unlock();
            }
        }
    }
    //上面内部类，下面是其他方法
    //这里需要把proxy放在外面
    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
    @Override
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        long orderId = redisIdWorker.nextId("order");
        // 1.执行lua脚本
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.emptyList(),
                voucherId.toString(), userId.toString(), String.valueOf(orderId)
        );
        int r = result.intValue();
        // 2.判断结果是否为0
        if (r != 0) {
            // 2.1.不为0 ，代表没有购买资格
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        VoucherOrder voucherOrder = new VoucherOrder();
        // 2.3.订单id
        voucherOrder.setId(orderId);
        // 2.4.用户id
        voucherOrder.setUserId(userId);
        // 2.5.代金券id
        voucherOrder.setVoucherId(voucherId);
        // 2.6.放入阻塞队列
        orderTasks.add(voucherOrder);
        //3.获取代理对象
        proxy = (IVoucherOrderService)AopContext.currentProxy();
        //4.返回订单id
        return Result.ok(orderId);
    }

    @Transactional
    public  void createVoucherOrder(VoucherOrder voucherOrder) {
        Long userId = voucherOrder.getUserId();
        // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherOrder.getVoucherId()).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            log.error("用户已经购买过了");
            return ;
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherOrder.getVoucherId()).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            log.error("库存不足");
            return ;
        }
        save(voucherOrder);

    }

}

~~~

#### 总结

秒杀业务的优化思路

* 先利用Redis完成库存余量、一人一单判断，完成抢单业务
* 再将下单业务放入阻塞队列，利用独立线程异步下单
* 基于阻塞队列的异步秒杀存在哪些问题？
  * 内存限制问题
  * 数据安全问题

### Redis消息队列

上一级使用的阻塞队列是在jvm里面的，但是存在内存限制问题和数据安全问题，因此这里是使用消息队列来解决

消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：

* 消息队列（Message Queue）：存储和管理消息，也被称为消息代理（Message Broker）
* 生产者：发送消息到消息队列
* 消费者：从消息队列获取消息并处理消息

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230703111546747.png" style="zoom:100%">

使用队列的好处在于 **解耦：**所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(**Message Queue**)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。

这种场景在我们秒杀中就变成了：**我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。**

**并且，消息队列独立于JVM，并且会做数据持久化操作，因此解决了上述的内存限制和数据安全问题**

消息队列有kafka，RabbitMq等等，当然也可以使用Redis带的mq去实现

**Redis可以使用list结构，PubSub，Stream三种结构来实现消息队列**

#### 基于List实现消息队列

**基于List结构模拟消息队列**

而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。

队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。
不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。

![image-20230703112502043](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230703112502043.png)

优点：

* 利用Redis存储，不受限于JVM内存上限
* 基于Redis的持久化机制，数据安全性有保证（因为Redis的链表就是一个他的一个数据结构，Redis会自己去把他持久化）
* 可以满足消息有序性

缺点：

* 无法避免消息丢失（因为RPOP操作马上就会删了数据，如果这时候服务拿走了却没处理，就会导致无法恢复了。
* 只支持单消费者(有时候需要多个消费者拿一条消息)

#### 基于PubSub的消息队列

PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。下面是**相关命令**

 SUBSCRIBE channel [channel] ：订阅一个或多个频道
 PUBLISH channel msg ：向一个频道发送消息
 PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道

基于PubSub的消息队列有哪些优缺点？

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230703153031516.png" style="zoom:80%">

优点：

* 采用发布订阅模型，支持多生产、多消费

缺点：

* 不支持数据持久化（因为这个是拿来做消息发送的）
* 无法避免消息丢失（如果channel没有被订阅，发送的消息会丢失）
* 消息堆积有上限，超出时数据丢失

#### 基于Stream的消息队列（重）

##### 单消费者

Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。

> **注意是数据类型，所以会自己持久化，保证了数据安全**

发送消息的命令：

![image-20230703153814535](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230703153814535.png)

例如：

![1653577349691](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653577349691.png)

读取消息的方式之一：XREAD

![1653577445413](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653577445413.png)

例如，使用XREAD读取第一个消息：

![1653577643629](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653577643629.png)

> Stream读取消息后，不会删除消息，其他消费者仍然可以读到消息

XREAD阻塞方式，读取最新的消息：

![1653577659166](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653577659166.png)

在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，**从而实现持续监听队列的效果**，伪代码如下

![1653577689129](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653577689129.png)

##### 消息漏读

注意：**当我们指定起始ID为$时，代表读取最新的消息，如<u>果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</u>**

STREAM类型消息队列的XREAD命令特点：

* **消息可回溯（没有删）**
* 一个消息可以被多个消费者读取
* 可以阻塞读取
* **有消息漏读的风险**

##### 消费者组

消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：

![1653577801668](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653577801668.png)

> 这个方法非常完善，01**加快了消息处理速度**；02**消息标识，记录最后一个被处理的消息可以确保消息不会漏读（区别于记录最新消息）**；
>
> 03**消息确认保证了Redis知道已经将消息处理完之后，再移除消息，避免了消息丢失。**

创建消费者组：

~~~shell
XGROUP CREATE key groupName ID [MKSTREAM]
~~~

key：队列名称
groupName：消费者组名称
ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息
MKSTREAM：队列不存在时自动创建队列
其它常见命令：

 **删除指定的消费者组**

```java
XGROUP DESTORY key groupName
```

 **给指定的消费者组添加消费者**

```java
XGROUP CREATECONSUMER key groupname consumername
```

 **删除消费者组中的指定消费者**

```java
XGROUP DELCONSUMER key groupname consumername
```

从消费者组读取消息：

```java
XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]
```

* group：消费组名称
* consumer：消费者名称，如果消费者不存在，会自动创建一个消费者
* count：本次查询的最大数量
* BLOCK milliseconds：当没有消息时最长等待时间
* NOACK：无需手动ACK，获取到消息后自动确认
* STREAMS key：指定队列名称
* ID：获取消息的起始ID：

">"：从下一个未消费的消息开始
其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始

消费者监听消息的基本思路：

![image-20230703175015604](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230703175015604.png)

* 消息可回溯
* 可以多消费者争抢消息，加快消费速度
* 可以阻塞读取
* 没有消息漏读的风险
* 有消息确认机制，保证消息至少被消费一次

最后我们来个小对比

![1653578560691](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1653578560691.png)

#### 基于Redis的Stream结构作为消息队列，实现异步秒杀下单

需求：

* 创建一个Stream类型的消息队列，名为stream.orders（直接进控制台加）
  * `XGROUP CREATE stream.orders g1 0 MKSTREAM`

* 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId
* 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单

修改lua表达式

~~~lua
-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...
redis.call('xadd', 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)
return 0
~~~

> 注意，必须先在redis-cl**i中创建对应的消息队列后才能运行，**不然一直循环报错
>
> 还有SET seckill:stock:7 200  ,因为之前把这个建同步到内存中，但是是在新增优惠卷的时候。如果我们正常走早就创建优惠券了。
>
> 还有就是需要auth,需要先开启nginx登录后，然后得到auth，复制到postman后，再去访问接口

然后VoucherOrderServiceImpl

~~~java

@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Resource
    private RedissonClient redissonClient;

    private static final DefaultRedisScript<Long> SECKILL_SCRIPT ;
    static {
        SECKILL_SCRIPT = new DefaultRedisScript<>();
        SECKILL_SCRIPT.setLocation(new ClassPathResource("sekill.lua"));
        SECKILL_SCRIPT.setResultType(Long.class);
    }

    //单个线程线程池
    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();

    //异步处理线程池

    //在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的
    @PostConstruct
    private void init() {
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    }


    private class VoucherOrderHandler implements Runnable {
        String queueName = "stream.orders";
        @Override
        public void run() {
            while (true) {
                try {
                    // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders >
                    List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                            Consumer.from("g1", "c1"),
                            StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),
                            StreamOffset.create(queueName, ReadOffset.lastConsumed())
                    );
                    // 2.判断订单信息是否为空
                    if (list == null || list.isEmpty()) {
                        // 如果为null，说明没有消息，继续下一次循环去再读消息
                        continue;
                    }
                    // 解析数据
                    MapRecord<String, Object, Object> record = list.get(0);
                    Map<Object, Object> value = record.getValue();
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                    // 3.创建订单
                    createVoucherOrder(voucherOrder);
                    // 4.确认消息 XACK
                    stringRedisTemplate.opsForStream().acknowledge(queueName, "g1", record.getId());
                } catch (Exception e) {
                    log.error("处理订单异常", e);
                    //处理异常消息
                    handlePendingList();
                }
            }
        }

        private void handlePendingList() {
            while (true) {
                try {
                    // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.order 0
                    List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                            Consumer.from("g1", "c1"),
                            StreamReadOptions.empty().count(1),
                            StreamOffset.create(queueName, ReadOffset.from("0"))
                    );
                    // 2.判断订单信息是否为空
                    if (list == null || list.isEmpty()) {
                        // 如果为null，说明没有异常消息，结束循环
                        break;
                    }
                    // 解析数据
                    MapRecord<String, Object, Object> record = list.get(0);
                    Map<Object, Object> value = record.getValue();
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                    // 3.创建订单
                    createVoucherOrder(voucherOrder);
                    // 4.确认消息 XACK
                    stringRedisTemplate.opsForStream().acknowledge("s1", "g1", record.getId());
                } catch (Exception e) {
                    log.error("处理pendding订单异常", e);
                    handlePendingList();
                    try{
                        Thread.sleep(20);
                    }catch(InterruptedException interruptedException){
                        interruptedException.printStackTrace();
                    }
                }
            }
        }
    }

    //这里需要把proxy放在外面
    IVoucherOrderService proxy ;
    @Override
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        long orderId = redisIdWorker.nextId("order");
        // 1.执行lua脚本，包括判断资格和发送信息到队列
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.emptyList(),
                voucherId.toString(), userId.toString(), String.valueOf(orderId)
        );
        int r = result.intValue();
        // 2.判断结果是否为0
        if (r != 0) {
            // 2.1.不为0 ，代表没有购买资格
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        //3.获取代理对象
        proxy = (IVoucherOrderService)AopContext.currentProxy();
        //4.返回订单id
        return Result.ok(orderId);
    }



    @Transactional
    public  void createVoucherOrder(VoucherOrder voucherOrder) {
        Long userId = voucherOrder.getUserId();
        // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherOrder.getVoucherId()).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            log.error("用户已经购买过了");
            return ;
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherOrder.getVoucherId()).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            log.error("库存不足");
            return ;
        }
        save(voucherOrder);

    }
}

~~~

