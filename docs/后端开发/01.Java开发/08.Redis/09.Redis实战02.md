---
title: Redis实战02
date: 2023-06-24
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Redis
---

> 黑马点评实战篇2

## 优惠券秒杀

业务介绍：每个店铺都可以发布优惠券：

![image-20230624095719242](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624095719242.png)

当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中**，而订单表如果使用数据库自增ID就存在一些问题**：

* **id的规律性太明显**
* **受单表数据量的限制**

场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。

场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。

### 全局ID生成器

**全局ID生成器**，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：



![image-20230624095734451](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624095734451.png)

#### 策略

**全局唯一ID策略**

- UUID
- Redis自增
- snowflake算法
- 数据库自增



> 这里使用redis拼接信息来当id

为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是在其之上拼接一些其它信息：

ID的组成部分：符号位：1bit，永远为0

![image-20230624100054596](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624100054596.png)

时间戳：31bit，以秒为单位，可以使用69年

序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID

优势：

- 每天一个key，方便统计
- ID是时间戳+计数器

util中新建RedisIdWorker

生成器

~~~java

@Component
public class RedisIdWorker {
    //开始时间戳
    private static final long BEGIN_TIMESTAMP= 1672531200;
    private static final int COUNT_BITS = 32;
    @Resource
    private  StringRedisTemplate stringRedisTemplate;

    public  Long nextId(String keyPrefix){
        //1生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        Long timestamp = nowSecond - BEGIN_TIMESTAMP;

        //2生成序列号
        //序列号生成利用redis的自增拼接时间是业务name实现
        String date =now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        //这里报可能产生空指针（因为这是自增key，但可能redis没有这个key），但由于当key不存在时，redis会自动创建一个，所以不会有空指针
        long count = stringRedisTemplate.opsForValue().increment("icr"+keyPrefix+":"+date);
        //拼接,利用位运算,这里之所以用或，是因为初始都是0，所以用或刚好
        return timestamp<<COUNT_BITS|count;
    }

    public static  void main(String args[]){
        //输入一个时间来生成时间戳
       LocalDateTime time=LocalDateTime.of(2023,1,1,0,0,0);
       //然后得到这个时间对应的秒数
       Long second = time.toEpochSecond(ZoneOffset.UTC);
        System.out.println(second);

    }
}

~~~

**并发测试**

~~~java
    @Resource
    private RedisIdWorker redisIdWorker;

    //测试并发要用的线程池
    private ExecutorService es = Executors.newFixedThreadPool(500);

    @Test
    void testIdWorker() throws InterruptedException {
        //并发生成id测试，这里是用300个线程生成3万个id
        CountDownLatch latch = new CountDownLatch(300);
        Runnable task = () ->{
            for(int i = 0;i<100;i++){
                long id = redisIdWorker.nextId("order");
                System.out.println("id = "+id);
            }
            latch.countDown();
        };
        long begin =System.currentTimeMillis();
        for(int i = 0;i<300;i++){
            es.submit(task);
        }

        latch.await();
        long end = System.currentTimeMillis();
        System.out.println("time="+(end-begin));
    }
~~~

补充：

关于countdownlatch

countdownlatch名为信号枪：**主要的作用是同步协调在多线程的等待于唤醒问题**

我们如果没有CountDownLatch ，**那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch**

CountDownLatch 中有两个最重要的方法

1、countDown

2、await

**await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行**，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。

### 优惠券秒杀下单

### 添加优惠卷

每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：

![image-20230624104833996](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624104833996.png)

**tb_voucher：优惠券的基本信息，优惠金额、使用规则等**
**tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息**

平价卷由于优惠力度并不是很大，所以是可以任意领取

而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段

> 注意，这里很坑，**只有当voucher的type为1时才是秒杀优惠券，并且前端只做了秒杀优惠券的抢购**

#### 实现

秒杀下单应该思考的内容：

下单时需要判断两点：

* 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
* 库存是否充足，不足则无法下单

下单核心逻辑分析：

**当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件**

**比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。**

![image-20230624111316392](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624111316392.png)

\VoucherOrderController配置要接口

~~~java
    @Resource
    private IVoucherOrderService voucherOrderService;
    @PostMapping("seckill/{id}")
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {

        return voucherOrderService.seckillVoucher(voucherId);
    }
~~~

在VoucherOrderServiceImple中新建方法

~~~java
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;

    @Override
    @Transactional
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId){
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if(voucher.getBeginTime().isAfter(LocalDateTime.now())){
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if(voucher.getEndTime().isBefore(LocalDateTime.now())){
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if(voucher.getStock()<1){
            return  Result.fail("库存不足！");
        }
        //5扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                .eq("voucher_id",voucherId).update();
        if (!success){
            return Result.fail("库存不足!");
        }
        //6创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        Long userId = UserHolder.getUser().getId();
        voucherOrder.setUserId(userId);

        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        // 返回结果
        return Result.ok(orderId);
    }
~~~

#### 超卖

但是上面的代码有问题，因为我们这是并发访问的线程。

> **也称为并发安全问题**

如下所示，如果一个线程在按照这种顺序访问，会把库存弄成负数

![image-20230624152138763](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624152138763.png)

**超卖问题是典型的多线程安全问题，解决方法可以是加锁**

![image-20230624152345309](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624152345309.png)

##### **悲观锁**

 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等

##### **乐观锁**

  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，**如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过。**

![image-20230624153543587](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624153543587.png)

实现

~~~java
    //5扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                //.eq("voucher_id",voucherId).eq("stock",voucher.getStock())//where id=？ and stock = ...
                //这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败
                .eq("voucher_id",voucherId).gt("stock",voucher.getStock())//where id=？ and stock = ...
                .update();
        if (!success){
            return Result.fail("库存不足!");
        }
~~~

> CAS法比较的是相等，但这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败

**这里也体现了乐观锁的缺点，成功率低**

###### 测试

**这里使用就Jmeter测试时，一定要注意这个接口需要验证信息！**

需要先在这里面从前端中，把请求头参数加上，后端校验成功了才能正常测试

![image-20230624163808832](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624163808832.png)

![image-20230624164036093](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624164036093.png)

![image-20230624163704700](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624163704700.png)

##### 一人一单业务实现

优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单

![image-20230624164124494](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624164124494.png)

VoucherOrderServiceImpl  

可以这样做

~~~java
  // 5.一人一单逻辑
    // 5.1.用户id
    Long userId = UserHolder.getUser().getId();
    int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
    // 5.2.判断是否存在
    if (count > 0) {
        // 用户已经购买过了
        return Result.fail("用户已经购买过一次！");
    }
~~~

**但是这样做仍然有并发访问安全的问题，**比如一开始的时候，数据库，没有记录，此时假设100个线程都在执行这段代码，就会导致这里面产生了100订单记录。

所以仍然要加锁，**并且这里我们要对从查询到新增订单这一大段代码加锁（**因为业务应该是连续的一个原子操作，即一个用户只能买一次下单）

所以先封装这段逻辑

###### 加锁（重）

> 这部分对锁，事务，以及执行顺序有很好的示例**
>
> 还有spring的事务代理失效的问题等等
>
> synchronized,java同步锁关键字**



**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，**而现在是插入数据，所以我们需要使用悲观锁操作**

**注意：**在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁

```java
@Transactional
public synchronized Result createVoucherOrder(Long voucherId) {

	Long userId = UserHolder.getUser().getId();
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
}
```

，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制**锁粒度** 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：
intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法

> 根据查看源码得知，toString方法会new一个string对象，所以哪怕对于同一个id，其对应的对象地址也不一样，所以要用到intern（）方法，使得对于同样的id得到同样的对象地址
>
> 之所以要这样，是因为我们希望对于同一个id，应该只有一个锁，如果不用intern()方法，那实际上是对每个线程都加锁（因为id对应的string地址不一样）

```java
@Transactional
public  Result createVoucherOrder(Long voucherId) {
	Long userId = UserHolder.getUser().getId();
	synchronized(userId.toString().intern()){
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
    }
}
```

但是以上代码还是存在问题，**问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：**

在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度

> 也就是说，我们在调用方法的时候加锁，而不是在方法内部加锁了

![image-20230624174004533](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624174004533.png)

但是以上做法依然有问题，因为你调用的方法，**其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务**

> 这个是spring 的transaction注解的代理失效的几种情况之一

~~~java
 @Transactional
    public Result createVoucherOrder(Long voucherId)
@Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId)
~~~

我们看到，seckillVouche方法中是没有Transactional注解的，这this.的方式调用的，这个方法的事务是不会生效的。**这个时候，就要想到spring的对象代理了，我们需要获得原始的事务对象， 来操作事务**

> 解决

添加依赖

~~~xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>
~~~

application中添加开启代理暴露

~~~java
@EnableAspectJAutoProxy(exposeProxy = true)
~~~

VoucherOrderServiceImpl  

~~~java
  synchronized (userId.toString().intern()){
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
~~~

因此最终代码为：

~~~java

@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Resource
    private RedisIdWorker redisIdWorker;


    @Transactional
    public Result createVoucherOrder(Long voucherId){//synchronized,java同步锁关键字
        // 5.一人一单逻辑
        // 5.1.用户id
        Long userId = UserHolder.getUser().getId();
       // synchronized (userId.toString().intern()){
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        //6扣减库存
        boolean success=seckillVoucherService.update()
                .setSql("stock = stock -1")
                //.eq("voucher_id",voucherId).eq("stock",voucher.getStock())//where id=？ and stock = ...
                //这里这个stock很特殊，只要大于0就还可以减，而用比较相等，会导致很多线程失败
                .eq("voucher_id",voucherId).gt("stock",0)//where id=？ and stock = ...
                .update();
        if (!success){
            return Result.fail("库存不足!");
        }
        //7创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        voucherOrder.setUserId(userId);

        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        // 返回结果
        return Result.ok(orderId);
        //}
    }
    @Override
    //库存减和订单增是两张表，所以加上事务控制
    public Result seckillVoucher(Long voucherId) {
        //1 查询秒杀优惠券信息
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀还没开始");
        }
        //3判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            return Result.fail("秒杀已经结束");
        }
        //4判断库存
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足！");
        }
        Long userId = UserHolder.getUser().getId();
        synchronized (userId.toString().intern()){
            //return this.createVoucherOrder(voucherId);
            //spring事务失效的几种可能性之一
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
            //这里还需要把createVoucherOrder加到接口方法里
            return  proxy.createVoucherOrder(voucherId);
        }
    }

}

~~~

测试

200个线程并发买（用一个登录id）

最后只有一条记录（一个用户只能买一个），成功

> 注意jmeter的的登录头要看看过期没，这个端口要登录凭证的，我们

![image-20230624175143734](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175143734.png)

#### 集群

通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。

1.我们将服务启动两份，端口分别为8081和8082：

复制服务，启动两个实例来模拟集群

![image-20230624175650551](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175650551.png)

![image-20230624175711440](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230624175711440.png)

2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：