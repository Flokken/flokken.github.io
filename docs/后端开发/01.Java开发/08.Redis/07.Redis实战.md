---
title: Redis实战01
date: 2023-06-21
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Redis
---

## 功能需求

基于提供的黑马点评项目，再利用Redis解决其中的一些功能

* 短信登录

这一块我们会使用redis共享session来实现

* 商户查询缓存

通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容

* 优惠卷秒杀

通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列

* 附近的商户

我们利用Redis的GEOHash来完成对于地理坐标的操作

* UV统计

主要是使用Redis来完成统计功能

* 用户签到

使用Redis的BitMap数据统计功能

* 好友关注

基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下

* 打人探店

基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能

以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis

![image-20230621214107520](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621214107520.png)

### 项目介绍

黑马点评数据表

![image-20230621220029450](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621220029450.png)

手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，**也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，**打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，**所以nginx是整个项目中重要的一环。**

在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，**会选择使用mysql集群，**同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，**同时使用Redis集群使得Redis对外提供更好的服务。**

![image-20230621215846438](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621215846438.png)

> 导入前后端项目过程这里略去
>
> windows运行nginx的命令是 `start ./nginx.exe`,并且目录中不能有中文



## 基于Session实现登录流程

### 验证码与登录

#### 验证码

**发送验证码：**

用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号

如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户

**短信验证码登录、注册：**

用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息

**校验登录状态:**

**用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行**

> 注意cookie中也存了session id

![image-20230621220606535](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621220606535.png)

~~~java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Override
    public Result sendCode(String phone, HttpSession session) {
        //1.校验手机号
        if (RegexUtils.isPhoneInvalid(phone)){
            //2.如果不符合，返回错误信息

            return Result.fail("手机号格式错误");
        }

        //3.符合，生成验证码
        String code = RandomUtil.randomNumbers(4);
        //4.保存验证码到session
        session.setAttribute("code",code);
        //5.发送验证码
        log.debug("验证码:"+code);
        //6.返回结果
        return Result.ok();
    }
}
//controller
    @PostMapping("code")
    public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {
        // TODO 发送短信验证码并保存验证码
        return userService.sendCode(phone,session);
    }
~~~

#### 登录

~~~java
//UserServiceImpl  
@Override
    public Result login(LoginFormDTO loginForm,HttpSession session) {
        //1.校验手机号
        String phone = loginForm.getPhone();
        if (RegexUtils.isPhoneInvalid(phone)){
            return Result.fail("手机号格式错误");
        }
        //2.校验验证码
        Object cacheCode = session.getAttribute("code");
        String code = loginForm.getCode();
        if(cacheCode == null || !cacheCode.toString().equals(code)){
            //3.不一致报错
            return Result.fail("验证码错误");
        }
        //4.一致，根据手机号查询用户select * from tb_user where phone = ? MP对应的语句

        //query(),save()这些都是mp提供的方法
        User user=query().eq("phone",phone).one();

        //5.判断用户是否存在
        if(user == null){
            //6.不存在则创建
            user = createUserWithPhone(phone);
        }
        //7.保存用户信息到session中
        session.setAttribute("user",user);
        return Result.ok();
    }

    private User createUserWithPhone(String phone) {
        User user = new User();
        user.setPhone(phone);
        //随机生成昵称
        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));
        save(user);

        return user;
    }
~~~



### 实现登录拦截功能：

为什么要拦截？因为当用户访问请求时，我们应该去查看一下他是否登录**，这样每个服务都要写一遍这个验证是否登录的功能，这样很麻烦，因此可以使用拦截器来验证**

> 也就是可以用拦截器来帮助我们验证用户，同时使用threadlocal来发送用户信息到服务

>

![image-20230622103636190](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230622103636190.png)

![image-20230621221006988](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621221006988.png)

>与瑞吉外卖拦截器也一样思路
>
>





当用户发起请求时，**会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接**，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应

**通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据**

>tomcat的运行原理

![image-20230621220941252](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621220941252.png)

> 关于threadlocal
>
> 如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，**所以可以通过这种方式来做到线程隔离**

拦截器代码

```Java
public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
       //1.获取session
        HttpSession session = request.getSession();
        //2.获取session中的用户
        Object user = session.getAttribute("user");
        //3.判断用户是否存在
        if(user == null){
              //4.不存在，拦截，返回401状态码
              response.setStatus(401);
              return false;
        }
        //5.存在，保存用户信息到Threadlocal
        UserHolder.saveUser((User)user);
        //6.放行
        return true;
    }
}
```

让拦截器生效

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/shop/**",
                        "/voucher/**",
                        "/shop-type/**",
                        "/upload/**",
                        "/blog/hot",
                        "/user/code",
                        "/user/login"
                ).order(1);
        // token刷新的拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns("/**").order(0);
    }
}
```

### 隐藏用户敏感信息

![image-20230622114539311](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230622114539311.png)

我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，**将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了**

并且这样可以让服务器少存一些没必要的数据，减轻服务器压力

**在登录方法处修改**

```java
//7.保存用户信息到session中
session.setAttribute("user", BeanUtil.copyProperties(user,UserDTO.class));
//注意是BeanUtil，而不是BeanUtils
```

**在拦截器处：**

```java
//5.存在，保存用户信息到Threadlocal
UserHolder.saveUser((UserDTO) user);
```

**在UserHolder处：将user对象换成UserDTO**

```java
public class UserHolder {
    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();

    public static void saveUser(UserDTO user){
        tl.set(user);
    }

    public static UserDTO getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

这里也需要修改

![image-20230622115951807](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230622115951807.png)

### session共享问题

![image-20230621221445770](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621221445770.png)

**核心思路分析：**

每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？

早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了

但是这种方案具有两个大问题

1、每台服务器中都有完整的一份session数据，服务器压力过大。

2、session拷贝数据时，可能会出现延迟

#### 解决办法

**基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了**

### 使用Redis替代session的业务流程

#### 存储结构设计

首先思考要存入的数据，无非就是用户和code，所以可以使用String结构，就是一个简单的key，value键值对的方式

在设计这个key的时候，需要满足两点

1、key要具有唯一性

2、key要方便携带

如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适**，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了**

> 因为手机号是唯一的，所以这里拿来当key了

对于value数据，因为是单个对象，可以用String也可以用Hash结构。

![image-20230622120615950](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230622120615950.png)

#### 新的登录流程

当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。

> token来替代phone当key，然后value是用户数据，因为要频繁访问用户信息，如果一直让前端传phone来访问，容易泄露信息

![image-20230622120751956](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230622120751956.png)

![image-20230621222833634](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621222833634.png)

sendCode

~~~java
    @Resource
    private StringRedisTemplate stringRedisTemplate;
	//注意这里用的注解是@Resource

    @Override
    public Result sendCode(String phone, HttpSession session) {
        //1.校验手机号
        if (RegexUtils.isPhoneInvalid(phone)){
            //2.如果不符合，返回错误信息

            return Result.fail("手机号格式错误");
        }

        //3.符合，生成验证码
        String code = RandomUtil.randomNumbers(4);
        //4.保存验证码到session
        //session.setAttribute("code",code);
        //一般会加上一些前缀来避免key冲突,LOGIN_CODE_KEY=login:code,LOGIN_CODE_TTL=2L
        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);
        //5.发送验证码
        log.debug("验证码:"+code);
        //6.返回结果
        return Result.ok();
    }
~~~



**UserServiceImpl代码**

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
    // 1.校验手机号
    String phone = loginForm.getPhone();
    if (RegexUtils.isPhoneInvalid(phone)) {
        // 2.如果不符合，返回错误信息
        return Result.fail("手机号格式错误！");
    }
    // 3.从redis获取验证码并校验
    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);
    String code = loginForm.getCode();
    if (cacheCode == null || !cacheCode.equals(code)) {
        // 不一致，报错
        return Result.fail("验证码错误");
    }

    // 4.一致，根据手机号查询用户 select * from tb_user where phone = ?
    User user = query().eq("phone", phone).one();

    // 5.判断用户是否存在
    if (user == null) {
        // 6.不存在，创建新用户并保存
        user = createUserWithPhone(phone);
    }

    // 7.保存用户信息到 redis中
    // 7.1.随机生成token，作为登录令牌
    String token = UUID.randomUUID().toString(true);
    // 7.2.将User对象转为HashMap存储
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
         //注意我们用的是StringTemplate，因此这里要把存的value的所有字段值都转成String
        //比如UserDTO中的id是Long，如果不转，会报long 不能自动转成string

    Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),
            CopyOptions.create()
                    .setIgnoreNullValue(true)
                    .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));
    // 7.3.存储
    String tokenKey = LOGIN_USER_KEY + token;
    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);
    // 7.4.设置token有效期
    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);

    // 8.返回token
    return Result.ok(token);
}
```

####  状态登录刷新问题

我们设置的token的有效期是30min，也就是redis，30min后会丢弃对应的数据，**但是，这个时间应该从用户最后一次访问算起，而不是一开始登录了算起,如何实现？使用拦截器实现**

##### 初始思路总结：

在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的

![image-20230621222942630](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230621222942630.png)

代码:

~~~java
//WebMvcConfig
	@Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry){
        //传入stringRedisTemplate
        registry.addInterceptor(new LoginInterceptor(stringRedisTemplate))
                .excludePathPatterns(
                        //把不需要验证的接口路径排除掉
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/shop/**",
                        "/upload/**",
                        "/user/login",
                        "/shop-type/**",
                        "/voucher/**"
                );
    }

//LoginInterceptor
public class LoginInterceptor implements HandlerInterceptor {

    //注意，这个类没有交给Spring管理（注意没有加@component这些注解），因此这里的stringRedisTemplate不能用@Autowired注入
    private StringRedisTemplate stringRedisTemplate;
    //所以这里构建这个对象时传参，传入stringRedisTemplate，因为是webmvc用这个对象，并且webmvc是spring管理的，因此可以在webmvc中注入了再传过来了
    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;

    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1.获取请求头中的token
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)) {
            return true;
        }
        // 2.基于TOKEN获取redis中的用户
        String key  = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);
        // 3.判断用户是否存在
        if (userMap.isEmpty()) {
            return true;
        }
        // 5.将查询到的hash数据转为UserDTO
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        // 6.存在，保存用户信息到 ThreadLocal
        UserHolder.saveUser(userDTO);
        // 7.刷新token有效期
        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);
        // 8.放行
        return true;
    }

    @Override
    public  void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception{
        //移除用户,避免内存泄露
        UserHolder.removeUser();
    }
}

~~~

##### 优化方案

**既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌**，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。

![image-20230622215122450](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230622215122450.png)

**webmvc**

~~~java
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry){
        //使用order控制执行顺序，小的先执行
        //登录拦截器，拦截需要登录后才能访问的请求
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        //把不需要验证的接口路径排除掉
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/shop/**",
                        "/upload/**",
                        "/user/login",
                        "/shop-type/**",
                        "/voucher/**"
                ).order(1);
        //刷新拦截器，拦截一切请求
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns("/**").order(0);

    }
~~~

**RefreshTokenInterceptor**

> 这个拦截器的作用是刷新token有效期，并且只判断有authorization的请求，也就是需要用到token的请求（需要登录后访问的请求才有token）

```java
public class RefreshTokenInterceptor implements HandlerInterceptor {

    private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1.获取请求头中的token
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)) {
            //没有authorization的直接放行
            return true;
        }
        // 2.基于TOKEN获取redis中的用户
        String key  = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);
        // 3.判断用户是否存在
        if (userMap.isEmpty()) {
            //
            return true;
        }
        // 5.将查询到的hash数据转为UserDTO
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        // 6.存在，保存用户信息到 ThreadLocal
        UserHolder.saveUser(userDTO);
        // 7.刷新token有效期
        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);
        // 8.放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户
        UserHolder.removeUser();
    }
}
	
```

**LoginInterceptor**

```java
public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1.判断是否需要拦截（ThreadLocal中是否有用户）
        if (UserHolder.getUser() == null) {
            // 没有，需要拦截，设置状态码
            response.setStatus(401);
            // 拦截
            return false;
        }
        // 有用户，则放行
        return true;
    }
}
```

## 缓存商户数据

> 缓存是数据交换的缓冲区(Cache),是存储数据的临时地方，读写性能高，当然成本比较高
>
> 缓存好处：
>
> 降低后端负载
>
> 提高读写效率，降低响应时间（Redis读写时间是微妙级）

![image-20230623101031189](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623101031189.png)

ShopController提供相关接口，从数据中读取商户数据，现在往里面添加缓存，当然，由于业务比较复杂，所以具体代码在service里写

~~~java

@Service
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result queryById(Long id) {
        //1 从redis中查询商铺缓存,这里用string存储value
        String key = CACHE_SHOP_KEY+id;
        String shopJson=stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+id);
        //2 判断是否存在
        if(StrUtil.isNotBlank(shopJson)){
            //3 存在则返回
            Shop shop  = JSONUtil.toBean(shopJson,Shop.class);
            return Result.ok(shop);
        }
        //4 不存在，根据id查询数据库,这是MP提供的方法
        Shop shop = getById(id);
        //5 不存在，返回错误
        if (shop == null){
            return Result.fail("店铺不存在");
        }
        //6 存在，写入redis
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));
        //7 返回信息
        return Result.ok(shop);
    }
~~~

练习，shoplist接口返回的是商户类型，把他也加入缓存

> 唯一的区别是这个需要的是list，这里value依然选择是string
>
> 相关Controller是shoptypeController

~~~java
@Service
public class ShopTypeServiceImpl extends ServiceImpl<ShopTypeMapper, ShopType> implements IShopTypeService {

    @Resource
    private  StringRedisTemplate stringRedisTemplate;

    @Override
    public Result queryTypeList() {
        //1 从Redis中查商铺类型数据
        String key =CACHE_SHOPLIST_KEY;
        //这里存的value是string类型
        String shopTypeListJsons = stringRedisTemplate.opsForValue().get(key);
        //2 存在则直接返回
        if (StrUtil.isNotBlank(shopTypeListJsons)){
            //返回给前端的应该是Json数据,JSONUtil.toList可以把JSON集合字符串转换为对应的java json list
            List<ShopType>shopTypesList = JSONUtil.toList(shopTypeListJsons,ShopType.class);
            return Result.ok(shopTypesList);
        }
        //3 没在redis里就去查数据库
        List<ShopType> typeList = query().orderByAsc("sort").list();
        //4 如果没有分类数据
        if(typeList == null){
            return Result.fail("没找到店铺类型");
        }
        //5 把数据存到redis
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(typeList));
        // 6返回去查询到的数据
        return Result.ok(typeList);
    }
}
~~~

### 缓存更新策略

缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。

但是数据库内容是会变化的，这时候缓存的内容还没变化，**就会引起数据不一致的问题。**

![image-20230623111741878](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623111741878.png)

#### 数据库缓存不一致

由于我们的**缓存的数据源来自于数据库**,而数据库的**数据是会发生变化的**,因此,如果当数据库中**数据发生变化,而缓存却没有同步**,此时就会有**一致性问题存在**,其后果是:

用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案

![image-20230623112005571](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623112005571.png)

> 第三种方法也叫**写回**
>
> 第一种简单，**易于实现，所以后面的内容都是由第一种（Cache Aside Pattern）来展开的**

#### 三个问题（Cache Aside）

操作缓存和数据库时有三个问题需要考虑：

- 删除缓存还是更新缓存？
  * 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  * 删除缓存：更新数据库时让缓存失效，查询时再更新缓存

>删除缓存还是更新缓存，如果采用第一个方案即更新缓存，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来
>
>**所以选择删除缓存比较好**

- 如何保证缓存与数据库的操作的同时成功或失败（**原子性**）？
  * 单体系统，将缓存与数据库操作放在一个事务
  * 分布式系统，利用TCC等分布式事务方案

* 先操作缓存还是先操作数据库？
  * 先删除缓存，再操作数据库
  * 先操作数据库，再删除缓存

应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，**如果你选择第一种方案**，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。

> 假设数据库的值由10更新为20，一开始缓存和数据库值都是10
>
> 两种方案都有可能冲突，但由于写redis操作快，而更新数据库操作慢，**所以实际上第二种情况发送可能性很低，第一种很高，所以第二种更好**
>
> 对于第二种可能的错误，可以再加一个超时更新来兜底
>
> 因此选择先操作数据库，后删除缓存

![image-20230623112528025](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623112528025.png)

#### 最佳实践

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623113325567.png" style="zoom:70%">

> 主动更新就是要自己写代码逻辑

#### 实现商铺和缓存与数据库双写一致

> 也就是给查询商铺的缓存添加超时剔除和主动更新的策略

核心思路如下：

修改ShopController中的业务逻辑，满足下面的需求：

根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间

根据id修改店铺时，先修改数据库，再删除缓存

**修改重点代码1**：修改**ShopServiceImpl**的queryById方法

**设置redis缓存时添加过期时间**

~~~java
//ShopServiceImpl 存入数据时设置超时时间 
stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);

~~~

**修改重点代码2**

根据最佳实践，我们先修改了数据之后，然后把缓存中的数据进行删除，

查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题

~~~java
	@Override
    @Transactional
    public Result update(Shop shop) {
        Long id = shop.getId();
        if(id == null){
            return Result.fail("店铺id不能为空");
        }
        //单体项目，所以可以用 @Transactional来保证原子性，然后根据最佳实践，先更新数据库，然后删除缓存
        //1 更新数据库
        updateById(shop);
        //2 删除缓存
        stringRedisTemplate.delete(CACHE_SHOP_KEY+id);
        return Result.ok();
    }
~~~

### 缓存穿透

**缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。**

常见的解决方案有两种：

* 缓存空对象
  * 优点：实现简单，维护方便
  * 缺点：
    * 额外的内存消耗
    * 可能造成短期的不一致
* 布隆过滤
  * 优点：内存占用较少，没有多余key
  * 缺点：
    * 实现复杂
    * **存在误判可能（即不是100%能判断成功）**

![image-20230623115418761](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623115418761.png)

#### 商铺缓存穿透解决

这里利用**缓存空对象**的方法来解决缓存穿透

在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的

现在的逻辑中：

1 如果这个数据不存在，**会把这个数据写入到Redis中，并且将value设置为空，然后再返回404**

2 当再次发起查询时，我们如果发现命中之后，**判断这个value是否是null，如果是null，则是之前写入的数据**，**证明是缓存穿透数据（返回404）**，如果不是，则直接返回数据。

![image-20230623152945069](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623152945069.png)

~~~java
 @Override
    public Result queryById(Long id) {
        //1 从redis中查询商铺缓存,这里用string存储value
        String key = CACHE_SHOP_KEY+id;
        String shopJson=stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+id);
        //2 判断是否存在
        if(StrUtil.isNotBlank(shopJson)){
            //3 存在则返回
            Shop shop  = JSONUtil.toBean(shopJson,Shop.class);
            return Result.ok(shop);
        }
        //判断是否是空值
        //这里注意isNotBlank当字符串为""或者是null时返回false，因此这里再判断其不是null，那说明是我们写入的空字符串
        if(shopJson!=null){
            return Result.fail("店铺信息不存在");
        }
        //4 不存在，根据id查询数据库,这是MP提供的方法
        Shop shop = getById(id);
        //5 不存在，返回错误
        if (shop == null){
            stringRedisTemplate.opsForValue().set(key,"",CACHE_NULL_TTL,TimeUnit.MINUTES);
            return Result.fail("店铺不存在");
        }
        //6 存在，写入redis
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);
        //7 返回信息
        return Result.ok(shop);
    }
~~~

缓存穿透产生的原因是什么？

* 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力

缓存穿透的解决方案有哪些？

* **缓存null值**
* 布隆过滤
* 增强id的复杂度，避免被猜测id规律
* 做好数据的基础格式校验
* 加强用户权限校验
* **做好热点参数的限流**

### 缓存雪崩

**缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。**

解决方案：

* **给不同的Key的TTL添加随机值**

> 比如当前有很多缓存同时到期，这个时候就会导致大量的缓存key同时失效

* **利用Redis集群提高服务的可用性**
* 给缓存业务添加降级限流策略
* 给业务添加多级缓存

![image-20230623155904834](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623155904834.png)

### 缓存击穿

**缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了（TTL），无数的请求访问会在瞬间给数据库带来巨大的冲击。**

>比如有很多个线程，假设线程1在查询缓存之后，发现没有，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，
>
>但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，**那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大，这就导致了缓存击穿**

常见的解决方案有两种：

* 互斥锁
* 逻辑过期

![image-20230623161032784](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623161032784.png)

比较：

>两种方案都用到了互斥锁

**互斥锁：**既然是很多线程导致数据库压力大，那就把这个重建缓存操作加锁，只让一个线程去干，**其他线程等待，最大的问题是会导致这段时间的性能下降**

**逻辑过期：**

我们之所以会出现这个缓存击穿问题，主**要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题**，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。

**这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理**。

假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞**，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑**，直到新开的线程完成这个逻辑后，才释放锁， **而线程1直接进行返回**。

假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。

**所有上面的线程1,3都返回过期数据，4返回重建的数据。**

> 线程2是1开启的重新线程

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。

#### 对比

**互斥锁方案：**由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响

> 可以保证一致性

**逻辑过期方案：** 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦

> 保证了可用性，但是不保证一致性

![image-20230623161109411](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623161109411.png)

#### 互斥锁解决商铺缓存击穿问题

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623161729876.png" style="zoom:80%">

核**心思路就是利用redis的setnx方法来表示获取锁**，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，

**我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。**

> 当然，**锁也应该有有效期。以免出现意外释放不掉**

~~~java
   private boolean tryLock(String key) {
        //setnx对应方法名是setIfAbsent
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
       //Boolean是包装类，有可能为空，所以这里加个判断
        return BooleanUtil.isTrue(flag);
    }

    private void unlock(String key) {
        stringRedisTemplate.delete(key);
    }
~~~



~~~java
    @Override
    public Result queryById(Long id) {

        Shop shop = queryWithMutex(id);
        if(shop ==null){
            return Result.fail("店铺不存在");
        }
        return Result.ok(shop);
    }

    public Shop queryWithMutex(Long id){
        //1 从redis中查询商铺缓存,这里用string存储value
        String key = CACHE_SHOP_KEY+id;
        String shopJson=stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+id);
        //2 判断是否存在
        if(StrUtil.isNotBlank(shopJson)){
            //3 存在则返回
            return JSONUtil.toBean(shopJson,Shop.class);

        }
        //判断是否是空值
        //这里注意isNotBlank当字符串为""或者是null时返回false，因此这里再判断其不是null，那说明是我们写入的空字符串
        if(shopJson!=null){
            //是"",返回null报错
            return null;
        }
        //4 不存在，尝试去缓存重建
        String lockKey = LOCK_SHOP_KEY+id;
        Shop shop =null;
        try {
            //4.1 获取互斥锁
            boolean isLock = tryLock(lockKey);
            if(!isLock){
                //4.2 失败则休眠并重试
                Thread.sleep(50);
                return  queryWithMutex(id);

            }
            //4.3 获取锁成功，去查数据库
            shop = getById(id);
            //模拟重建延时,测试时使用
            Thread.sleep(200);
            //5 不存在，返回错误
            if (shop == null){
                stringRedisTemplate.opsForValue().set(key,"",CACHE_NULL_TTL,TimeUnit.MINUTES);
                return null;
            }
            //6 存在，写入redis
            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);
        }catch (InterruptedException e){
            throw new RuntimeException(e);
        }
        finally {
            //7 释放互斥锁,这一步必须要做
            unlock(lockKey);
        }
        //8 返回
        return  shop;

    }
~~~

##### 测试（使用jmeter）

> D:\apache-jmeter-5.5\apache-jmeter-5.5\bin,点击jmeter.bat
>
> 参考https://www.bilibili.com/video/BV1cr4y1671t?p=45&spm_id_from=pageDriver&vd_source=d005def162a369d30cf8c241225a9395
>
> 最后几分钟的测试教程
>
> 经过测试发现，1000次5s的请求也没出问题

#### 逻辑过期解决商铺缓存击穿问题

思路分析：

当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。

> 注意，**这里做了一个假设，就是一开始会把热点数据都存在缓存，这样下面才会缓存未命中时直接返回而非再去查数据库**
>
> **逻辑过期未命中直接返回了，所以也就不存在缓存穿透了**

![image-20230623170752454](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623170752454.png)

首先，我们存到redis中的数据多了一个expire，也就是过期时间，因此我们在util中新建一个数据对象RedisData

```java
@Data
public class RedisData {
    private LocalDateTime expireTime;
    private Object data;
    //data用来存shop
}
```

然后，要先预存一些缓存数据来模拟过期，也叫数据预热

> 对于热点key，后台系统一般会预存热点数据，来减轻压力

~~~java
    public void saveShop2Redis(Long id,Long expireSeconds){
        //1. 查询店铺数据
        Shop shop = getById(id);
        //模拟重建时间
        Thread.sleep(200);
        //2. 封装逻辑过期时间
        RedisData redisData = new RedisData();
        redisData.setData(shop);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));
        //3 写入Redis
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));
    }
~~~

然后预热

~~~java
@Test
void testSaveShop(){
    shopService.saveShop2Redis(1L,10L);
}

~~~

query

~~~java
//线程池    
private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);
   
@Override
    public Result queryById(Long id) {

        //Shop shop = queryWithMutex(id);
        Shop shop = queryWithLogicalExpire(id);
        if(shop ==null){
            return Result.fail("店铺不存在");
        }
        return Result.ok(shop);
    }
    public Shop queryWithLogicalExpire(Long id){
        //1 从redis中查询商铺缓存,这里用string存储value
        String key = CACHE_SHOP_KEY+id;
        String shopJson=stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY+id);
        //2 判断是否存在
        if(StrUtil.isBlank(shopJson)){
            //3 缓存为空则返回,
            return null;

        }

        // 4.命中，需要先把json反序列化为对象
        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
        //这里redisdata的data设置的是Object，没有指定类型，所以下面强制转为Json
        Shop shop = JSONUtil.toBean((JSONObject)redisData.getData(), Shop.class);
        LocalDateTime expireTime = redisData.getExpireTime();
        // 5.判断是否过期
        if(expireTime.isAfter(LocalDateTime.now())) {
            // 5.1.未过期，直接返回店铺信息
            return shop;
        }
        // 已过期，需要缓存重建
        // 6.缓存重建
        // 6.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        // 6.2.判断是否获取锁成功
        if (isLock){
            //6.4成功，则开启独立线程，实现缓存重建
            CACHE_REBUILD_EXECUTOR.submit(()->{
                try{
                    //重建缓存
                    this.saveShop2Redis(id,20L);
                }catch (Exception e){
                    throw new RuntimeException(e);
                }finally {
                    unlock(lockKey);
                }
            });
        }
        // 6.4.返回过期的商铺信息
        return shop;

    }
~~~

##### 测试

这里先预热时，缓存信息如下

![image-20230623174913050](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623174913050.png)

等到过期后（10秒后），然后用jemeter测试，发现更新了，并且idea的日志也说明只访问了一次数据库

![image-20230623174848134](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623174848134.png)

![image-20230623175217803](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623175217803.png)



测试组是1000次请求，5s内，在这过程中重建了缓存，所以重建钱返回的是102，重建后返回103

![image-20230623175327232](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623175327232.png)

![image-20230623175352330](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230623175352330.png)

### 封装Redis工具类（重）

基于StringRedisTemplate封装一个缓存工具类，满足下列需求：

* 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间
* 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题



* 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
* 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题

将逻辑进行封装

#### 泛型

泛型：**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型,，。**

*在Java中,使用尖括号 `< >` 来定义泛型类型参数。泛型类型参数可以在类、接口、方法等声明中使用*

> 尖括号 `< >` 中的类型参数可以是任何合法的标识符，但通常会根据参数的含义或用途来进行命名，以增加代码的可读性，**并且一般是大写字母**

**泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来**….这样的话，用户明确了什么类型，该类就代表着什么类型…用户在使用的时候就不用担心强转的问题，运行时转换异常的问题了。

 ~~~java
 /*
     1:把泛型定义在类上
     2:类型变量定义在类上,方法中也可以使用
  */
 public class ObjectTool<T> {
     private T obj;
 
     public T getObj() {
         return obj;
     }
 
     public void setObj(T obj) {
         this.obj = obj;
     }
 }
 ~~~

**泛型方法:**仅仅在某一个方法上需要使用泛型….外界仅仅是关心该方法，不关心类其他的属性,那么可以在方法上定义泛型，

~~~java
    //定义泛型方法..
    public <T> void show(T t) {
        System.out.println(t);
    }
~~~

> [泛型](https://zhuanlan.zhihu.com/p/78811004),这里面还有继承，通配符等内容

**`Class<R>` 是一种语法结构，**用于表示一个 `Class` 对象，该对象表示泛型类型参数 `R` **所代表的具体类型的类。**

在 Java 中，`Class` 是一个特殊的类，用于表示其他类的元数据信息，例如类的名称、方法、字段等。通过 `Class` 对象，可以获取有关该类的各种信息。

在给定的代码示例中，`Class<R>` 表示一个 `Class` 类型的对象，**它的具体类型是由泛型类型参数 `R` 所决定的**。通过使用 `Class<R>`，我**们可以在方法中传递一个表示具体类型的 `Class` 对象，并在需要的时候使用该对象进行相关操作，例如实例化对象、获取类的信息等。**

> **所以后面可以这样来接受R的类型**

#### 函数式编程



#### caheClient

在util中新建cacheclient类

~~~java

@Slf4j
@Component
public class CacheClient {

    private final StringRedisTemplate stringRedisTemplate;

    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    public CacheClient(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    //将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间
    public void set(String key, Object value, Long time, TimeUnit unit){
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);
    }
    //将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题
    public void setWithLogicalExpire(String key, Object value,Long time,TimeUnit unit){
        //设置逻辑过期
        RedisData redisData  = new RedisData();
        redisData.setData(value);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));
        //写入Redis
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(redisData));

    }
    //根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
    public <R,ID>R queryWithPassThrough(
        //<R, ID> 是用尖括号 < > 括起来的，表示同时定义了两个泛型类型参数R和 ID。
        //<R>：这表示 R 是一个泛型类参数，用于表示方法的返回值类型。
        //<ID>：这表示 ID 是另一个泛型类型参数，用于表示方法的传入参数 id 的类型。
        //key前缀(因为查缓存时key是前缀+id)，
        
        //Class<R> 是一种语法结构，用于表示一个 Class`对象，该对象表示泛型类型参数 R所代表的具体类型的类。
        // Function<ID, R> dbFallback 参数可以传入一个函数接口，用于从数据库中获取数据并返回相应类型的对象。
        //有参有返回值，用Function
        String keyPrefix, ID id, Class<R> type, Function<ID,R>dbFallback,Long time,TimeUnit unit)
    	{
            String key=keyPrefix+id;
            // 1.从redis查询商铺缓存
            String json = stringRedisTemplate.opsForValue().get(key);
            // 2.判断是否存在
            if (StrUtil.isNotBlank(json)) {
                // 3.存在，直接返回
                return JSONUtil.toBean(json, type);
            }
            // 判断命中的是否是空值
            if (json != null) {
                // 返回一个错误信息
                return null;
            }

            // 4.不存在，根据id查询数据库,这里要求用户自己传一个函数进来
            R r = dbFallback.apply(id);
            // 5.不存在，返回错误
            if (r == null) {
                // 将空值写入redis
                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
                // 返回错误信息
                return null;
            }
            // 6.存在，写入redis
            this.set(key, r, time, unit);
            return r;
    }


    //根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题
    public <R, ID> R queryWithLogicalExpire(
            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
            String key = keyPrefix + id;
            // 1.从redis查询商铺缓存
            String json = stringRedisTemplate.opsForValue().get(key);
            // 2.判断是否存在
            if (StrUtil.isBlank(json)) {
                // 3.存在，直接返回
                return null;
        }
        // 4.命中，需要先把json反序列化为对象
            RedisData redisData = JSONUtil.toBean(json, RedisData.class);
            R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);
            LocalDateTime expireTime = redisData.getExpireTime();
            // 5.判断是否过期
            if(expireTime.isAfter(LocalDateTime.now())) {
                // 5.1.未过期，直接返回店铺信息
                return r;
            }
            // 5.2.已过期，需要缓存重建
            // 6.缓存重建
            // 6.1.获取互斥锁
            String lockKey = LOCK_SHOP_KEY + id;
            boolean isLock = tryLock(lockKey);
            // 6.2.判断是否获取锁成功
            if (isLock){
                // 6.3.成功，开启独立线程，实现缓存重建
                CACHE_REBUILD_EXECUTOR.submit(() -> {
                    try {
                        // 查询数据库
                        R newR = dbFallback.apply(id);
                        // 重建缓存
                        this.setWithLogicalExpire(key, newR, time, unit);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }finally {
                        // 释放锁
                        unlock(lockKey);
                    }
                });
            }
            // 6.4.返回过期的商铺信息
            return r;
    }

    // 根据指定的key查询缓存，并反序列化为指定类型，利用互斥锁解决缓存击穿问题
    public <R, ID> R queryWithMutex(
            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
            String key = keyPrefix + id;
            // 1.从redis查询商铺缓存
            String shopJson = stringRedisTemplate.opsForValue().get(key);
            // 2.判断是否存在
            if (StrUtil.isNotBlank(shopJson)) {
                // 3.存在，直接返回
                return JSONUtil.toBean(shopJson, type);
            }
            // 判断命中的是否是空值
            if (shopJson != null) {
                // 返回一个错误信息
                return null;
            }

            // 4.实现缓存重建
            // 4.1.获取互斥锁
            String lockKey = LOCK_SHOP_KEY + id;
            R r = null;
            try {
                boolean isLock = tryLock(lockKey);
                // 4.2.判断是否获取成功
                if (!isLock) {
                    // 4.3.获取锁失败，休眠并重试
                    Thread.sleep(50);
                    return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);
                }
                // 4.4.获取锁成功，根据id查询数据库
                r = dbFallback.apply(id);
                // 5.不存在，返回错误
                if (r == null) {
                    // 将空值写入redis
                    stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
                    // 返回错误信息
                    return null;
                }
                // 6.存在，写入redis
                this.set(key, r, time, unit);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }finally {
                // 7.释放锁
                unlock(lockKey);
            }
            // 8.返回
            return r;
    }

    private boolean tryLock(String key) {
            Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
            return BooleanUtil.isTrue(flag);
    }

    private void unlock(String key) {
            stringRedisTemplate.delete(key);
    }




}

~~~

shopServiceImpl

> 注意函数的调用`this::getById`,其传参时等同于lambda表达式 id->getById(id)

~~~java
    @Resource
    private CacheClient cacheClient;
   
	@Override
    public Result queryById(Long id) {

        Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);
        // 互斥锁解决缓存击穿
        // Shop shop = cacheClient
        //         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);

        // 逻辑过期解决缓存击穿
        // Shop shop = cacheClient
        //         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);

        if(shop ==null){
            return Result.fail("店铺不存在");
        }
        return Result.ok(shop);
    }
~~~

