---
title: 瑞吉外卖基础后端开发
date: 2023-06-06
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Springboot
---

## 登录功能

首先打开已经给出的login.hml,按F12，打开网络，点击全部，然后点击网页中的登录，然后查看标头（Header）可以看到相关请求的信息。

![image-20230606113447872](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606113447872.png)

点击载荷，可以看到发送的json

![image-20230606113605883](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606113605883.png)

#### 参考：

[MP基础使用](https://www.jb51.net/article/223514.htm)

### 数据传输约定

![image-20230606114016269](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606114016269.png)

发现前端需要这些json字段，因此后端传输的json数据需要有这些字段



### 实现逻辑

![image-20230606113630533](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606113630533.png)

controller处理逻辑（注意比一般的登录多加了一个禁用字段，对应数据库表employee的status，如果该值为0，表示已经锁定）

![image-20230606180418962](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606180418962.png)

### 具体实现

新建一个entity，存储实体类，然后把Employee类创建；

~~~java
package com.test.entity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import lombok.Data;
import java.io.Serializable;
import java.time.LocalDateTime;

@Data
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;
    //之前说的数据库表和属性，如果有下划线的就可以映射为驼峰命名法
    //这个idNumber在数据库中是id_number

    private Integer status;

    private LocalDateTime createTime;

    private LocalDateTime updateTime;

    @TableField(fill = FieldFill.INSERT)
    private Long createUser;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;

}

~~~

然后创建Mapper包，写EmployeeMapper接口文件，**使用MP提供的通用类Mapper**

~~~java
package com.test.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.test.entity.Employee;
import org.apache.ibatis.annotations.Mapper;


@Mapper
public interface EmployeeMapper extends BaseMapper<Employee> {
    //这个BaseMapper包含了基础的增删改查等功能
}

~~~

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606115049344.png" style="zoom:90%">

创建对应service包，创建

![image-20230606174446673](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606174446673.png)

其中EmployeeService接口如下

~~~java
package com.test.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.test.entity.Employee;
//MP开发规范，继承他提供的服务类父类
public interface EmployeeService extends IService<Employee> {
}

~~~

实现类 EmployeeServiceImpl如下，同样的，继承自MP提供的类

~~~java
package com.test.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.test.entity.Employee;
import com.test.mapper.EmployeeMapper;
import com.test.service.EmployeeService;
import org.springframework.stereotype.Service;

@Service
//也是MP开发规范，继承他提供的服务类实现父类
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee>  implements EmployeeService {
}

~~~

最后实现Controller

~~~java
package com.test.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.test.common.R;
import com.test.entity.Employee;
import com.test.service.EmployeeService;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.DigestUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;


@Slf4j
 @RestController
 @RequestMapping("/employee")
 public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    @PostMapping("/login")
    //传入HttpServletRequest主要是为了session中还要使用
    public R<Employee> login(HttpServletRequest request, @RequestBody Employee employee){
        String password = employee.getPassword();
        password=DigestUtils.md5DigestAsHex(password.getBytes());

        LambdaQueryWrapper<Employee>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Employee::getUsername,employee.getUsername());
        Employee emp = employeeService.getOne(queryWrapper);

        if(emp == null){
            return R.error("登陆失败");
        }

        //密码比对，不一致返回失败
        if(!emp.getPassword().equals(password)){
            return R.error("登录失败");
        }

        //查看是否禁用，已经禁用返回已经禁用
        if(emp.getStatus()==0){
            return R.error("账号已禁用");
        }

        //登录成功，将员工存入Session并返回登录结果
        request.getSession().setAttribute("employee",emp.getId());
        return R.success(emp);

        }

     /**
      * 员工登出
      * @param request
      * @return
      */
    @PostMapping("/logout")
    public R<String> logout(HttpServletRequest request){
            request.getSession().removeAttribute("employee");
            //前端页面发送请求到logout，然后这个方法清除session中的值，并且返回一个R.Success,这里因为是前端是当返回退出成功时，也会同步清除本地的cookie
            return R.success("退出成功");
        }

}

~~~

#### 结果类

将所有的都返回结果封装为同一个类，新建一个包`common`，新建结果类R

~~~java
package com.test.common;

import lombok.Data;
import java.util.HashMap;
import java.util.Map;
/**
 * 通用返回结果类，所有的返回结果封装为此类
 * @param <T>
 */
@Data
public class R<T> {
    private Integer code; //编码：1成功，0和其它数字为失败
    private String msg; //错误信息
	//T是泛型
    private T data; //数据
    private Map map = new HashMap(); //动态数据
	//注意这里是静态方法，所以不用new 一个对象，直接用即可
    public static <T> R<T> success(T object) {
        R<T> r = new R<T>();
        r.data = object;
        r.code = 1;
        return r;
    }
    public static <T> R<T> error(String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }
    public R<T> add(String key, Object value) {
        this.map.put(key, value);
        return this;
    }
}
~~~

#### 退出登录

用户点击退出，发送请求到/employee/logout

- 清除Session中的用户id，
- 返回结果

#### 问题

1. springboot3内置tomcat10，对应的javaEE10，而本项目用的javaEE9，其中有一个大坑，javax更名为javaktra，导致很多包不能用，下面的错误就是换包后，HttpServlet实例化错误

~~~bash
at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590) ~[tomcat-embed-core-10.1.8.jar:6.0]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885) ~[spring-webmvc-6.0.9.jar:6.0.9]
~~~

解决：

**一开始就不要创建3.0的项目，用2.45，把pom直接拷贝过来，刷新就能用了**

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.5</version>
        <!--创项目时，不要用3，用springboot2-->
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.test</groupId>
    <artifactId>reggie</artifactId>
    <version>1.0-SNAPSHOT</version>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.2</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.20</version>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.76</version>
        </dependency>

        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.23</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.5</version>
            </plugin>
        </plugins>
    </build>
</project>
~~~



> 参考https://www.xyhtml5.com/48932.html

更改后成功访问，3.0真坑啊，市面上好多还是2.0，还是用spring2.0好，不然配置很浪费时间

2 输出中，sql有异常

![image-20230607110918809](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607110918809.png)

原因是使用的方法没有开启@Transactionnal那个注解，但是好像不影响使用？教程里也有一样问题



#### 完善登录功能

上面实现的登录功能，不管是不是从login进去，都能直接访问index.html，但是这显然不合理，因此需要修改，没有登录时，将直接访问index的请求重定向到login.html。**可以使用过滤器或者拦截器实现**

![image-20230607100054848](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607100054848.png)

##### 处理逻辑

![image-20230607101725521](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607101725521.png)





##### code

![image-20230607111141272](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111141272.png)

~~~java
package com.test.filter;

import com.alibaba.fastjson.JSON;
import com.test.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

//拦截器名字，后面是拦截路径，/*表示都拦截
@WebFilter(filterName = "LoginCheckFilter",urlPatterns = "/*")
//加了这个，可以通过日志的方法来输出
@Slf4j

public class LoginCheckFilter implements Filter {
    //IDEA中选中标红的接口，可以点实现类，然后自动生成函数名

    //路径匹配器，支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request =(HttpServletRequest)servletRequest;
        HttpServletResponse response = (HttpServletResponse)servletResponse;

        //获取本次请求uri
        String requestURI = request.getRequestURI();
        //定义不用处理的请求，但是如果直接这样写，对/backend/index.html这样的路径拦截会出问题
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "front/**"
        };

        boolean check = check(urls, requestURI);

        //在里面，直接放行
        if(check){
            filterChain.doFilter(request,response);
            return;

        }
        //如果已经登录，当然也放行
        if ((request.getSession().getAttribute("employee")!=null)){
            filterChain.doFilter(request,response);
            return;

        }
        //如果未登录则的返回未登录结果，通过输出流方式向客户端页面响应数据，这里的msg是前端request.js判断要用的
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
        //log.info("拦截到请求:{}",request.getRequestURI());
        //放行，因为拦截是request和response都拦，所以都放
        //filterChain.doFilter(request,response);
    }

    /**
     * 判断路径是否放行
     * @param urls
     * @param requestURI
     * @return
     */
    public boolean check(String[] urls,String requestURI){
        for(String url:urls){
            boolean match = PATH_MATCHER.match(url,requestURI);
            if(match){
                return true;
            }
        }
        return false;
    }
}

~~~

##### 拦截器

配置了这个东西之后，导致了一个问题，就是 对静态资源的访问也被拦截了，因此需要新建一个WebMvcConfig

> 参考：https://blog.csdn.net/qq_41091397/article/details/106929531

~~~java
    /**
     * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        super.addResourceHandlers(registry);
    }

~~~



## 员工管理

### 新增员工

![image-20230607111415165](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111415165.png)

#### 流程

![image-20230607111523825](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111523825.png)

**按F12，点击网络->ALL->header/荷载，可以看到请求发送的json的格式**

![image-20230607111827056](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111827056.png)

![image-20230607111835921](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111835921.png)

#### 异常

![image-20230607114102633](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607114102633.png)

增加全局异常处理

![image-20230607173445251](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607173445251.png)

~~~java
package com.test.common;


import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常捕获
 */
@Slf4j
@ResponseBody
@ControllerAdvice(annotations ={RestController.class,Controller.class})
public class GlobalExceptionHandler {
    //这里是捕获SQL相关异常信息
    public R<String>exceptionHandler(SQLIntegrityConstraintViolationException ex){
        //log.error(ex.getMessage());
        //Duplicate entry 'admin' for key 'employee.idx_username'
        if(ex.getMessage().contains("Duplicate entry")){
            String[] split = ex.getMessage().split(" ");
            String msg = split[2]+"已存在";
            return R.error(msg);
        }
        return R.error("未知错误");
    }
}

~~~

#### 实现

~~~java
    /**
     * 增加员工
     * @param employee
     * @return
     */
    @PostMapping
    //这里因为前端就是直接访问的employee，这里路径不用写了
    public R<String> save(HttpServletRequest request,@RequestBody Employee employee){
        //log.info("新增员工，员工信息");
        //下面是需要手动设置的信息，有些数据库表有默认值，所以不用设置
        employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());

        //获取当前登录用户id
        Long empId =(Long)request.getSession().getAttribute("employee");

        employee.setCreateUser(empId);
        employee.setUpdateUser(empId);
        //MP中的通用方法，基于insert语句
        employeeService.save(employee);
        return R.success("新增员工成功");
    }
~~~



#### 总结

对于某个功能开发，基本上流程都一样

![image-20230607115813644](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607115813644.png)

### 分页

![image-20230607143141367](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607143141367.png)

进入界面的时候，会有自动请求（backend/page/list.html）分页数据，前端的代码，逻辑是创建完vue对象带上一些函数，注意这次发送给后端的不是json，就时普通的key-value

![image-20230607143423133](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607143423133.png)

#### 实现

都是基于MP提供的方法来开发，首先开启mybatis分页插件

![image-20230607173704901](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607173704901.png)

~~~java
package com.test.config;

import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 配置MP的分页插件
 */
@Configuration
public class MybatisPlusConfig {
    //利用MP提供拦截器实现
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor((new PaginationInnerInterceptor()));
        return mybatisPlusInterceptor;
    }
}

~~~

~~~java
//直接加到employee controller中    
/**
     * 员工信息分页查询
     * @param page
     * @param pageSize
     * @param name
     * @return
     */
    @GetMapping("/page")
    //一般来说需要page和pageSize，之所以这里有name，是因为他还可以根据name来搜员工，因此写一起了，不穿name就默认为null，也能正常查到
    public R<Page>page(int page,int pageSize,String name){
        //log.info("page={},pagesize={},name={}",page,pageSize,name);

        //构造分页构造器
        Page pageInfo = new Page(page,pageSize);
        //构造条件构造器，这里根据name来过滤
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper();
        //StringUtils.isNotEmpty(name),这个方法很多包都要，注意导入common.lang才有这个方法
        //其实就是如果name不为空，才进行like，为空like不生效，相当于if like,else continue;
        //根据第一个参数判断是否进行like，这句话就是只有name不为空才进行，否则相当于没有这句话
        queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);//queryWrapper相当于sql的where

        //添加降序排序
        queryWrapper.orderByDesc(Employee::getUpdateTime);

        //执行查询
        //这里的page也是MP提供的，并且这条语句执行后，会将查询结果赋值给pageInfo
        employeeService.page(pageInfo,queryWrapper);
        return R.success(pageInfo);

    }
~~~

### 启用/禁用状态修改

就是修改status为0或者1

注意这里前端已经实现了0/1的变化

![image-20230607174637605](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607174637605.png)

~~~java
   /**
     * 根据id修改信息
     * @param request
     * @param employee
     * @return
     */
    @PutMapping
    public R<String>update(HttpServletRequest request,@RequestBody Employee employee){
        //log.info(employee.toString());
        //修改status的操作在前端，因此只需要顺便加上时间和操作人即可
        Long empId =(Long)request.getSession().getAttribute("employee");
        employee.setUpdateTime(LocalDateTime.now());
        employee.setUpdateUser(empId);
        employeeService.updateById(employee);
        return R.success("员工信息修改成功");
    }
~~~

#### 注意：

1.注意ID是long型，但是js最多处理16位，也就是前端处理时收到的只能保证只有前16位是准的，所以要在后端把Long型统一转换为String类型

![image-20230607171552455](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607171552455.png)



首先配置转换类

~~~java
package com.test.common;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

		//就是把很多类型都转成String了
        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}

~~~



然后增加一个webmvc的消息转换器

![image-20230607173855125](C:/Users/28788/AppData/Roaming/Typora/typora-user-images/image-20230607173855125.png)

~~~java
package com.test.config;


import com.test.common.JacksonObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

import java.util.List;

@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {


    /**
     * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        super.addResourceHandlers(registry);
    }


    /**
     * 扩展MVC消息转换器
     * @param converters
     */
    @Override
    //输入ex可以有候选
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        //log.info("扩展消息转换器");
        //创建消息转换器对象
        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
        //设置对象转换器，底层使用jackson将java对象转换为json
        messageConverter.setObjectMapper(new JacksonObjectMapper());
        //将上面的消息转换器对象追加到mvc框架的转换器集合中
        //这里的0代表转换器的优先级，0最高
        converters.add(0,messageConverter);
    }
}

~~~

![image-20230607173216929](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607173216929.png)



### 编辑员工信息

#### 操作流程

![image-20230607195322109](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607195322109.png)

> add.html是公共页面，新增员工和编辑员工都在这里

点击编辑按钮时，会跳转到add，并且携带了一个参数ID

![image-20230607195710677](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607195710677.png)



分析前端代码，的确传了id，这里没去探究具体细节，但只要知道从url中获取了id

![image-20230607200153096](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607200153096.png)

#### 实现

~~~java
    @GetMapping("/id")
    public R<Employee>getById(@PathVariable Long id){
        //log.info("根据id查询员工信息...")
        Employee employee = employeeService.getById(id);
        if(employee!=null){
            //会在修改页展示之前的信息
            return R.success(employee);
        }
        return R.error("未查询到信息");
        //最后的保存调用的之前的Update方法，那个是通用方法
    }

~~~



## 分类相关

### 公共字段填充

如果很多表都有一些相同的属性，就可以考虑公共字段填充减少代码量

![image-20230607202516464](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607202516464.png)

#### 实现

![image-20230607202544789](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607202544789.png)

#### ThreadLocal

![image-20230607210804992](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607210804992.png)

> 在一个调用链上，都是一个线程，因此才可以借助线程拿到id，这一点很重要，必须在一个线程内

##### 介绍

![image-20230607211419129](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607211419129.png)

![image-20230607211639174](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607211639174.png)

#### 代码

首先创建

![image-20230607213546644](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213546644.png)

BaseContext

~~~java
package com.test.common;

/**
 * 基于ThreadLocal的封装工具类，用户保存和获取当前登录用户id
 * 注意ThreadLocal也只是一个局部变量，所以只能保存一个值
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public  static void setCurrentId(Long id){
        threadLocal.set(id);
    }

    public static Long getCurrentId(){
        return threadLocal.get();
    }
}

~~~

 MyMetaObjecthandler

~~~java
package com.test.common;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * 自定义元数据处理器
 */
@Component
@Slf4j
public class MyMetaObjecthandler  implements MetaObjectHandler {

    //插入操作，自动填充
    @Override
    public void insertFill(MetaObject metaObject) {
        //log.info(metaObject.toString());
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime",LocalDateTime.now());

        //这里注意，需要根据用户id来填user，并且这个类里没有httpSession，于是可以用ThreadLocal来获取id
        //利用ThreadLocal获取了值
        metaObject.setValue("createUser",BaseContext.getCurrentId());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }

    //更新操作，自动填充
    @Override
    public void updateFill(MetaObject metaObject) {
        //log.info(metaObject.toString());
        metaObject.setValue("updateTime",LocalDateTime.now());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }
}

~~~

在controller注释掉之前的公共字段设置的语句

![image-20230607213731626](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213731626.png)

![image-20230607213750857](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213750857.png)

**filter中加入设置id的语句即可（后面还有UserId，同样也要记录了。才能使用）**

![image-20230607213826109](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213826109.png)



### 新增/查询分类（菜品/套餐）

都在category表中，主要关注name是唯一约束，通过type来分辨菜品/套餐，sort是移动端对展示的菜品的排序

![image-20230607214243627](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607214243627.png)

同样的实现逻辑

![image-20230607214426842](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607214426842.png)

程序执行逻辑

![image-20230607215626858](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607215626858.png)

Controller代码

~~~java
package com.test.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.test.common.R;
import com.test.entity.Category;
import com.test.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 分类管理
 */
@RestController
@RequestMapping("/category")
@Slf4j
public class CategoryController  {
    @Autowired
    private CategoryService categoryService;

    /**
     * 新增分类
     * @param category
     * @return
     */
    @PostMapping
    public R<String>save(@RequestBody Category category){
        //log.info("保存");
        categoryService.save(category);
        //因为定义了全局的sql异常处理，所以当重复创建重名菜时也会被全局那个捕捉到
        //同样的，那些设置字段值的也被那个公共字段填充类填充了
        return R.success("新增分类成功");
    }

    /**
     * 分页查询
     * @param page
     * @param pageSize
     * @return
     */
    @GetMapping("/page")
    public R<Page>page(int page,int pageSize){
        //分页构造器
        Page<Category>pageInfo = new Page<>(page,pageSize);
        //条件构造器，主要是里面有个sort，需要返回有序的数据
        LambdaQueryWrapper<Category>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.orderByAsc(Category::getSort);
        //进行分页查询
        categoryService.page(pageInfo,queryWrapper);
        return R.success(pageInfo);
    }
}
~~~

### 删除分类

![image-20230607222047570](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607222047570.png)

流程

![image-20230607222128116](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607222128116.png)

![image-20230607222552411](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607222552411.png)

#### 实现

主要是如果删除的分类关联了套餐或者菜品，就不能删除，因此进行此种行为时，需要自定义一个异常

在common中新建CustomException

~~~java
package com.test.common;

/**
 * 自定义业务异常
 */
public class CustomException extends RuntimeException{
    public CustomException(String msg){
        super(msg);
    }
}

~~~

重新categoryServcice的remove方法

CategoryService接口

~~~java
package com.test.service;


import com.baomidou.mybatisplus.extension.service.IService;
import com.test.entity.Category;

public interface CategoryService extends IService<Category> {
    void remove(Long id);
}

~~~

实现

~~~java

package com.test.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.test.common.CustomException;
import com.test.entity.Category;
import com.test.entity.Dish;
import com.test.entity.Setmeal;
import com.test.mapper.CategoryMapper;
import com.test.service.CategoryService;
import com.test.service.DishService;
import com.test.service.SetmealService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category>  implements CategoryService {

    @Autowired
    private SetmealService setmealService;

    @Autowired
    private DishService dishService;
    /**
     * 根据id删除分类，删除之前需要进行判断有无关联
     * @param id
     */
    @Override
    public void remove(Long id){
        //如果当前分类关联了菜品/套餐，抛出异常
        LambdaQueryWrapper<Dish> dishLambdaQueryWrapper=new LambdaQueryWrapper<>();
        //添加查询条件，根据分类id进行查询
        dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);
        int countDish = dishService.count(dishLambdaQueryWrapper);

        if(countDish>0){
            //有关联菜品，抛出一个业务异常（自定义异常类）
            throw new CustomException("当前分类下关联了菜品，不能删除");

        }

        //查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常
        LambdaQueryWrapper<Setmeal>setmealLambdaQueryWrapper=new LambdaQueryWrapper<>();
        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);
        int countSetmeal = setmealService.count(setmealLambdaQueryWrapper);
        if(countSetmeal>0){
            throw new CustomException("当前分类下关联了套餐，不能删除");
        }
        //正常删除分类
        super.removeById(id);
    }
}

~~~

controller

~~~java
    @DeleteMapping
    public R<String>delete(@RequestParam("ids") Long id){
        //这个变量名要和前端完全一样，但前端传的ids，因此加一个注解起别名
        log.info("删除分类，id为:{}",id);
        //categoryService.removeById(id);
        categoryService.remove(id);
        return R.success("分类信息删除成功");
    }
~~~

### 分类信息修改

前端会直接对数据写（V-model双向绑定）,然后将修改后的值返回

![image-20230608202136837](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230608202136837.png)

controller

~~~java
    @PutMapping
    public R<String>update(@RequestBody Category category){
        log.info("修改菜品信息{}",category);

        categoryService.updateById(category);
        //其他的公共字段自动填充

        return R.success("修改分类信息");
    }
~~~

公共字段填充

![image-20230608202554684](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230608202554684.png)



## 菜品相关

### 文件上传下载

#### 上传

![image-20230608203001711](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230608203001711.png)

前端

![image-20230608203100055](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230608203100055.png)

![image-20230608203332735](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230608203332735.png)

后端

![image-20230608203200430](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230608203200430.png)

##### 实现

~~~java
   @PostMapping("/upload")
    //注意这里与前端表单的name=file的name值保持一致
    public R<String> upload(MultipartFile file){
        //刚上传到服务器的文件其实是存在临时目录里，所以要转存到指定位置
        log.info(file.toString());

        String originalFilename = file.getOriginalFilename();
        //截文件后缀
        String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));

        //使用UUID生成新的文件名
        String fileName = UUID.randomUUID().toString()+suffix;
        File dir = new File(basePath);
        if(!dir.exists()){
            //如果没有创建相应目录则创建
            dir.mkdirs();
        }

        try{
            //将临时文件存储到指定位置
            file.transferTo((new File(basePath+fileName)));
        }catch(IOException e){
            //如果存储失败此时需要捕捉IO异常
            e.printStackTrace();
        }
        //根据name继续处理
        return R.success(fileName);

    }
~~~

##### 注意

首先是配置文件的书写

~~~yaml
reggie:
  path: D:\img\
~~~

然后取这个值@Value注解

~~~java
    @Value("${reggie.path}")
    private String basePath;
~~~



#### 下载

![image-20230608203235461](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230608203235461.png)



![image-20230609100356589](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230609100356589.png)







### 新增菜品

![image-20230609101944427](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230609101944427.png)

![image-20230609104604664](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230609104604664.png)

![image-20230609111013662](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230609111013662.png)



#### 注意

1. 由于保存菜品时，里面有一个比较复杂的key叫flavors,所以新建一个dto来保存

![image-20230609113447383](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230609113447383.png)

![image-20230609113425991](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230609113425991.png)

2为什么同样接受json数据，有时候要加@Requestbody,有时候不用？

> 参考
>
> https://www.cnblogs.com/panxuejun/p/7007892.html

直观的来解释，使用`@RequestBody`注解取决于请求的HTTP方法和前端发送请求时的数据格式。**如果请求需要从请求体中获取JSON数据**，就需要使用该注解；否则，可以省略该注解。

如果使用`POST`或`PUT`等方法发送请求，并且请求的`Content-Type`设置为`application/json`，则需要在后端的方法参数中使用`@RequestBody`注解来映射请求体中的JSON数据。这将告诉Spring Boot将请求的JSON数据绑定到方法参数上。

但是，如果使用`GET`方法或将数据作为查询参数发送请求，则不需要使用`@RequestBody`注解**。这是因为`@RequestBody`主要用于从请求体中读取数据，而`GET`请求通常将数据作为查询参数附加在URL中。**

> GPT回答，验证后的确是这样
>
> 所以用GET请求，只需要获取对应url的参数即可，就算用实体类接受，只有实体类里有那个字段也行

3 为什么有时候只传了id，却要用类来接受

主要是为了增强接口通用性，比如下面只传了一个参数，但是这个参数type，我这个类里面有，这样传更多这个类的参数过来时，我也能接受，所以通用性更强

~~~java
    @GetMapping("/list")
    //这里不能给参数加@Requestbody,不知道为什么
    //http://localhost:8080/category/list?type=1
    //这里是get请求，所以不用加这个注解，并且这个类只有type=1，其他都是null，不过只做查询用，不是存到数据库，所以这样也没事
    public R<List<Category>> list( Category category){
        //条件构造器

        LambdaQueryWrapper<Category>queryWrapper=new LambdaQueryWrapper<>();
        //添加条件
        queryWrapper.eq(category.getType()!=null,Category::getType,category.getType());
        //添加排序条件
        queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);

        List<Category>list = categoryService.list(queryWrapper);

        return R.success(list);
    }
~~~



#### 实现

~~~java
    @PostMapping
    //这里必须加@RequestBody这个参数，不知道为什么
    //因为这个需要从请求体里读数据
    public R<String> save(@RequestBody DishDto dishDto){
        log.info(dishDto.toString());
        dishService.saveWithFlavor(dishDto);

        return R.success("新增菜品成功");
    }


~~~

DTO

~~~java
package com.test.dto;


import com.test.entity.Dish;
import com.test.entity.DishFlavor;
import lombok.Data;
import java.util.ArrayList;
import java.util.List;

/**
 * 菜品数据传输对象，注意集成了菜品本来的字段，新增了一个List来存那个复杂的列表
 */
@Data
public class DishDto extends Dish {

    private List<DishFlavor> flavors = new ArrayList<>();

    private String categoryName;

    private Integer copies;
}

~~~

### 菜品分页，修改&根据id查询

这里的难点再与要查两张表，修改时也是涉及两张表，其中dish_flavro中的dish_id的维护尤为重要，是关联两张表的键，注意是怎么对他操作的

dishController

~~~java

    /**
     * 菜品分页信息，需要查两张表
     * @param page
     * @param pageSize
     * @param name
     * @return
     */
    @GetMapping("/page")
    public R<Page>page(int page,int pageSize,String name){

        //构造分页构造器，Page是MP提供的一个类
        Page<Dish>pageInfo = new Page<>(page,pageSize);
        //因为我们返回的信息需要有categoryName,所以最后返回dishDto
        Page<DishDto> dishDtoPage = new Page<>();


        LambdaQueryWrapper<Dish>queryWrapper = new LambdaQueryWrapper<>();

        queryWrapper.like(name!=null,Dish::getName,name);

        queryWrapper.orderByDesc(Dish::getUpdateTime);

        dishService.page(pageInfo,queryWrapper);
        //上面从dish库里读取了 相关dish，但是菜品分类dish里存的是菜品分类的id，需要映射到category表里的name才能正常展示
        //所以还要根据菜品id查category表

        //对象拷贝
        //这条语句的作用是将pageInfo对象中除了records属性之外的其他属性值复制到dishDtoPage对象中。这通常用于将一个对象的属性值复制到另一个对象中，以便进行数据传递或转换。
        //records是Page对象的一个属性，其中存储了当前数据记录，但是我们需要的是映射了名字的，所以这里不拷贝数据记录
        BeanUtils.copyProperties(pageInfo,dishDtoPage,"records");
        //把数据记录中的records，也就是dish集合中的id改成了name，在返回
        List<Dish>records = pageInfo.getRecords();
        List<DishDto>list =  records.stream().map((item)->{
            DishDto dishDto = new DishDto();
            BeanUtils.copyProperties(item,dishDto);
            Long categoryId = item.getCategoryId();
            Category category = categoryService.getById(categoryId);
            //这样更安全，因为有可能id错误，没查到，就会抛出异常
            if(category!=null){
                String categoryName = category.getName();
                dishDto.setCategoryName(categoryName);
            }
            return dishDto;
        }).collect(Collectors.toList());
        dishDtoPage.setRecords(list);
        return R.success(dishDtoPage);
    }

    /**
     * 根据id查询菜品（包括口味）
     * @param id
     * @return
     */
    @GetMapping("/{id}")
    //在 @GetMapping 注解中，使用大括号 {} 将路径中的一部分括起来表示这是一个路径变量（Path Variable）。
    public R<DishDto>get(@PathVariable Long id){
        DishDto dishDto = dishService.getByIdWithFlavor(id);
        return R.success(dishDto);
    }

    @PutMapping
    public R<String>update(@RequestBody DishDto dishDto){
        log.info(dishDto.toString());
        dishService.updateWithFlavor(dishDto);

        return R.success("新增菜品成功");
    }

~~~

注意要加接口中定义方法，然后再实现

~~~java
package com.test.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.test.dto.DishDto;
import com.test.entity.Dish;
import com.test.entity.DishFlavor;
import com.test.mapper.DishMapper;
import com.test.service.DishFlavorService;
import com.test.service.DishService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class DishServiceImpl extends ServiceImpl<DishMapper, Dish> implements DishService {

    @Autowired
    private DishFlavorService dishFlavorService;
    /**
     * 新增菜品，同时保存对应口味数据（操作两张表）
     * 操作涉及两张表，所以要加事务控制
     * @param dishDto
     */
    @Transactional
    public void saveWithFlavor(DishDto dishDto){
        //保存菜品的基本信息到菜品表dish
        this.save(dishDto);
        Long dishId = dishDto.getId();

        //菜品口味
        List<DishFlavor>flavors = dishDto.getFlavors();
        //用流的方式，将flavors中的字段读出，并将其DishId赋值
        flavors = flavors.stream().map((item) ->{
            item.setDishId(dishId);
            return item;
        }).collect(Collectors.toList());
        //这里的flavors是一个falvor列表，因此要用saveBatch
        dishFlavorService.saveBatch(flavors);


    }

    @Override
    public DishDto getByIdWithFlavor(Long id) {
        //根据id，从dish表里查基本信息
        Dish dish = this.getById(id);

        DishDto dishDto = new DishDto();
        BeanUtils.copyProperties(dish,dishDto);

        //查询菜品对对应口味信息，查dish_flavor
        LambdaQueryWrapper<DishFlavor>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(DishFlavor::getDishId,dish.getId());
        List<DishFlavor>flavors = dishFlavorService.list(queryWrapper);
        dishDto.setFlavors(flavors);

        return dishDto;

    }

    @Override
    public void updateWithFlavor(DishDto dishDto) {
        //这里首先更新dish的普通字段，对于flavor，比较复杂，先移除，再添加



        //更新dish表基本功能
        this.updateById(dishDto);

        //清理当前菜品对应口味数据--dish_flavor表的delete操作
        LambdaQueryWrapper<DishFlavor>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());

        dishFlavorService.remove(queryWrapper);
        //添加当前提交过来的口味数据---dish_flavor表的insert操作
        //同样的，要给dish_falvor的dishid赋值，表示这是哪个菜品的flavor

        List<DishFlavor>flavors = dishDto.getFlavors();
        flavors = flavors.stream().map((item) -> {
            item.setDishId(dishDto.getId());
            return item;
        }).collect(Collectors.toList());

        dishFlavorService.saveBatch(flavors);
    }
}

~~~

## 套餐相关

### 新增套餐

![image-20230610093027748](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610093027748.png)

![image-20230610093048188](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610093048188.png)

![image-20230610094028187](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610094028187.png)

![image-20230610095609195](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610095609195.png)

#### 实现

controller

~~~java
    @PostMapping
    public R<String>save(@RequestBody SetmealDto setmealDto){

        log.info("套餐信息：{}",setmealDto);
        setmealService.saveWithDish(setmealDto);

        return R.success("新增套餐成功");
    }

~~~

setmealDto

~~~java
package com.test.dto;


import com.test.entity.Setmeal;
import com.test.entity.SetmealDish;
import lombok.Data;
import java.util.List;

@Data
public class SetmealDto extends Setmeal {

    private List<SetmealDish> setmealDishes;

    private String categoryName;
}

~~~

#### 注意

1为什么这里的save时，需要去设置Id？

当然是因为前端传来的dto对象中，那个字段是null，而当要存到setmeal_dish这张表时，setmeal这个字段不能为空，而setmealDto的id就是我们需要的这个id，所以要手动设置一下，前面有些一样的也是一个道理

```
SetmealServiceImpl
```

~~~java
    @Transactional
    @Override
    public void saveWithDish(SetmealDto setmealDto) {
        //保存套餐的基本信息，对setmeal执行insert
        this.save(setmealDto);
        //Dto的id就是setmealdish表的setmealId,并且dto中这个字段是空，因此要这么设置
        List<SetmealDish>setmealDishes = setmealDto.getSetmealDishes();
        setmealDishes.stream().map(item->{
            item.setSetmealId(setmealDto.getId());
            return item;
        }).collect(Collectors.toList());
        //保存套餐和菜品的关联信息，insert到setmeal_dish
        setmealDishService.saveBatch(setmealDishes);
    }
~~~

dto

![image-20230610110731488](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610110731488.png)

setmeal_dish

![image-20230610110834288](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610110834288.png)

### 分页查询

![image-20230610112654447](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610112654447.png)

controller

~~~java
  /**
     * 套餐分页查询
     * @param page
     * @param pageSize
     * @param name
     * @return
     */
    @GetMapping("/page")
    public R<Page>page(int page,int pageSize,String name){
        //分页构造器对象
        Page<Setmeal>pageInfo = new Page<>(page,pageSize);
        Page<SetmealDto>dtoPage = new Page<>();

        LambdaQueryWrapper<Setmeal>queryWrapper = new LambdaQueryWrapper<>();

        queryWrapper.like(name!=null,Setmeal::getName,name);

        queryWrapper.orderByDesc(Setmeal::getUpdateTime);

        setmealService.page(pageInfo,queryWrapper);

        //这个也有dto对象，因此也要对象拷贝,这里就和上一节的菜品的操作一样
        BeanUtils.copyProperties(pageInfo,dtoPage,"records");
        List<Setmeal>records = pageInfo.getRecords();
        //这里将Setmeal类的数据给setmealDto，当然，dto里的name，需要再去查表获得，所以这里用stream流的方式批量改了（因为这是一个列表）
        List<SetmealDto>list = records.stream().map(item->{
            SetmealDto setmealDto = new SetmealDto();
            BeanUtils.copyProperties(item,setmealDto);
            Long categoryId = item.getCategoryId();

            Category category = categoryService.getById(categoryId);
            if(category!=null){
                String categoryName = category.getName();
                setmealDto.setCategoryName(categoryName);

            }
            return setmealDto;
        }).collect(Collectors.toList());

        dtoPage.setRecords(list);
        return R.success(dtoPage);
    }
~~~

### 删除套餐

![image-20230610163916585](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610163916585.png)

![image-20230610163931716](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610163931716.png)

controller

~~~java

    /**
     * 删除一个或者多个套餐
     * 因为可能传多个值，所以用list类型接受，这样一个或者多个也能接受
     * 这里删一个套餐，处理删除套餐表，还要删除套餐关联表里这个套餐的 相关记录
     * @param ids
     * @return
     */
    @DeleteMapping
    public R<String>delete(@RequestParam List<Long> ids){
        setmealService.removeWithDish(ids);
        return R.success("套餐删除成功");
    }

~~~

impl

~~~java
    @Override
    public void removeWithDish(List<Long> ids) {
        // 查询套餐状态，确定是否可以删除
        LambdaQueryWrapper<Setmeal>queryWrapper = new LambdaQueryWrapper<>();
        //条件查询，返回Setmeal表中id与id列表中相同的记录
        queryWrapper.in(Setmeal::getId,ids);
        //再对得到的结果中进行筛选，选出status为1，即在售的记录，也就是不能删除的
        queryWrapper.eq(Setmeal::getStatus,1);

        int count=this.count(queryWrapper);
        if(count>0){
            throw new CustomException("套餐正在售卖，不能删除");
        }

        //如果可以删除，就删除setmeal中的数据
        this.removeByIds(ids);

        //删除套餐菜品表中，与该套餐相关的信息
        LambdaQueryWrapper<SetmealDish>lambdaQueryWrapper = new LambdaQueryWrapper<>();
        lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids);
        setmealDishService.remove(lambdaQueryWrapper);
    }
~~~

## 短信服务

![image-20230610174705210](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610174705210.png)

> 阿里云SMShttps://next.api.aliyun.com/document/Dysmsapi/2017-05-25/overview

![image-20230610174851037](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610174851037.png)

![image-20230610175216377](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610175216377.png)

![image-20230610174929040](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610174929040.png)

![image-20230610175548476](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230610175548476.png)



这一章主要还用了他自定义的一些类，感觉不如直接用阿里云教程的方法简单，也不是核心功能，所以不做展示



## 导入地址簿

![image-20230611085150444](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611085150444.png)

controller

~~~java
package com.test.controller;


import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.test.common.BaseContext;
import com.test.common.R;
import com.test.entity.AddressBook;
import com.test.service.AddressBookService;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/addressBook")
public class AddressBookController {
    @Autowired
    private AddressBookService addressBookService;

    /**
     * 新增
     * @param addressBook
     * @return
     */
    @PostMapping
    public R<AddressBook> save(@RequestBody AddressBook addressBook){
        //从线程里拿id
        addressBook.setUserId(BaseContext.getCurrentId());
        addressBookService.save(addressBook);
        return R.success(addressBook);
    }

    /**
     * 默认地址
     * @param addressBook
     * @return
     */
    @PostMapping("/default")
    public R<AddressBook>setDefault(@RequestBody AddressBook addressBook){
        LambdaUpdateWrapper<AddressBook> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(AddressBook::getUserId,BaseContext.getCurrentId());
        wrapper.set(AddressBook::getIsDefault,0);
        //SQL:update address_book set is_default = 0 where user_id = ?
        addressBookService.update(wrapper);

        addressBook.setIsDefault(1);
        //SQL:update address_book set is_default = 1 where id = ?
        addressBookService.updateById(addressBook);
        return R.success(addressBook);
    }

    /**
     * 查询默认地址
     */
    @GetMapping("default")
    public R<AddressBook> getDefault() {
        LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());
        queryWrapper.eq(AddressBook::getIsDefault, 1);

        //SQL:select * from address_book where user_id = ? and is_default = 1
        AddressBook addressBook = addressBookService.getOne(queryWrapper);

        if (null == addressBook) {
            return R.error("没有找到该对象");
        } else {
            return R.success(addressBook);
        }
    }

    /**
     * 查询指定用户的全部地址
     */
    @GetMapping("/list")
    public R<List<AddressBook>> list(AddressBook addressBook) {
        addressBook.setUserId(BaseContext.getCurrentId());
        log.info("addressBook:{}", addressBook);

        //条件构造器
        LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(null != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());
        queryWrapper.orderByDesc(AddressBook::getUpdateTime);

        //SQL:select * from address_book where user_id = ? order by update_time desc
        return R.success(addressBookService.list(queryWrapper));
    }


}

~~~

checkfilter

~~~java
        //如果user已经登录，当然也放行
        if ((request.getSession().getAttribute("user")!=null)){

            Long userId = (long)request.getSession().getAttribute("user");
            //在线程中保存id，方便公共填充字段那里使用
            BaseContext.setCurrentId(userId);

            filterChain.doFilter(request,response);
            return;

        }
        //如果未登录则的返回未登录结果，通过输出流方式向客户端页面响应数据，这里的msg是前端request.js判断要用的
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
        //log.info("拦截到请求:{}",request.getRequestURI());
        //放行，因为拦截是request和response都拦，所以都放
        //filterChain.doFilter(request,response);

~~~

## 菜品展示(front)

![image-20230611094311911](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611094311911.png)

这里前端展示菜品需求的接口是/dish/list，返回dishdto，包含套餐和菜品信息，这个接口之前就写好了，所以可以不管了

还有就是setmealController中也得写一个套餐返回的接口

~~~java

    /**
     * 前端首页展示时调用该接口，返回套餐选择
     * @param setmeal
     * @return
     */
    @GetMapping("/list")
    public R<List<Setmeal>> list(Setmeal setmeal) {
        log.info("setmeal:{}", setmeal);
        //条件构造器
        LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.like(StringUtils.isNotEmpty(setmeal.getName()), Setmeal::getName, setmeal.getName());
        queryWrapper.eq(null != setmeal.getCategoryId(), Setmeal::getCategoryId, setmeal.getCategoryId());
        queryWrapper.eq(null != setmeal.getStatus(), Setmeal::getStatus, setmeal.getStatus());
        queryWrapper.orderByDesc(Setmeal::getUpdateTime);

        return R.success(setmealService.list(queryWrapper));
    }

~~~

主要还得写购物车的接口

### 购物车

![image-20230611100256887](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611100256887.png)



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611100341205.png"/>

![image-20230611101013467](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611101013467.png)

#### 实现

controller

~~~java
package com.test.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.test.common.BaseContext;
import com.test.common.R;
import com.test.entity.ShoppingCart;
import com.test.service.ShoppingCartService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@Slf4j
@RestController
@RequestMapping("/shoppingCart")
public class ShoppingCartController {
    @Autowired
    private ShoppingCartService shoppingCartService;

    /**
     * 添加购物车
     * @param shoppingCart
     * @return
     */
    @PostMapping("/add")
    public R<ShoppingCart> add(@RequestBody ShoppingCart shoppingCart){
        log.info("购物车数据:{}",shoppingCart);
        //前端没有传UserId，因此需要自己设置，指定是哪个用户的购物车
        Long currentId = BaseContext.getCurrentId();
        shoppingCart.setUserId(currentId);

        Long dishId = shoppingCart.getDishId();

        LambdaQueryWrapper<ShoppingCart>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,currentId);
        if(dishId != null){
            //添加到购物车的是菜品
            queryWrapper.eq(ShoppingCart::getDishId,dishId);
        }else{
            //添加到购物车的是套餐
            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
        }

        //查询当前菜品或者套餐是否在购物车中，可以通过传来的是setmealid还是dishid判断是套餐还是菜品
        //SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?
        ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);


        if(cartServiceOne!=null){
            //如果已经存在，数量加一
            Integer number = cartServiceOne.getNumber();
            cartServiceOne.setNumber(number+1);
            shoppingCartService.updateById(cartServiceOne);
        }else{
            //如果不存在，则添加到购物车，数量默认是1
            shoppingCart.setNumber(1);
            //这里的表字段上没加那个注解，因此这里需要自己手动设置时间，而不是公共字段填充
            shoppingCart.setCreateTime(LocalDateTime.now());
            shoppingCartService.save(shoppingCart);
            cartServiceOne = shoppingCart;
            cartServiceOne = shoppingCart;
        }

        return R.success(cartServiceOne);
    }

    @GetMapping("/list")
    //查看当前user的购物车，id存在于线程里，因此前端可以什么都不传
    public R<List<ShoppingCart>> list(){
        log.info("查看购物车");
        LambdaQueryWrapper<ShoppingCart>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());
        queryWrapper.orderByDesc(ShoppingCart::getCreateTime);

        List<ShoppingCart>list = shoppingCartService.list(queryWrapper);

        return R.success(list);
    }

    @DeleteMapping("/clean")
    public R<String>clean(){
        //SQL:delete from shopping_cart where user_id = ?,然后把该用户数据全删了就行

        LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());

        shoppingCartService.remove(queryWrapper);

        return R.success("清空购物车成功");
    }
    /**
     * 减少套餐或者菜品
     */
    @PostMapping("/sub")
    public R<ShoppingCart> sub(@RequestBody ShoppingCart shoppingCart){
        log.info("购物车数据:{}",shoppingCart);

        //设置用户id，指定当前是哪个用户的购物车数据
        Long currentId = BaseContext.getCurrentId();
        shoppingCart.setUserId(currentId);

        Long dishId = shoppingCart.getDishId();

        LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(ShoppingCart::getUserId,currentId);

        if(dishId != null){
            //减少的是菜品
            queryWrapper.eq(ShoppingCart::getDishId,dishId);

        }else{
            //减少的是套餐
            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
        }

        //查询当前菜品或者套餐是否在购物车中
        //SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?
        ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);

        if(cartServiceOne != null){
            //如果已经存在，就在原来数量基础上一，这里要判断如果减到0，直接删除记录
            Integer number = cartServiceOne.getNumber();
            if(number==1){
                shoppingCartService.remove(queryWrapper);
            }else{
            cartServiceOne.setNumber(number-1);
            shoppingCartService.updateById(cartServiceOne);
            }
        }else{
            //如果不存在，说明传的参数有问题
            return  R.error("删除没有的东西!");
        }

        return R.success(cartServiceOne);
    }
}
~~~

#### 注意

1 增加和删除时，对number的判断

### 用户下单

![image-20230611110258416](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611110258416.png)

![image-20230611110459880](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611110459880.png)



![image-20230611110530094](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611110530094.png)

![image-20230611110654002](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611110654002.png)

![image-20230611110948743](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230611110948743.png)



#### 请求接口

/order/submit,

#### 实现

这里主要流程是从各个表里读出信息，然后把相应信息存到order和orderdetail表中，故略过



## 一些细节

1 静态资源要放在static或者templates文件下，不然不能访问。如果想放在其他文件夹，要专门写一个配置类。

![image-20230606112228005](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606112228005.png)