---
title: 瑞吉外卖基础后端开发
date: 2023-06-06
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Springboot
---

## 登录功能

首先打开已经给出的login.hml,按F12，打开网络，点击全部，然后点击网页中的登录，然后查看标头（Header）可以看到相关请求的信息。

![image-20230606113447872](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606113447872.png)

点击载荷，可以看到发送的json

![image-20230606113605883](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606113605883.png)

#### 参考：

[MP基础使用](https://www.jb51.net/article/223514.htm)

### 数据传输约定

![image-20230606114016269](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606114016269.png)

发现前端需要这些json字段，因此后端传输的json数据需要有这些字段



### 实现逻辑

![image-20230606113630533](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606113630533.png)

controller处理逻辑（注意比一般的登录多加了一个禁用字段，对应数据库表employee的status，如果该值为0，表示已经锁定）

![image-20230606180418962](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606180418962.png)

### 具体实现

新建一个entity，存储实体类，然后把Employee类创建；

~~~java
package com.test.entity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import lombok.Data;
import java.io.Serializable;
import java.time.LocalDateTime;

@Data
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;
    //之前说的数据库表和属性，如果有下划线的就可以映射为驼峰命名法
    //这个idNumber在数据库中是id_number

    private Integer status;

    private LocalDateTime createTime;

    private LocalDateTime updateTime;

    @TableField(fill = FieldFill.INSERT)
    private Long createUser;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;

}

~~~

然后创建Mapper包，写EmployeeMapper接口文件，**使用MP提供的通用类Mapper**

~~~java
package com.test.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.test.entity.Employee;
import org.apache.ibatis.annotations.Mapper;


@Mapper
public interface EmployeeMapper extends BaseMapper<Employee> {
    //这个BaseMapper包含了基础的增删改查等功能
}

~~~

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606115049344.png" style="zoom:90%">

创建对应service包，创建

![image-20230606174446673](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606174446673.png)

其中EmployeeService接口如下

~~~java
package com.test.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.test.entity.Employee;
//MP开发规范，继承他提供的服务类父类
public interface EmployeeService extends IService<Employee> {
}

~~~

实现类 EmployeeServiceImpl如下，同样的，继承自MP提供的类

~~~java
package com.test.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.test.entity.Employee;
import com.test.mapper.EmployeeMapper;
import com.test.service.EmployeeService;
import org.springframework.stereotype.Service;

@Service
//也是MP开发规范，继承他提供的服务类实现父类
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee>  implements EmployeeService {
}

~~~

最后实现Controller

~~~java
package com.test.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.test.common.R;
import com.test.entity.Employee;
import com.test.service.EmployeeService;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.DigestUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;


@Slf4j
 @RestController
 @RequestMapping("/employee")
 public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    @PostMapping("/login")
    //传入HttpServletRequest主要是为了session中还要使用
    public R<Employee> login(HttpServletRequest request, @RequestBody Employee employee){
        String password = employee.getPassword();
        password=DigestUtils.md5DigestAsHex(password.getBytes());

        LambdaQueryWrapper<Employee>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Employee::getUsername,employee.getUsername());
        Employee emp = employeeService.getOne(queryWrapper);

        if(emp == null){
            return R.error("登陆失败");
        }

        //密码比对，不一致返回失败
        if(!emp.getPassword().equals(password)){
            return R.error("登录失败");
        }

        //查看是否禁用，已经禁用返回已经禁用
        if(emp.getStatus()==0){
            return R.error("账号已禁用");
        }

        //登录成功，将员工存入Session并返回登录结果
        request.getSession().setAttribute("employee",emp.getId());
        return R.success(emp);

        }

     /**
      * 员工登出
      * @param request
      * @return
      */
    @PostMapping("/logout")
    public R<String> logout(HttpServletRequest request){
            request.getSession().removeAttribute("employee");
            //前端页面发送请求到logout，然后这个方法清除session中的值，并且返回一个R.Success,这里因为是前端是当返回退出成功时，也会同步清除本地的cookie
            return R.success("退出成功");
        }

}

~~~

#### 结果类

将所有的都返回结果封装为同一个类，新建一个包`common`，新建结果类R

~~~java
package com.test.common;

import lombok.Data;
import java.util.HashMap;
import java.util.Map;
/**
 * 通用返回结果类，所有的返回结果封装为此类
 * @param <T>
 */
@Data
public class R<T> {
    private Integer code; //编码：1成功，0和其它数字为失败
    private String msg; //错误信息
	//T是泛型
    private T data; //数据
    private Map map = new HashMap(); //动态数据
	//注意这里是静态方法，所以不用new 一个对象，直接用即可
    public static <T> R<T> success(T object) {
        R<T> r = new R<T>();
        r.data = object;
        r.code = 1;
        return r;
    }
    public static <T> R<T> error(String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }
    public R<T> add(String key, Object value) {
        this.map.put(key, value);
        return this;
    }
}
~~~

#### 退出登录

用户点击退出，发送请求到/employee/logout

- 清除Session中的用户id，
- 返回结果

#### 问题

1. springboot3内置tomcat10，对应的javaEE10，而本项目用的javaEE9，其中有一个大坑，javax更名为javaktra，导致很多包不能用，下面的错误就是换包后，HttpServlet实例化错误

~~~bash
at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590) ~[tomcat-embed-core-10.1.8.jar:6.0]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885) ~[spring-webmvc-6.0.9.jar:6.0.9]
~~~

解决：

**一开始就不要创建3.0的项目，用2.45，把pom直接拷贝过来，刷新就能用了**

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.5</version>
        <!--创项目时，不要用3，用springboot2-->
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.test</groupId>
    <artifactId>reggie</artifactId>
    <version>1.0-SNAPSHOT</version>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.2</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.20</version>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.76</version>
        </dependency>

        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.23</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.5</version>
            </plugin>
        </plugins>
    </build>
</project>
~~~



> 参考https://www.xyhtml5.com/48932.html

更改后成功访问，3.0真坑啊，市面上好多还是2.0，还是用spring2.0好，不然配置很浪费时间

2 输出中，sql有异常

![image-20230607110918809](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607110918809.png)

原因是使用的方法没有开启@Transactionnal那个注解，但是好像不影响使用？教程里也有一样问题



#### 完善登录功能

上面实现的登录功能，不管是不是从login进去，都能直接访问index.html，但是这显然不合理，因此需要修改，没有登录时，将直接访问index的请求重定向到login.html。**可以使用过滤器或者拦截器实现**

![image-20230607100054848](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607100054848.png)

##### 处理逻辑

![image-20230607101725521](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607101725521.png)





##### code

![image-20230607111141272](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111141272.png)

~~~java
package com.test.filter;

import com.alibaba.fastjson.JSON;
import com.test.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

//拦截器名字，后面是拦截路径，/*表示都拦截
@WebFilter(filterName = "LoginCheckFilter",urlPatterns = "/*")
//加了这个，可以通过日志的方法来输出
@Slf4j

public class LoginCheckFilter implements Filter {
    //IDEA中选中标红的接口，可以点实现类，然后自动生成函数名

    //路径匹配器，支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request =(HttpServletRequest)servletRequest;
        HttpServletResponse response = (HttpServletResponse)servletResponse;

        //获取本次请求uri
        String requestURI = request.getRequestURI();
        //定义不用处理的请求，但是如果直接这样写，对/backend/index.html这样的路径拦截会出问题
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "front/**"
        };

        boolean check = check(urls, requestURI);

        //在里面，直接放行
        if(check){
            filterChain.doFilter(request,response);
            return;

        }
        //如果已经登录，当然也放行
        if ((request.getSession().getAttribute("employee")!=null)){
            filterChain.doFilter(request,response);
            return;

        }
        //如果未登录则的返回未登录结果，通过输出流方式向客户端页面响应数据，这里的msg是前端request.js判断要用的
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
        //log.info("拦截到请求:{}",request.getRequestURI());
        //放行，因为拦截是request和response都拦，所以都放
        //filterChain.doFilter(request,response);
    }

    /**
     * 判断路径是否放行
     * @param urls
     * @param requestURI
     * @return
     */
    public boolean check(String[] urls,String requestURI){
        for(String url:urls){
            boolean match = PATH_MATCHER.match(url,requestURI);
            if(match){
                return true;
            }
        }
        return false;
    }
}

~~~

##### 拦截器

配置了这个东西之后，导致了一个问题，就是 对静态资源的访问也被拦截了，因此需要新建一个WebMvcConfig

> 参考：https://blog.csdn.net/qq_41091397/article/details/106929531

~~~java
    /**
     * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        super.addResourceHandlers(registry);
    }

~~~



## 员工管理

### 新增员工

![image-20230607111415165](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111415165.png)

#### 流程

![image-20230607111523825](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111523825.png)

**按F12，点击网络->ALL->header/荷载，可以看到请求发送的json的格式**

![image-20230607111827056](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111827056.png)

![image-20230607111835921](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607111835921.png)

#### 异常

![image-20230607114102633](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607114102633.png)

增加全局异常处理

![image-20230607173445251](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607173445251.png)

~~~java
package com.test.common;


import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常捕获
 */
@Slf4j
@ResponseBody
@ControllerAdvice(annotations ={RestController.class,Controller.class})
public class GlobalExceptionHandler {
    //这里是捕获SQL相关异常信息
    public R<String>exceptionHandler(SQLIntegrityConstraintViolationException ex){
        //log.error(ex.getMessage());
        //Duplicate entry 'admin' for key 'employee.idx_username'
        if(ex.getMessage().contains("Duplicate entry")){
            String[] split = ex.getMessage().split(" ");
            String msg = split[2]+"已存在";
            return R.error(msg);
        }
        return R.error("未知错误");
    }
}

~~~

#### 实现

~~~java
    /**
     * 增加员工
     * @param employee
     * @return
     */
    @PostMapping
    //这里因为前端就是直接访问的employee，这里路径不用写了
    public R<String> save(HttpServletRequest request,@RequestBody Employee employee){
        //log.info("新增员工，员工信息");
        //下面是需要手动设置的信息，有些数据库表有默认值，所以不用设置
        employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());

        //获取当前登录用户id
        Long empId =(Long)request.getSession().getAttribute("employee");

        employee.setCreateUser(empId);
        employee.setUpdateUser(empId);
        //MP中的通用方法，基于insert语句
        employeeService.save(employee);
        return R.success("新增员工成功");
    }
~~~



#### 总结

对于某个功能开发，基本上流程都一样

![image-20230607115813644](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607115813644.png)

### 分页

![image-20230607143141367](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607143141367.png)

进入界面的时候，会有自动请求（backend/page/list.html）分页数据，前端的代码，逻辑是创建完vue对象带上一些函数，注意这次发送给后端的不是json，就时普通的key-value

![image-20230607143423133](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607143423133.png)

#### 实现

都是基于MP提供的方法来开发，首先开启mybatis分页插件

![image-20230607173704901](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607173704901.png)

~~~java
package com.test.config;

import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 配置MP的分页插件
 */
@Configuration
public class MybatisPlusConfig {
    //利用MP提供拦截器实现
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor((new PaginationInnerInterceptor()));
        return mybatisPlusInterceptor;
    }
}

~~~

~~~java
//直接加到employee controller中    
/**
     * 员工信息分页查询
     * @param page
     * @param pageSize
     * @param name
     * @return
     */
    @GetMapping("/page")
    //一般来说需要page和pageSize，之所以这里有name，是因为他还可以根据name来搜员工，因此写一起了，不穿name就默认为null，也能正常查到
    public R<Page>page(int page,int pageSize,String name){
        //log.info("page={},pagesize={},name={}",page,pageSize,name);

        //构造分页构造器
        Page pageInfo = new Page(page,pageSize);
        //构造条件构造器，这里根据name来过滤
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper();
        //StringUtils.isNotEmpty(name),这个方法很多包都要，注意导入common.lang才有这个方法
        //其实就是如果name不为空，才进行like，为空like不生效，相当于if like,else continue;
        //根据第一个参数判断是否进行like，这句话就是只有name不为空才进行，否则相当于没有这句话
        queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);//queryWrapper相当于sql的where

        //添加降序排序
        queryWrapper.orderByDesc(Employee::getUpdateTime);

        //执行查询
        //这里的page也是MP提供的，并且这条语句执行后，会将查询结果赋值给pageInfo
        employeeService.page(pageInfo,queryWrapper);
        return R.success(pageInfo);

    }
~~~

### 启用/禁用状态修改

就是修改status为0或者1

注意这里前端已经实现了0/1的变化

![image-20230607174637605](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607174637605.png)

~~~java
   /**
     * 根据id修改信息
     * @param request
     * @param employee
     * @return
     */
    @PutMapping
    public R<String>update(HttpServletRequest request,@RequestBody Employee employee){
        //log.info(employee.toString());
        //修改status的操作在前端，因此只需要顺便加上时间和操作人即可
        Long empId =(Long)request.getSession().getAttribute("employee");
        employee.setUpdateTime(LocalDateTime.now());
        employee.setUpdateUser(empId);
        employeeService.updateById(employee);
        return R.success("员工信息修改成功");
    }
~~~

#### 注意：

1.注意ID是long型，但是js最多处理16位，也就是前端处理时收到的只能保证只有前16位是准的，所以要在后端把Long型统一转换为String类型

![image-20230607171552455](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607171552455.png)



首先配置转换类

~~~java
package com.test.common;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

		//就是把很多类型都转成String了
        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}

~~~



然后增加一个webmvc的消息转换器

![image-20230607173855125](C:/Users/28788/AppData/Roaming/Typora/typora-user-images/image-20230607173855125.png)

~~~java
package com.test.config;


import com.test.common.JacksonObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

import java.util.List;

@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {


    /**
     * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        super.addResourceHandlers(registry);
    }


    /**
     * 扩展MVC消息转换器
     * @param converters
     */
    @Override
    //输入ex可以有候选
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        //log.info("扩展消息转换器");
        //创建消息转换器对象
        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
        //设置对象转换器，底层使用jackson将java对象转换为json
        messageConverter.setObjectMapper(new JacksonObjectMapper());
        //将上面的消息转换器对象追加到mvc框架的转换器集合中
        //这里的0代表转换器的优先级，0最高
        converters.add(0,messageConverter);
    }
}

~~~

![image-20230607173216929](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607173216929.png)



### 编辑员工信息

#### 操作流程

![image-20230607195322109](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607195322109.png)

> add.html是公共页面，新增员工和编辑员工都在这里

点击编辑按钮时，会跳转到add，并且携带了一个参数ID

![image-20230607195710677](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607195710677.png)



分析前端代码，的确传了id，这里没去探究具体细节，但只要知道从url中获取了id

![image-20230607200153096](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607200153096.png)

#### 实现

~~~java
    @GetMapping("/id")
    public R<Employee>getById(@PathVariable Long id){
        //log.info("根据id查询员工信息...")
        Employee employee = employeeService.getById(id);
        if(employee!=null){
            //会在修改页展示之前的信息
            return R.success(employee);
        }
        return R.error("未查询到信息");
        //最后的保存调用的之前的Update方法，那个是通用方法
    }

~~~



## 菜品相关

### 公共字段填充

如果很多表都有一些相同的属性，就可以考虑公共字段填充减少代码量

![image-20230607202516464](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607202516464.png)

#### 实现

![image-20230607202544789](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607202544789.png)

#### ThreadLocal

![image-20230607210804992](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607210804992.png)

> 在一个调用链上，都是一个线程，因此才可以借助线程拿到id，这一点很重要，必须在一个线程内

##### 介绍

![image-20230607211419129](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607211419129.png)

![image-20230607211639174](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607211639174.png)

#### 代码

首先创建

![image-20230607213546644](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213546644.png)

BaseContext

~~~java
package com.test.common;

/**
 * 基于ThreadLocal的封装工具类，用户保存和获取当前登录用户id
 * 注意ThreadLocal也只是一个局部变量，所以只能保存一个值
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public  static void setCurrentId(Long id){
        threadLocal.set(id);
    }

    public static Long getCurrentId(){
        return threadLocal.get();
    }
}

~~~

 MyMetaObjecthandler

~~~java
package com.test.common;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * 自定义元数据处理器
 */
@Component
@Slf4j
public class MyMetaObjecthandler  implements MetaObjectHandler {

    //插入操作，自动填充
    @Override
    public void insertFill(MetaObject metaObject) {
        //log.info(metaObject.toString());
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime",LocalDateTime.now());

        //这里注意，需要根据用户id来填user，并且这个类里没有httpSession，于是可以用ThreadLocal来获取id
        //利用ThreadLocal获取了值
        metaObject.setValue("createUser",BaseContext.getCurrentId());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }

    //更新操作，自动填充
    @Override
    public void updateFill(MetaObject metaObject) {
        //log.info(metaObject.toString());
        metaObject.setValue("updateTime",LocalDateTime.now());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }
}

~~~

在controller注释掉之前的公共字段设置的语句

![image-20230607213731626](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213731626.png)

![image-20230607213750857](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213750857.png)

filter中加入设置id的语句即可

![image-20230607213826109](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607213826109.png)



### 新增/查询分类（菜品/套餐）

都在category表中，主要关注name是唯一约束，通过type来分辨菜品/套餐，sort是移动端对展示的菜品的排序

![image-20230607214243627](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607214243627.png)

同样的实现逻辑

![image-20230607214426842](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607214426842.png)

程序执行逻辑

![image-20230607215626858](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607215626858.png)

Controller代码

~~~java
package com.test.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.test.common.R;
import com.test.entity.Category;
import com.test.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 分类管理
 */
@RestController
@RequestMapping("/category")
@Slf4j
public class CategoryController  {
    @Autowired
    private CategoryService categoryService;

    /**
     * 新增分类
     * @param category
     * @return
     */
    @PostMapping
    public R<String>save(@RequestBody Category category){
        //log.info("保存");
        categoryService.save(category);
        //因为定义了全局的sql异常处理，所以当重复创建重名菜时也会被全局那个捕捉到
        //同样的，那些设置字段值的也被那个公共字段填充类填充了
        return R.success("新增分类成功");
    }

    /**
     * 分页查询
     * @param page
     * @param pageSize
     * @return
     */
    @GetMapping("/page")
    public R<Page>page(int page,int pageSize){
        //分页构造器
        Page<Category>pageInfo = new Page<>(page,pageSize);
        //条件构造器，主要是里面有个sort，需要返回有序的数据
        LambdaQueryWrapper<Category>queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.orderByAsc(Category::getSort);
        //进行分页查询
        categoryService.page(pageInfo,queryWrapper);
        return R.success(pageInfo);
    }
}
~~~

### 删除分类

![image-20230607222047570](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607222047570.png)

流程

![image-20230607222128116](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607222128116.png)

![image-20230607222552411](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230607222552411.png)





## 一些细节

1 静态资源要放在static或者templates文件下，不然不能访问。如果想放在其他文件夹，要专门写一个配置类。

![image-20230606112228005](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230606112228005.png)