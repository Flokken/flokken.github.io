---
title: 瑞吉外卖优化
date: 2023-06-13
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Springboot
---

## 缓存优化

如果同时有多个用户访问，都需要从数据库请求菜品数据，就会导致数据库性能下降，可能需要加载好一会，因此可以使用缓存优化

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230613112415254.png" style="zoom:90%">



### 引入redis

~~~xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
~~~



### 创建template

自定义一个RedisTemplate,（默认的jdk序列化16进制表示可以，value，可读性很差）

~~~java
@Configuration
public class RedisConfig extends CachingConfigurerSupport {
    @Bean
    public RedisTemplate<Object,Object>redisTemplate(RedisConnectionFactory connectionFactory){
        RedisTemplate<Object,Object>redisTemplate = new RedisTemplate<>();
        //默认使用jdk序列化器，不好使，一般都要改成这个
        //如果不自己创建redisTemplate也可以，但是框架提供的该模板用的是jdk序列化器，不方便
        //这里只改了可以的序列化，value还是16进制的jdk序列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setConnectionFactory(connectionFactory);
        return redisTemplate;
    }
}
~~~

如果不自己设置，框架也会提供一个，如下

![image-20230614164148501](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614164148501.png)

![image-20230614164207481](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614164207481.png)

> 阅读代码，如果自己创建了，就不会生效，如果没有，才会生效。通过下面这个注解来判断是否自己创建了一个redisTemplate
>
> ```
> @Bean
> @ConditionalOnMissingBean(
>     name = {"redisTemplate"}
> )
> ```

### 缓存短信验证码

原先的手机验证码保存在session中，现在将其更改存储到cache中

注入redisTemplate

> 这里因为我们的config中，把redisConfig加到bean管理了，所以可以直接注入

![image-20230614165705723](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614165705723.png)

1先把验证码加入redis

![image-20230614165659682](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614165659682.png)

> （key，value）的数据

2从redis中读取验证码



![image-20230614165801593](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614165801593.png)

3登录成功后删除数据

![image-20230614165810711](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614165810711.png)

### 缓存菜品数据

菜品数据现在是点击移动端，就会向数据库查询，一旦很多人一起访问，数据库压力很大，所以需要缓存

思路：

1.改造DishController中的list方法，先从Redis中获取菜品数据，有则直接返回，无需查询数据库，如果没有则查询数据库，并且将查询到的菜品放入Redis

2.**改造DishController的save和update，加入清理缓存的逻辑**

~~~java
   @GetMapping("/list")
    public R<List<DishDto>> list(Dish dish){
        //dtoList是要返回的数据集，因此我们可以直接存他就行
        List<DishDto>dishDtos = null;

        //key构造，这里存的应该是key,list对象，也就是一个分类对应的菜品有哪些
        //前端传来分类id和status（是否在售），可以用这两个构造，status没啥用，主要是分类id
        String key = "dish_"+dish.getCategoryId()+"_"+dish.getStatus();
        //dish_12312431_1   这样写方便观察啥意思

        //先从redis中获取请求数据
        dishDtos  = (List<DishDto>)redisTemplate.opsForValue().get(key);
        //如果存在，直接返回
        if(dishDtos !=null){
            return R.success(dishDtos );
        }
        //如果不存在，查询数据库，将查询到的数据存到redis
        //log.info("dish:{}",dish);
        LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.like(StringUtils.isNotEmpty(dish.getName()), Dish::getName, dish.getName());
        queryWrapper.eq(null != dish.getCategoryId(), Dish::getCategoryId, dish.getCategoryId());
        //添加条件，查询状态为1（起售状态）的菜品
        queryWrapper.eq(Dish::getStatus,1);
        queryWrapper.orderByDesc(Dish::getUpdateTime);
        //将Wrapper数据转换为数组
        List<Dish> dishs = dishService.list(queryWrapper);
		//这里稍微修改一下，把他提到前面，因为需要判断
        dishDtos = dishs.stream().map(item->{
            DishDto dishDto = new DishDto();
            BeanUtils.copyProperties(item,dishDto);
            Category category = categoryService.getById(item.getCategoryId());
            if(category!=null){
                //设置dto的分类名称字段
                dishDto.setCategoryName(category.getName());
            }
            LambdaQueryWrapper<DishFlavor>wrapper = new LambdaQueryWrapper<>();
            wrapper.eq(DishFlavor::getDishId,item.getId());
            //设置dto的flavor
            dishDto.setFlavors(dishFlavorService.list(wrapper));
            return dishDto;

        }).collect(Collectors.toList());
        //这里存到redis
        redisTemplate.opsForValue().set(key,dishDtos ,60, TimeUnit.MINUTES);
        return R.success(dishDtos);
    }
~~~

#### 清理菜品缓存

理由：因为有可能修改了菜品，或者新增了菜品，此时如果不清理，**就会造成缓存和数据库的数据不一致！为了保证数据一致性，必须清理**

~~~java
    @PutMapping
    public R<String>update(@RequestBody DishDto dishDto){
        log.info(dishDto.toString());
        dishService.updateWithFlavor(dishDto);

//        //清理所有菜品缓存数据，所有分类
//        Set keys = redisTemplate.keys("dish_*");
//        redisTemplate.delete(keys);

        //清理该分类菜品缓存,因为状态都是1，写死就行
        String key = "dish_"+dishDto.getCategoryId()+"_1";
        redisTemplate.delete(key);


        return R.success("新增菜品成功");
    }
~~~

#### 验证

连接服务器，然后`redis-cli`,

`select 0`,输入`keys *`可以看到缓存的数据

### Spring cache

spring 提供的一个框架,实现了基于注解的的缓存功能，

提供一层抽象，底层可以切换不同的cache实现，**具体就是通过CacheManager接口来统一·不同的缓存技术。**

![image-20230614180335750](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614180335750.png)

常用注解

![image-20230614180352157](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614180352157.png)



> 注意spring-web包中就已经有spring cache了，可以用他的部分注解，只不过要用redis等其他的cache要额外导入相关包
>
> **@EnableCaching是加到application上面**

#### 基本案例

mysql有表user(id,name,age,address)

![image-20230614205347383](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614205347383.png)

> pom中导入了spring-web，因为里面有cache

首先开启缓存功能

![image-20230614205441168](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614205441168.png)

接下来改写userController的方法

首先注入cacheManager

```
@Autowired
private CacheManager cacheManager;


```

**注意注解里的value参数指的是缓存的名称（相当于一个文件夹，key-value都会存到这里面）**

~~~java

//key的写法可以在cache的方法代码里看到

/**
     * CachePut：将方法返回值放入缓存
     * value：缓存的名称，每个缓存名称下面可以有多个key
     * key：缓存的key
     */
    @CachePut(value = "userCache",key = "#user.id")
	//#是spel（spring表达式）的写法，作用是是获取下面的方法里的东西
    @PostMapping
    public User save(User user){
        userService.save(user);
        return user;
    }

    /**
     * CacheEvict：清理指定缓存
     * value：缓存的名称，每个缓存名称下面可以有多个key
     * key：缓存的key
     * 下面三种方法等价
     */
    @CacheEvict(value = "userCache",key = "#p0") //方法的第一个参数
    //@CacheEvict(value = "userCache",key = "#root.args[0]")  方法的第一个参数
    //@CacheEvict(value = "userCache",key = "#id")
    @DeleteMapping("/{id}")
    public void delete(@PathVariable Long id){
        userService.removeById(id);
    }

    //@CacheEvict(value = "userCache",key = "#p0.id")
    //@CacheEvict(value = "userCache",key = "#user.id")
    //@CacheEvict(value = "userCache",key = "#root.args[0].id")
    @CacheEvict(value = "userCache",key = "#result.id")
    @PutMapping
    public User update(User user){
        userService.updateById(user);
        return user;
    }

    /**
     * Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中
     * value：缓存的名称，每个缓存名称下面可以有多个key
     * key：缓存的key
     * condition：条件，满足条件时才缓存数据
     * unless：满足条件则不缓存
     */
    @Cacheable(value = "userCache",key = "#id",unless = "#result == null")
	//#result指的是去方法返回值
    @GetMapping("/{id}")
    public User getById(@PathVariable Long id){
        User user = userService.getById(id);
        return user;
    }

    @Cacheable(value = "userCache",key = "#user.id + '_' + #user.name")
    @GetMapping("/list")
    public List<User> list(User user){
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(user.getId() != null,User::getId,user.getId());
        queryWrapper.eq(user.getName() != null,User::getName,user.getName());
        List<User> list = userService.list(queryWrapper);
        return list;
    }
~~~

#### 把底层缓存切换为redis

![image-20230614210758558](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614210758558.png)

### 缓存套餐数据

使用springcache实现

![image-20230614211049445](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614211049445.png)

redis已经导入，还需导入spring cache

~~~xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
~~~

配置

~~~yaml
spring:  
    cache:
        redis:
          time-to-live: 1800000
~~~

然后application中开启缓存，加入注解即可

~~~java
@ServletComponentScan
//加了webFilter这种注解要加这个注解才能扫描到

@SpringBootApplication
@EnableCaching
public class ReggieApplication {

    public static void main(String[] args) {

        SpringApplication.run(ReggieApplication.class, args);
        //log.info("项目启动成功");
    }
}
~~~

然后给R实现 Serializable接口

> 只要类要缓存，从缓存中读取时都需要序列化，因此这种类都要继承这个接口

![image-20230614212417970](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614212417970.png)

list

~~~java
 @GetMapping("/list")
 @Cacheable(value = "setmealCache",key="#setmeal.categoryId+ '_'+#setmeal.status")
~~~

删除和新增数据、

~~~java
@DeleteMapping
@CacheEvict(value = "setmealCache",allEntries = true)
//这里的意思是删除所有setmealCache这个分类下的数据
~~~

## 读写分离

现在只有一台服务器，他的压力很大，并且如果服务器坏了，数据也就丢失了，因此可以进行读写分离优化

![image-20230614214627128](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614214627128.png)

### mysql主从复制介绍

> 主库增删改，从库查询

![image-20230614214718050](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614214718050.png)

![image-20230614214848888](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614214848888.png)

![image-20230614214901192](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614214901192.png)

> mysql自带了这个功能，只需配置即可

首先得有两个安装好mysql的服务器

![image-20230614215214705](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614215214705.png)

#### master配置

![image-20230614215235224](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614215235224.png)

> id用来区别多台服务器的

然后重启`systemctl restart mysqld`

登录mysql,执行

~~~sql
GRANT REPLICATION SLAVE ON *.* to 'xiaoming'@'%' identified by 'Root@123456'
~~~

> 创建一个用户test，密码是test，然后给他复制的权限，salve必须被master授权具有该权限的用户，才能通过该用户复制

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614215811281.png"/>

#### slave配置

![image-20230614215850907](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614215850907.png)

然后重启`systemctl restart mysqld`

**注意读取的bin文件名要和上面的那张图一样**

![image-20230614215922237](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614215922237.png)

> 到这里就配置完了，主库的更新会更新到从库

![image-20230614220128516](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614220128516.png)

### 基本案例

#### shaeding-JDBC

![image-20230614220512442](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614220512442.png)

![image-20230614220552262](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230614220552262.png)

配置

~~~yaml
server:
  port: 8080
mybatis-plus:
  configuration:
    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: ASSIGN_ID
spring:
  shardingsphere:
    datasource:
      names:
        master,slave
      # 主数据源
      master:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://192.168.138.100:3306/rw?characterEncoding=utf-8
        username: root
        password: root
      # 从数据源
      slave:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://192.168.138.101:3306/rw?characterEncoding=utf-8
        username: root
        password: root
    masterslave:
      # 读写分离配置
      #这里这个选项是负载均衡，这里是因为可能有多个从库，这时候查询就可以按顺序分给不同的从库
      load-balance-algorithm-type: round_robin #轮询
      # 最终的数据源名称
      name: dataSource
      # 主库数据源名称
      master-data-source-name: master
      # 从库数据源名称列表，多个逗号分隔
      slave-data-source-names: slave
      #slave1,salve2
    props:
      sql:
        show: true #开启SQL显示，默认false
  #允许bean定义覆盖配置项
  main:
    allow-bean-definition-overriding: true
~~~

**java代码不用改，只需要改配置文件即可**

### Nginx
