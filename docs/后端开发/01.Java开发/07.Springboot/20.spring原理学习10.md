---
title: spring原理学习10-容器事件和事件监听器
date: 2024-01-22
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Springboot
---

## java

在Java中，`E`和`?`是用作泛型类型参数的占位符。并且`E`和`?`只是约定俗成的命名惯例

- `E`通常用作泛型类或接口的类型参数，表示一个未知的具体类型。它表示"Element"（元素）的缩写，用于表示集合中的元素类型。例如，`List<E>`表示一个元素类型为`E`的列表。
- `?`是通配符类型参数，表示任意类型。它在泛型中用于表示不确定的类型。例如，`List<?>`表示一个未知元素类型的列表。通配符类型参数可以用于方法的参数、返回类型、类型限定等地方，用于增加灵活性和泛化性。

## 目标

在 Spring 中有一个 Event 事件功能，它可以提供事件的定义、发布以及监听事件来完成一些自定义的动作。比如你可以定义一个新用户注册的事件，当有用户执行注册完成后，在事件监听中给用户发送一些优惠券和短信提醒，这样的操作就可以把属于基本功能的注册和对应的策略服务分开，降低系统的耦合。以后在扩展注册服务，比如需要添加风控策略、添加实名认证、判断用户属性等都不会影响到依赖注册成功后执行的动作。

那么在本章节我们需要以观察者模式的方式，设计和实现 Spring Event 的容器事件和事件监听器功能，**最终在 Spring 框架中可以定义、监听和发布自己的事件信息。**

## 方案

事件的设计本身就是一种观察模式的实现，，它所要解决的就是一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

在功能实现上我们需要定义出**事件类、事件监听、事件发布，**而这些类的功能需要结合到 Spring 的 AbstractApplicationContext#refresh()，**以便于处理事件初始化和注册事件监听器的操**作。整体设计结构如下图

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/spring-11-01.png)

- 在整个功能实现过程中，仍然需要在面向用户的应用上下文 `AbstractApplicationContext` 中添加相关事件内容，包括：初始化事件发布者、注册事件监听器、发布容器刷新完成事件。
- 使用观察者模式定义事件类、监听类、发布类，同时还需要完成一个广播器的功能，接收到事件推送时进行分析处理符合监听事件接受者感兴趣的事件，也就是使用 isAssignableFrom 进行判断。
- isAssignableFrom 和 instanceof 相似，不过 **isAssignableFrom 是用来判断子类和父类的关系的**，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。**如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来。**

**容器事件和事件监听器实现类关系，如图**

![Bean10.drawio11111](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/Bean10.drawio11111.png)

- 以上整个类关系图以围绕实现 event 事件定义、发布、监听功能实现和把事件的相关内容使用 AbstractApplicationContext#refresh 进行注册和处理操作。
- 在实现的过程中主要以扩展 spring context 包为主，事件的实现也是在这个包下进行扩展的.
- ApplicationContext 容器继承事件发布功能接口 ApplicationEventPublisher，并在实现类中提供事件监听功能。
- ApplicationEventMulticaster **接口是注册监听器和发布事件的广播器，提供添加、移除和发布事件方法**。
- 最后是发布容器关闭事件，这个仍然需要扩展到 AbstractApplicationContext#close 方法中，由注册到虚拟机的钩子实现。

## 工程结构

```java
small-spring-step-10
└── src
    ├── main
    │   └── java
    │       └── cn.bugstack.springframework
    │           ├── beans
    │           │   ├── factory
    │           │   │   ├── config
    │           │   │   │   ├── AutowireCapableBeanFactory.java
    │           │   │   │   ├── BeanDefinition.java
    │           │   │   │   ├── BeanFactoryPostProcessor.java
    │           │   │   │   ├── BeanPostProcessor.java
    │           │   │   │   ├── BeanReference.java
    │           │   │   │   ├── ConfigurableBeanFactory.java
    │           │   │   │   └── SingletonBeanRegistry.java
    │           │   │   ├── support
    │           │   │   │   ├── AbstractAutowireCapableBeanFactory.java
    │           │   │   │   ├── AbstractBeanDefinitionReader.java
    │           │   │   │   ├── AbstractBeanFactory.java
    │           │   │   │   ├── BeanDefinitionReader.java
    │           │   │   │   ├── BeanDefinitionRegistry.java
    │           │   │   │   ├── CglibSubclassingInstantiationStrategy.java
    │           │   │   │   ├── DefaultListableBeanFactory.java
    │           │   │   │   ├── DefaultSingletonBeanRegistry.java
    │           │   │   │   ├── DisposableBeanAdapter.java
    │           │   │   │   ├── FactoryBeanRegistrySupport.java
    │           │   │   │   ├── InstantiationStrategy.java
    │           │   │   │   └── SimpleInstantiationStrategy.java  
    │           │   │   ├── support
    │           │   │   │   └── XmlBeanDefinitionReader.java
    │           │   │   ├── Aware.java
    │           │   │   ├── BeanClassLoaderAware.java
    │           │   │   ├── BeanFactory.java
    │           │   │   ├── BeanFactoryAware.java
    │           │   │   ├── BeanNameAware.java
    │           │   │   ├── ConfigurableListableBeanFactory.java
    │           │   │   ├── DisposableBean.java
    │           │   │   ├── FactoryBean.java
    │           │   │   ├── HierarchicalBeanFactory.java
    │           │   │   ├── InitializingBean.java
    │           │   │   └── ListableBeanFactory.java
    │           │   ├── BeansException.java
    │           │   ├── PropertyValue.java
    │           │   └── PropertyValues.java 
    │           ├── context  
    │           │   ├── event
    │           │   │   ├── AbstractApplicationEventMulticaster.java 
    │           │   │   ├── ApplicationContextEvent.java 
    │           │   │   ├── ApplicationEventMulticaster.java 
    │           │   │   ├── ContextClosedEvent.java 
    │           │   │   ├── ContextRefreshedEvent.java 
    │           │   │   └── SimpleApplicationEventMulticaster.java 
    │           │   ├── support
    │           │   │   ├── AbstractApplicationContext.java 
    │           │   │   ├── AbstractRefreshableApplicationContext.java 
    │           │   │   ├── AbstractXmlApplicationContext.java 
    │           │   │   ├── ApplicationContextAwareProcessor.java 
    │           │   │   └── ClassPathXmlApplicationContext.java 
    │           │   ├── ApplicationContext.java 
    │           │   ├── ApplicationContextAware.java 
    │           │   ├── ApplicationEvent.java 
    │           │   ├── ApplicationEventPublisher.java 
    │           │   ├── ApplicationListener.java 
    │           │   └── ConfigurableApplicationContext.java
    │           ├── core.io
    │           │   ├── ClassPathResource.java 
    │           │   ├── DefaultResourceLoader.java 
    │           │   ├── FileSystemResource.java 
    │           │   ├── Resource.java 
    │           │   ├── ResourceLoader.java 
    │           │   └── UrlResource.java
    │           └── utils
    │               └── ClassUtils.java
    └── test
        └── java
            └── cn.bugstack.springframework.test
                ├── event
                │   ├── ContextClosedEventListener.java
                │   ├── ContextRefreshedEventListener.java
                │   ├── CustomEvent.java
                │   └── CustomEventListener.java
                └── ApiTest.java

```

### 定义和实现事件

```java
public abstract class ApplicationEvent extends EventObject {

    /**
     * Constructs a prototypical Event.
     *
     * @param source The object on which the Event initially occurred.
     * @throws IllegalArgumentException if source is null.
     */
    public ApplicationEvent(Object source) {
        super(source);
    }

}

```

- 以继承 java.util.EventObject 定义出具备事件功能的抽象类 ApplicationEvent，后续所有事件的类都需要继承这个类。

```java
public class ApplicationContextEvent extends ApplicationEvent {
    /**
     * Constructs a prototypical Event.
     * 创建一个原型事件
     *
     * @param source The object on which the Event initially occurred.
     * @throws IllegalArgumentException if source is null.
     */
    public ApplicationContextEvent(Object source) {
        super(source);

    }

    /**
     * Get the <code>ApplicationContext</code> that the event was raised for.
     * 获取引发事件的ApplicationContext
     */
    public  final ApplicationContext getApplicationContext(){
        return (ApplicationContext) getSource();
    }
}



public class ContextClosedEvent extends ApplicationContextEvent{

    /**
     * Constructs a prototypical Event.
     *
     * @param source The object on which the Event initially occurred.
     * @throws IllegalArgumentException if source is null.
     */
    public ContextClosedEvent(Object source) {
        super(source);
    }

}


public class ContextRefreshedEvent extends ApplicationContextEvent{
    /**
     * Constructs a prototypical Event.
     *
     * @param source The object on which the Event initially occurred.
     * @throws IllegalArgumentException if source is null.
     */
    public ContextRefreshedEvent(Object source) {
        super(source);
    }

}

```

- ApplicationEvent 是定义事件的抽象类，所有的事件包括关闭、刷新，以及用户自己实现的事件，都需要继承这个类。
- ContextClosedEvent、ContextRefreshedEvent，分别是 Spring 框架自己实现的两个事件类，可以用于监听刷新和关闭动作。

### 事件监听器

**com.inet.context**

```java

public interface ApplicationListener <E extends ApplicationEvent> extends EventListener {
    /**
     * Handle an application event.
     * 监听一个事件的方法
     * @param event the event to respond to
     */
    void onApplicationEvent(E event);
}

```

- 事件监听器类，监听某种事件

###  事件广播器

**com.inet.context.event.ApplicationEventMulticaster**

```java
public interface ApplicationEventMulticaster {
    /**
     * Add a listener to be notified of all events.
     * 添加一个监听器，以便通知所有事件。
     * @param listener the listener to add
     */
    void addApplicationListener(ApplicationListener<?> listener);

    /**
     * Remove a listener from the notification list.
     * 从通知列表中移除一个监听器。
     * @param listener the listener to remove
     */
    void removeApplicationListener(ApplicationListener<?> listener);

    /**
     * Multicast the given application event to appropriate listeners.
     * 将给定的应用程序事件广播给适当的监听器。
     * @param event the event to multicast
     */
    void multicastEvent(ApplicationEvent event);

}

```

- 在事件广播器中定义了添加监听和删除监听的方法以及一个广播事件的方法 `multicastEvent` 最终推送时间消息也会经过这个接口方法来处理谁该接收事件。

```java
/**
 * Abstract implementation of the {@link ApplicationEventMulticaster} interface,
 * providing the basic listener registration facility.
 * 提供基础的监听器注册功能
 */
public abstract class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster, BeanFactoryAware {

    //监听器集合
    public final Set<ApplicationListener<ApplicationEvent>> applicationListeners = new LinkedHashSet<>();

    private BeanFactory beanFactory;

    @Override
    public void addApplicationListener(ApplicationListener<?> listener){
        applicationListeners.add((ApplicationListener<ApplicationEvent>) listener);
    }

    @Override
    public void removeApplicationListener(ApplicationListener<?> listener){
        applicationListeners.remove(listener);
    }

    @Override
    public final void setBeanFactory(BeanFactory beanFactory){
        this.beanFactory = beanFactory;
    }
    /**
     * Return a Collection of ApplicationListeners matching the given
     * event type. Non-matching listeners get excluded early.
     * 返回给定事件类型下的所有事件监听器
     * @param event the event to be propagated. Allows for excluding
     * non-matching listeners early, based on cached matching information.
     * @return a Collection of ApplicationListeners
     */
    protected Collection<ApplicationListener>getApplicationListeners(ApplicationEvent event){
        LinkedList<ApplicationListener>allListeners = new LinkedList<ApplicationListener>();
        for(ApplicationListener<ApplicationEvent> listener: applicationListeners){
            if(supportsEvent(listener,event)) allListeners.add(listener);
        }
        return allListeners;
    }

    /**
     * 监听器是否对这个事件感兴趣（监听这个事件）
     * @param applicationListener
     * @return
     */
    protected boolean supportsEvent(ApplicationListener<ApplicationEvent> applicationListener, ApplicationEvent event){

        Class<? extends ApplicationListener> listenerClass = applicationListener.getClass();
        // 按照 CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy 不同的Bean实例化类型，需要判断后获取目标 class
        Class<?> targetClass = ClassUtils.isCglibProxyClass(listenerClass) ? listenerClass.getSuperclass() : listenerClass;
        Type genericInterface = targetClass.getGenericInterfaces()[0];

        //这行代码的作用是获取泛型接口的实际类型参数,而第一个参数就是我们要的类名。
        //genericInterface 是一个表示泛型接口的 Type 对象。
        //通过将 genericInterface 强制转换为 ParameterizedType，我们可以访问泛型接口的详细信息。
        Type actualTypeArgument = ((ParameterizedType) genericInterface).getActualTypeArguments()[0];
        String className = actualTypeArgument.getTypeName();
        Class<?> eventClassName;
        try {
            //className 是一个字符串，表示一个类的完全限定名。
            //Class.forName(className) 是一个静态方法，它根据给定的类名字符串返回对应的 Class 对象。
            //Class.forName() 方法会根据类名字符串动态加载类，并返回对应的 Class 对象。
            eventClassName =Class.forName(className);
        }catch (ClassNotFoundException e){
            throw new BeansException("wrong event class name:"+ className);
        }
      // 判定此 eventClassName 对象所表示的类或接口与指定的 event.getClass() 参数所表示的类或接口是否相同，或是否是其超类或超接口。
        return eventClassName.isAssignableFrom(event.getClass());

    }

}

```

- AbstractApplicationEventMulticaster 是对事件广播器的公用方法提取，**在这个类中可以实现一些基本功能**，避免所有直接实现接口类还需要处理细节。
- 除了像 addApplicationListener、removeApplicationListener，这样的通用方法，这里这个类中主要是对 getApplicationListeners 和 supportsEvent 的处理。
  - getApplicationListeners 方法主要是摘取符合广播事件中的监听处理器，具体过滤动作在 supportsEvent 方法中。
  - 在 supportsEvent 方法中，主要包括对Cglib、Simple不同实例化需要获取目标Class，**Cglib代理类需要获取父类的Class，普通实例化的不需要**。接下来就是通过提取接口和对应的 ParameterizedType 和 eventClassName，方便最后确认是否为子类和父类的关系，以此证明此事件归这个符合的类处理。*可以参考代码中的注释*

**supportsEvent 方法运行截图**

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/spring-11-03.png)

- 在代码调试中可以看到，最终 eventClassName 和 event.getClass() 在 isAssignableFrom 判断下为 true
- 关于 CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy 可以尝试在 AbstractApplicationContext 类中更换验证。

###   事件发布者的定义和实现

```java
/**
 * Interface that encapsulates event publication functionality.
 * Serves as super-interface for ApplicationContext.
 * 该接口封装了事件发布的功能。它作为ApplicationContext的超级接口。
 *
 * 事件发布者接口
 */
public interface ApplicationEventPublisher {
    /**
     * Notify all listeners registered with this application of an application
     * event. Events may be framework events (such as RequestHandledEvent)
     * or application-specific events.
     * 通知注册到该应用程序的所有监听器关于一个应用程序事件。这些事件可以是框架事件（例如RequestHandledEvent）或特定于应用程序的事件。
     * 发布的意思就是把事件通知给所有的事件监听器
     * @param event the event to publish
     */
    void publishEvent(ApplicationEvent event);
}

```

- ApplicationEventPublisher 是整个一个事件的发布接口，所有的事件都需要从这个接口发布出去。

由于注册事件广播器是在Bean创建时，所以下面还需要修改**AbstractApplicationContext**，在创建Bean时加入相关流程
