---
title: spring集成neo4j
date: 2023-06-06
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - Springboot
---

> 参考：
>
> https://spring.io/projects/spring-data-neo4j
>
> https://neo4j.com/
>
> [cyber文档](https://neo4j.com/docs/cypher-manual/current/clauses/)

## 安装配置

首先是运行neo4j

~~~dockerfile
docker run -d -p 7474:7474 -p 7687:7687  \
-v /usr/local/neo4j/data:/data \
-v /usr/local/neo4j/logs:/logs \
-v /usr/local/neo4j/conf:/var/lib/neo4j/conf \
-v /usr/local/neo4j/import:/var/lib/neo4j/import \
--name sbom-neo4j neo4j:latest
~~~

注意

这里把容器内的一些目录挂载到主机，可以方便查看和修改，顺便还命名了neo4j

必须保证主机目录存在，不然启动失败

注意name顺序，**并且镜像要带版本**

`docker run --name <container_name> <image_name>`

**然后可以在neo4j.conf下切换数据库**

![image-20230619213554661](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619213554661.png)

追加配置文件

~~~properties
# The name of the default database
dbms.default_database=test
~~~



maven引入依赖

~~~xml
<dependency>
    <groupId>org.neo4j.driver</groupId>
    <artifactId>neo4j-java-driver-spring-boot-starter</artifactId>
</dependency>
~~~

> 参考https://blog.csdn.net/ccnice99/article/details/123420884，说官方要替代上面这个包，发现好像烂尾了，而spring boot的反而一直还在维护
>
> ~~~xml
> <dependency>
>     <groupId>org.neo4j.driver</groupId>
>     <artifactId>neo4j-java-driver-spring-boot-starter</artifactId>
> </dependency>
> ~~~
>
> 但是neo4j的这个包都停止维护了，因此还是用spring-data-neo4j吧

neo4j自带了movie图谱，因此以该图谱为例，展示spring boot集成neo4j的操作

> [spring-neo4文档](https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/)

## 利用spring-data-neo4j操作neo4j

> https://spring.io/guides/gs/accessing-neo4j-data-rest/
>
> https://spring.io/guides/gs/accessing-data-neo4j/

首先开启neo4jRepository注解，，这里除了配置类开启，也可以在application上加@EnableNeo4jRepositories开启（好像，但不能同时这么干，会冲突）

~~~java
@Configuration
@EnableNeo4jRepositories(basePackages = "com.inet.repository")
@EnableTransactionManagement
public class Neo4jConfig {

    @Value("${spring.neo4j.uri}")
    private String url;

    @Value("${spring.neo4j.authentication.username}")
    private String username;

    @Value("${spring.neo4j.authentication.password}")
    private String password;

    @Bean(name = "session")
    public Session neo4jSession() {
        Driver driver = GraphDatabase.driver(url, AuthTokens.basic(username, password));
        return driver.session();
    }

}
~~~

neo4j提供了节点注解@Node,和关系注解@RelationShip,

分别对应neo4j的节点和关系，那么如何通过程序创建实体和关系呢？

~~~java
@Node("Cloud")
public class Cloud {

    @Id
    private String cloudName;

    @Relationship(type = "hasCategory")
    private List<Category>CategoryList;

    public Cloud(String cloudName) {
        this.cloudName = cloudName;
    }
}

~~~

答案是直接赋值，比如上面的cloud，，先new一个，然后save，就有一个cloud节点了，但是注意，要有边的话，要把边的`List<Category>`复制了才有边。也就是说，只要赋值了再save，neo4j中就会创建相应的边。

@Repository注解,以cloud为例，Neo4jRepository已经封装了基础的CURD操作，因此继承其即可，对于一些其他的操作，可以自定义方法再去实现。其中有一些命名规范，如果符合命名规范不用写查询语句，比如`findByCloudName`。

**注意，对于一个实体类的操作，只能解析返回结果是这个类的语句！（也就是返回类必须是 Neo4jRepository中写的这个）**

> 如果不是，就会导致无法映射，值全部是null，比如下面返回category的方法

~~~java


@Repository
public interface CloudRepository extends Neo4jRepository<Cloud,Long> {

    //符合命名约定的就不用写自定义语句，但一般写了更好
    @Query("MATCH (cloud:Cloud) WHERE cloud.cloudName = $cloudName RETURN cloud")
    //MATCH (cloud:Cloud) WHERE cloud.cloudName = "腾讯云" RETURN cloud
    Cloud findByCloudName(String cloudName);

    @Query("MATCH (cloud:Cloud)-[:hasCategory]->(category:Category) WHERE cloud.cloudName = $cloudName RETURN category")
    //MATCH (cloud:Cloud)-[:hasCategory]->(category:Category) WHERE cloud.cloudName = "腾讯云" RETURN category
    List<Category>findAllCategory(String cloudName);
    //这个方法是错误的，不能正确解析，返回类必须是cloud，因为上面传的就是那个值
}

~~~

> 参考:https://blog.csdn.net/russle/article/details/79940894

## cyber

删除所有数据

~~~cypher
MATCH (n)
DETACH DELETE n
~~~

但是这样会有残留的属性，这里很坑，一定要注意，这会导致之前你就算更改了实体类的属性，但是neo4j中的没有改变

> 有一个bug，我遇到的，返回的结果一直全是null，原因就是因为本地的属性改了，但是neo4j中还残留着原来的属性，导致一直映射失败
>
> 但是后来发现不是这个的原因，而是我没搞清楚repository注解咋用

如何去除Property Keys–**删库**

1. 暂停服务；
2. **/data/databases路径下**，删除 graphName.db 目录【命令为：rm -rf graphName.db】；
3. 重启服务。
