---
title: AOP编程
date: 2023-04-23
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - SSM
---

## AOP

### AOP是什么

AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。

> 类比一下oop，面对对象编程

Spring有两个核心，一个是IOC/DI,另一个是AOP

### AOP作用

- 作用:在不惊动原始设计的基础上为其进行功能增强，前面咱们有技术就可以实现这样的功能即代理模式。

前面咱们有技术就可以实现这样的功能即`代理模式`。

>`代理模式`，即Proxy Pattern，23种java常用设计模式之一。代理模式提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
>
>代理模式的主要作用是为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。

###  AOP核心概念

#### 环境准备

项目结构如

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230423211737339.png" style="zoom:80%">

pom.xml如下

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>aop-demo</artifactId>
    <version>1.0-SNAPSHOT</version>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.10.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.4</version>
        </dependency>
    </dependencies>
</project>
~~~



MyAdvice 写aop的

~~~java
package com.test.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(* com.test.dao.BookDao.*d*(..))")
    private void pt(){}

    @Around("pt()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable{
        System.out.println("------------------");
        Long startTime = System.currentTimeMillis();
        for(int i=0;i<10000;i++){
            pjp.proceed();
        }
        Long endTime = System.currentTimeMillis();
        Long totalTime = endTime - startTime;
        System.out.println("执行万次时间"+totalTime+"ms");
        return null;
    }

}
~~~

SpringConfig代替application的

~~~java
package com.test.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan("com.test")
@EnableAspectJAutoProxy
public class SpringConfig {
}
~~~

APP，调用方法的

~~~java
package com.test;

import com.test.config.SpringConfig;
import com.test.dao.BookDao;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class);
        bookDao.select();
    }
}

~~~

**重点在于BookDaoImpl**

```java
@Repository
public class BookDaoImpl implements BookDao {
    public void save() {
        //记录程序当前执行执行（开始时间）
        Long startTime = System.currentTimeMillis();
        //业务执行万次
        for (int i = 0;i<10000;i++) {
            System.out.println("book dao save ...");
        }
        //记录程序当前执行时间（结束时间）
        Long endTime = System.currentTimeMillis();
        //计算时间差
        Long totalTime = endTime-startTime;
        //输出信息
        System.out.println("执行万次消耗时间：" + totalTime + "ms");
    }
    public void update(){
        System.out.println("book dao update ...");
    }
    public void delete(){
        System.out.println("book dao delete ...");
    }
    public void select(){
        System.out.println("book dao select ...");
    }
}
```

当在App类中从容器中获取bookDao对象后，分别执行其`save`,`delete`,`update`和`select`方法后会有如下的打印结果:

![image-20230423212308173](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230423212308173.png)

#### Q&A

对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?

* 对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?
* delete和update方法有，那什么select方法为什么又没有呢?

这个案例中其实就使用了Spring的AOP，**在不惊动(改动)原有设计(代码)的前提下，想给谁添加功能就给谁添加**。这个也就是Spring的理念：

* **无入侵式/无侵入式**

![image-20230423212830721](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230423212830721.png)

#### 核心概念

##### 连接点

Spring的AOP是对一个类的方法在不进行任何修改的前提下实现增强。对于上面的案例中BookServiceImpl中有`save`,`update`,`delete`和`select`方法,这些方法我们叫**连接点**

##### 切入点

在BookServiceImpl的四个方法中，`update`和`delete`只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能，那也就是说`update`和`delete`方法都已经被增强，所以对于需要增强的方法叫**切入点**

##### 通知

执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是存放共性功能的方法，我们给起了个名字叫**通知**

##### 切面

通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述。**称为切面**

##### 通知类

通知是一个方法，方法不能独立存在需要被写在一个类中，这个类我们叫**通知类**

##### 官方点的定义

* 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等
  * 在SpringAOP中，理解为方法的执行
* 切入点(Pointcut):匹配连接点的式子
  * 在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法
    * 一个具体的方法:如com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法
    * 匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法
  * 连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。
* 通知(Advice):在切入点处执行的操作，也就是共性功能
  * 在SpringAOP中，功能最终以方法的形式呈现
* 通知类：定义通知的类
* 切面(Aspect):描述通知与切入点的对应关系。

#### 入门实现

上面的例子中，主要就是MyAdvice帮助实现了AO。P，这里介绍如何实现。

对于SpringAOP的开发有两种方式，XML 和 注解.

**这里采用注解完成AOP的开发。**

需求为:**使用SpringAOP的注解方式完成在方法执行的前打印出当前系统时间。**

**直接基于上面的项目修改**

BookDao和BookDaoImpl

~~~java
public interface BookDao {
    public void save();
    public void update();
}

@Repository
public class BookDaoImpl implements BookDao {

    public void save() {
        System.out.println(System.currentTimeMillis());
        System.out.println("book dao save ...");
    }

    public void update(){
        System.out.println("book dao update ...");
    }
}
~~~

**说明:**

* 目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间
* 对于update方法来说，就没有该功能
* **我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。**

##### 通知类和通知

**通知就是将共性功能抽取出来后形成的方法**，共性功能指的就是当前系统时间的打印。

通知类这里就是MyAdvice

~~~java
public class MyAdvice {
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
~~~

##### 定义切入点

BookDaoImpl中有两个方法，分别是save和update，我们要增强的是update方法，该如何定义呢?

~~~java
public class MyAdvice {
    @Pointcut("execution(void com.test.dao.BookDao.update())")
    private void pt(){}
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
~~~

* **切入点定义依托一个不具有实际意义的方法进行**，即无参数、无返回值、方法体无实际逻辑。
* execution及后面编写的内容后面介绍

##### 制作切面

**切面是用来描述通知和切入点之间的关系**，如何进行关系的绑定?

~~~java
public class MyAdvice {
    @Pointcut("execution(void com.test.dao.BookDao.update())")
    private void pt(){}
    
    @Before("pt()")
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
~~~

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230423215106095.png" style="zoom:80%">

**说明:**@Before翻译过来是之前，也就是说**通知会在切入点方法执行之前执行**，除此之前还有其他四种类型，后面会讲。

##### 开启注解格式AOP功能

~~~java
@Configuration
@ComponentScan("com.test")
@EnableAspectJAutoProxy
public class SpringConfig {
}
~~~

##### 运行结果

![image-20230423215743766](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230423215743766.png)

### 知识点1：@EnableAspectJAutoProxy  

| 名称 | @EnableAspectJAutoProxy |
| ---- | ----------------------- |
| 类型 | 配置类注解              |
| 位置 | 配置类定义上方          |
| 作用 | 开启注解格式AOP功能     |

### 知识点2：@Aspect

| 名称 | @Aspect               |
| ---- | --------------------- |
| 类型 | 类注解                |
| 位置 | 切面类定义上方        |
| 作用 | 设置当前类为AOP切面类 |

### 知识点3：@Pointcut   

| 名称 | @Pointcut                   |
| ---- | --------------------------- |
| 类型 | 方法注解                    |
| 位置 | 切入点方法定义上方          |
| 作用 | 设置切入点方法              |
| 属性 | value（默认）：切入点表达式 |

### 知识点4：@Before

| 名称 | @Before                                                      |
| ---- | ------------------------------------------------------------ |
| 类型 | 方法注解                                                     |
| 位置 | 通知方法定义上方                                             |
| 作用 | 设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 |

