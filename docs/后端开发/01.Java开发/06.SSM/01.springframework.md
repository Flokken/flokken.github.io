---
title: springframework介绍
date: 2023-04-12 00:00:00
tags: 
  - Java
categories: 
  - 后端开发
  - Java开发
  - SSM
---

## SpringFramework

- **Spring是一款非常优秀而且功能强大的框架。**Spring可以**简化开发**，降低企业级开发的复杂性，使开发变得更简单快捷
- Spring能做什么:用以开发web、微服务以及分布式系统等，这些也是javaEE的主流
- Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。

**两大核心：**

- IOC
- AOP

### 系统架构

spring framework 4架构图

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230412202243972.png" style="zoom:90%">

**(1)核心层**

Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块

**(2)AOP层**

AOP:面向切面编程，它依赖核心层容器，目的是**在不改变原有代码的前提下对其进行功能增强**

Aspects:AOP是思想,Aspects是对AOP思想的具体实现

**(3)数据层**

Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis

Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现.

**(4)Web层**

SpringMVC框架,开发web应用

**(5)Test层**

Spring主要整合了Junit来完成单元测试和集成测试

### 核心概念

#### 问题引入

假设下面一个问题，我有一个接口类bookDao，我用booodaotmp1实现他，并且需要调用其数据层的方法，**现在数据层的实现类变了，业务层代码也要变**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230412202649157.png" style="zoom:90%">

(1)业务层需要调用数据层的方法，**就需要在业务层new数据层的对象**

(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署

(3)所以，现在代码在编写的过程中存在的问题是：**耦合度偏高**

**如果去掉new对象**，好像就可以了。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230412203731144.png" style="zoom:90%">

但这样不能运行，业务层不想new对象，运行的时候又需要这个对象，该咋办呢

**spring解决办法**

使用对象时，在程序中不要主动使用new产生对象，转换为由**外部**提供对象，这就是IOC

#### IOC

 **IOC(Inversion of Control)称为控制反转**

##### 是什么？

使用对象时，由主动new产生对象转换为由**外部**提供对象，**此过程中对象创建控制权由程序转移到外部，此思想称为控制反转**。

**Spring和IOC之间的关系是什么呢?**

- Spring技术对IOC思想进行了实现
- Spring提供了一个容器，称为**IOC**容器，用来充当IOC思想中的"外部"
- IOC思想中的别人[外部]指的就是Spring的IOC容器

**IOC容器的作用以及内部存放的是什么?**

- IOC容器负责对象的创建、初始化等一系列工作，**其中包含了数据层和业务层的类对象**
- **被创建或被管理的对象在IOC容器**中统称为**Bean**
- **IOC容器中放的就是一个个的Bean对象**

**当IOC容器中创建好service和dao对象后，程序能正确执行么?**

- 不行，因为service运行需要依赖dao对象
- IOC容器中虽然有service和dao对象
- **但是service对象和dao对象没有任何关系**
- **需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系**

##### 依赖注入

再看上面的例子，我们发现业务层需要数据层的对象才能正常工作

![image-20230412210121470](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230412210121470.png)

**(1)什么是依赖注入?**

- 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入

  - 业务层要用数据层的类对象，以前是自己new的

  - 现在自己不new了，靠别人[外部其实指的就是IOC容器]来给注入进来

  - 这种思想就是依赖注入

(2)**IOC容器中哪些bean之间要建立依赖关系**？

需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系

##### 好处

Spring的IOC/DI的,这两个概念的最终目标就是:**充分解耦**，具体实现靠:

- 使用IOC容器管理bean（IOC)
- 在IOC容器内将有依赖关系的bean进行关系绑定（DI）
- 最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.



#### Q&A

(1)什么IOC/DI思想?

- IOC:控制反转，控制反转的是对象的创建权
- DI:依赖注入，绑定对象与对象之间的依赖关系

(2)什么是IOC容器?

​	Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器

(3)什么是Bean?

​	容器中所存放的一个个对象就叫Bean或Bean对象

<img src="" style="zoom:70%">

<img src="" style="zoom:70%">

<img src="" style="zoom:70%">

<img src="" style="zoom:70%">
<img src="" style="zoom:70%">

<img src="" style="zoom:70%">

<img src="" style="zoom:70%">

## 入门案例

### 细节Q&A

(1)Spring是使用容器来管理bean对象的，那么管什么? 

* 主要管理项目中所使用到的类对象，比如(Service和Dao)

(2)如何将被管理的对象告知IOC容器?

* **使用配置文件**

(3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?

* Spring框架提供相应的接口

(4)IOC容器得到后，如何从容器中获取bean?

* 调用Spring框架提供对应接口中的方法

(5)使用Spring导入哪些坐标?

* 用别人的东西，就需要在pom.xml添加对应的依赖

### 具体实现

需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。

1.创建Maven的java项目

2.pom.xml添加Spring的依赖jar包

3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类

4.resources下添加spring配置文件，并完成bean的配置

5.使用Spring提供的接口完成IOC容器的创建

6.从容器中获取对象进行方法调用

#### 步骤1:创建Maven项目

![image-20230412211521610](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230412211521610.png)



#### 步骤2:添加Spring的依赖jar包

pom.xml里添加

~~~java
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
        <scope>test</scope>
    </dependency>
</dependencies>
~~~

##### **步骤3:添加案例中需要的类**

创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类

```java
public interface BookDao {
    public void save();
}
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
}
public interface BookService {
    public void save();
}
public class BookServiceImpl implements BookService {
    private BookDao bookDao = new BookDaoImpl();
    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

##### 步骤4:添加spring配置文件

resources下**添加spring配置文件**applicationContext.xml，并完成bean的配置

> 注意先添加spring的依赖，new xml 才有spring config的选项

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
 
    <!--bean标签标示配置bean
    	id属性标示给bean起名字
    	class属性表示给bean定义类型
	-->
	<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl"/>

</beans>
~~~

**注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复**

##### 步骤6:获取IOC容器

使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法

```java
public class App {
    public static void main(String[] args) {
        //获取IOC容器
		ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); 
    }
}
```

##### 步骤7:从容器中获取对象进行方法调用

```java
public class App {
    public static void main(String[] args) {
        //获取IOC容器
		ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); 
//        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
//        bookDao.save();
        BookService bookService = (BookService) ctx.getBean("bookService");
        bookService.save();
    }
}
```

##### 步骤8:运行程序

测试结果为：

Spring的IOC入门案例已经完成，但是在`BookServiceImpl`的类中依然存在`BookDaoImpl`对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的`DI:依赖注入`。

完整的项目目录如图，注意要达到这个效果，**要先创包，再去一个个添加子包和类**

![image-20230412221532912](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230412221532912.png)