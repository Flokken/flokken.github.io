---
title: 类文件结构
date: 2023-07-20
categories: 
  - 后端开发
  - 深入理解JVM
---

## 概述

机器码：机器码是一种由计算机直接执行的低级指令。它是二进制代码的形式，每条指令都对应着CPU中的一组硬件操作。计算机程序最终被转换为机器码，然后由计算机的中央处理器（CPU）逐条执行这些指令，实现对计算机硬件的底层控制和操作。

问题：**不同的CPU架构有不同的机器码指令集，因此同一程序的机器码在不同的CPU上可能是不兼容的。**

> 比如x86,amd架构的机器码就不兼容
>
> **本地机器码**（Native Code）就是与本机系统关联的机器码

### 无关性

java诞生时有一个非常著名的口号：“Write Once ，RunAnyWhere"。这正是得益于虚拟机和字节码。

平台无关性:各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code） ,**这是平台无关性的基石。**

语言无关性：**实现语言无关性的基础是虚拟机和字节码存储格式。**

**Java虚拟机不与包括Java语言在内的任何 程序语言绑定，，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机 指令集、符号表以及若干其他辅助信息。**

> 正因为如此，才会可以把java规范分成《Java语言规范》（The Java Language Specification）及《Java虚拟机规范》 （The Java Virtual Machine Specification）两部分
>
> 时至今日，**商业企业和开源机构已经在Java语言之外发展出一大批运行在Java虚拟机之上的语言， 如Kotlin、Clojure、Groovy、JRuby、JPython、Scala等。**

《Java虚拟机规范》中要求在Class文 件必须应用许多强制性的语法和结构化约束，**但图灵完备的字节码格式，保证了任意一门功能性语言 都可以表示为一个能被Java虚拟机所接受的有效的Class文件。**

> java等语言的各种命令与操作，可以通过字节码的组合来实现，感觉与汇编指令集有点像？
>
> 区别：
>
> - 字节码是高级语言编译后生成的**面向虚拟机或解释器的中间代码，具有跨平台性，不面向特定硬件；（划重点，是一种编译后的中间代码，跨平台）**
> - 而汇编指令集是与特定硬件体系结构相关的低级机器指令，**不具有跨平台性**，**直接面向计算机的硬件执行**。

语言无关性图示

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721172049264.png" style="zoom:80%">

## .class文件结构

**.Class文件是一组以8位字节为基础单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

按照Java虚拟机规范，**Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种结构中只有两种数据类型：无符号数和表。**

- **无符号数**属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值、或者按照UTF-8编码构成字符串值。
- **表**是由多个无符号数或其他表作为数据项构成的复合数据类型，所有的表都习惯性地以`"_info"`结尾。表用于描述有层次关系的复合数据结构的数据，整个Class文件本质上就是一张表，它由如下所示的数据项构成：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721173856500.png" style="zoom:80%">

<center> class文件格式</center>

>无论是无符号数还是表，当需要描述同一类型单数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据位某一类型的集合。

### 举例

我们可以通过hello word来认知，一个类到底是什么

首先我们编写一个`Hello world.java`,这是我们的源代码文件

~~~java
package cn.itcast.jvm.t5;
 // HelloWorld 示例
public class HelloWorld {
 	public static void main(String[] args) {
 		System.out.println("hello world");
	 }
 }
~~~

然后我们用javac编译器，把他编译成**字节码文件**，`javac -parameters -d . HellowWorld.java`,

也就是`Hello World.class`

~~~shell
root@localhost ~]# od -t xC HelloWorld.class 
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07
0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29
0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e
0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63
0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01
0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63
0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f
0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16
0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72
0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13
0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69
0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61
0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46
0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64
0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e
0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64
0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74
0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c
0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61
0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61
0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f
0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72
0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76
0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d
0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a
0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b
0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01
0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01
0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00
0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00
0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00
0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00
0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a
0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b
0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00
0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00
0001120 00 00 02 00 14
~~~

根据 JVM 规范，类文件结构如下

~~~css
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
~~~



### 魔数与Class文件的版本

每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用时用语确定这个文件是否作为一个能被虚拟机接受的Class文件。Class文件的魔数值是`0xCAFEBABE`（咖啡宝贝？）。

紧挨着魔数的4个字节存储的是Class文件的版本号;

第5和6个字节是次版本号（Minor Version），**第7和8个字节是主版本号**（Major Version）。 

Java的版本号是从45开始的，以后每个大版本发布后，主版本号向上加1，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生变化。

### 常量池

从第 9 个字节开始，就是常量池的入口，常量池是 Class 文件中：

- 与其他项目关联最多的的数据类型；
- 占用 Class 文件空间最大的数据项目；
- Class 文件中第一个出现的表类型数据项目。

**常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。**

- 字面量比较接近Java语言的常量概念，如文本字符串、被声明为final的常量值等。

- 符号引用则属于编译原理方面的概念，包括了下面三类常量：

  - 类和接口的全限定名（Fully Quaified Name）

  - 字段的名称和描述

  - 方法的名称和描述符

**常量池中每一项常量都是一个表**，最初常量表中共有11种结构各不相同的表结构数据，后来为了 更好地支持动态语言调用，额外增加了4种动态语言相关的常量，为了支持Java模块化系统 （Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，**所以截至JDK 13，常量表中分别有17种不同类型的常量**

> 现在都有20了，肯定更多
>
> 为这17种常量类型各自有着完全独立的数据结构，两两之 间并没有什么共性和联系，因此只能逐项进行讲解，感觉知道有这个东西就行

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721205024896.png" style="zoom:70%">



### **访问标志**

**访问标志（access_flag）**：用于识别一些类或接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否定义为abstract类型，如果是类的话，是否被声明为final，等等。

### **类索引、父类索引、接口索引集合**

类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合是一个u2类型的数据集合，**class文件由这三个数据来确定这个类的继承关系。**

- 类索引用于确定这个类的全限定名，
- 父类索引用于确定这个类的父类的全限定名
  - 所有的类都要父类，除了java.lang.Object类
- 接口索引集合用来描述这个类实现了那些接口，**这些被实现的接口按implement后的接口顺序从左到右排列在接口索引集合中**
  - 如果这个class表示的是一个接口，则是extend关键字
  - 接口索引集合的第一u2数据是接口计数器

>类的全限定名（Fully Qualified Name）是指一个类在Java中的唯一标识符，包含了类的包名和类名。全限定名的格式为：
>`<包名>/<类名>`
>
>比如`com/example/utils/StringUtils `,其实就是把类的全名中的'.'换成'/'

###  **字段表集合**

**字段表（field_info）**：**用于描述类或者接口的声明的变量，不包括方法的内部声明变量。**

字段表结构如下：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721205354480.png" style="zoom:80%">



access_flag中存放的是字段修饰符，表示变量的修饰符。

> 比如这个变量是private还是public啥的等等

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721212552011.png" style="zoom:70%">

name_index  ：简单名称，description_index字段和方法的描述符。这两者都是 常量池的引用。

还有属性表。

### **方法表集合**

方法表的结构如同字段表一样，一次包括了，访问标识（access_flag）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）。

> 这些的确可以定义一个方法，但是方法里的代码呢？
>
> 答案是这些代码被编译成字节码指令之后，被存放到一个名为"code"的属性里

为什么重载一个方法不能仅仅靠返回值区分？

**在Java语言(代码)中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求 必须拥有一个与原方法不同的特征签名**

特征签名是指一个方法中各个参数在常量池中的字段符号 引用的集合。

正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值 的不同来对一个已有方法进行重载的。

> 但是在Class文件格式之中，特征签名的范围明显要更大一些， 只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签 名，但返回值不同，那么也是可以合法共存于同一个Class文件中的

### **属性表集合**

> 上面的字段表，方法表都可以带一个尾巴：属性表

**属性表集合（attribute_info）**：用于描述某些场景（Class文件、字段表、方法表）的专有信息。

####  **！！！Code属性**

Java程序方法体里面的代码经过javac编译器处理之后，**最终会变成字节码指令存储在Code属性内，code属性是class文件最重要的属性之一**。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721213953897.png" style="zoom:80%">

> 并非所有方法都有code属性，注意接口和抽象类就没有code属性

这里介绍几个比较重要的字段：

**max_stack代表了操作数栈（Operand Stack）深度的最大值**。在方法执行的任意时刻，操作数栈都 不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。

**max_locals代表了局部变量表所需的存储空间。**在这里，max_locals的单位是变量槽（Slot），变量 槽是虚拟机为局部变量分配内存所使用的最小单位。

> 这两个就是保证栈帧有确切深度和空间大小的字段

**code_length和code用来存储Java源程序编译后生成的字节码指令**。code_length代表字节码长度， code是用于存储字节码指令的一系列字节流

！！！一种概念：

如果把一个Java程序中的信息分为**代码（Code，方法 体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，**那么在整 个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据

####  **Exceptions属性**

列举出方法体中可能抛出的受查异常（checked exception），也就是方法描述时在throws关键字后面的异常。

#### **LineNumberTable属性**

用于描述Java字节码行号与源代码行号之间的对应关系（字节码的偏移量）。

#### **LocalVariableTable属性**

用于描述栈帧中局部变量表中的变量和Java源代码中定义的变量之间的关系。

#### **SourceFile属性**

用于记录生成这个Class文件的源码文件的名称。

#### **ConstantValue属性**

通知虚拟机自动为静态变量赋值。

#### **InnerClasses属性**

用于记录内部类与宿主之间的关联。

#### **Deprecated和Synthetic属性**

Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定位废弃不推荐使用，可以在代码中通过 `@deprecated` 注释来设置。

Synthetic属性代表字段或方法并不是由Java源代码直接产生的，而是由编译器自行添加的。

#### 模块化相关属性

JDK9的一个重量级功能，java的模块化功能，因为模块描述文件最终要编译成一个独立的class，因此也新增了三个属性支持这个功能

#### 运行时注解相关属性

有好几个属性用来支持注解功能，下面是一个代表

RuntimeVisibleAnnotations是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注 解，当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。

.....随着jdk的版本更新，后面也有一些 新属性

### 字节码指令

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成

> 类比汇编的很多寄存器指令
>
> 由Java虚拟机采用 面向操作数栈而不是面向寄存器的架构，**所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。**

字节码指令集算是一种具有鲜明特点、优势和劣势均很突出的指令集架构：

缺点：

- 由于限制了Java虚 拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条；

- Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构

优点：

- 放弃了操作数长度对齐，就意味着可以省略掉大量的填充和间隔符号；

- 用一个字节来代表操作码， 也是为了尽可能获得短小精干的编译代码

**好处就是尽可能小数据量、高传输效率的设计**

#### 字节码和数据类型

**在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。**

举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据

这两 条指令的操作在虚拟机内部可能会是由同一段代码来实现的，**但在Class文件中它们必须拥有各自独立 的操作码**

注意：

- Java虚拟机的操作码长度只有一字节，**所以，Java虚拟机的指令集对于特定的操作 只提供了有限的数据类型相关指令去支持它**
  - 对一个操作，如果是所有类型都支持256显然不够用

例如：（最左边是操作，右边是其支持的操作类型）

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721221535705.png" style="zoom:80%">

> 总结一下，就是操作码要带上数据类型，但是由于操作码数量上限限制，因此对于一种操作，只支持特定几种数据类型

#### 加载和存储指令

**加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之 间来回传输**

比如

- 将一个局部变量加载到操作栈：iload、iload
- 将一个数值从操作数栈存储到局部变量表：istore、istore
- 将一个常量加载到操作数栈：bipush、sipush

#### 运算指令

**算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶**

大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令

例如：

加法指令：iadd、ladd、fadd、dadd  

减法指令：isub、lsub、fsub、dsub 

乘法指令：imul、lmul、fmul、dmul

....................

#### 类型转换指令

**类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显 式类型转换操作**

或者用来处理字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题

Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：

- int类型到long、float或者double类型 
- long类型到float、double类型 
- float类型到double类型

........

#### 对象创建和访问指令

**虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令**。对象创建后，就可以通过对象访问指 令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230721222255099.png" style="zoom:80%">

#### 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指 令，包括： ·将操作数栈的栈顶一个或两个元素出栈：pop、pop2等等

#### 控制转移指令 

控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序，**从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存 器的值。控制转移指令比如**

条件分支：ifeq,   ifle等等............

#### 方法调用和返回指令

#### 异常处理指令

在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛 出异常的情况之外，还有很多其他异常情况

> 例如整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出 ArithmeticException异常。

#### 同步指令

**Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的**

>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中

### 公有设计，私有实现

《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：**Class文件格式以及字节码指令集**。

**这些内容与硬件、操作系统和具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿 意把它们看作程序在各种Java平台实现之间互相安全地交互的手段**

>理解公有设计与私有实现之间的分界线是非常有必要的，**任何一款Java虚拟机实现都必须能够读 取Class文件并精确实现包含在其中的Java虚拟机代码的语义**

