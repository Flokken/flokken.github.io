---
title: 虚拟机类加载机制
date: 2023-07-22
categories: 
  - 后端开发
  - 深入理解JVM
---

##  虚拟机类加载

虚拟机把**描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型**，这就是**虚拟机的类的加载机制**。

### 类加载时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，**它的整个生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称 为连接（Linking）**。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230722110513469.png" style="zoom:70%">

其中，**加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按 照这种顺序按部就班地开始**。

**而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）**

> 注意，这里是 按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，**强调这点是因为这些阶段通常都 是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段**

**虚拟机规范没有规定必须什么时候进行加载，但规定了什么时候必须初始化**

> **既然初始化了，那么前面的加载、验证、准备也就要在之前开始**

**有且只有**以下6种情况下必须**立即对类进行“初始化”**：

- 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时**，如果类没有初始化，则需要先出发其初始化。生成这4条指令的典型场景是：使用 `new` 关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法的时候**
- 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候
- **当初始化一个类时，如果发现它的父类还没有进行初始化，则需要先触发其父类进行初始化**
- **当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化这个类**
- 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
- 当一个接口中定义了JDK 8新加入的默认方法（**被default关键字修饰的接口方法）**时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

> **感觉其中new创建对象,反射调用，父类没初始化的初始化，主类（包含main），default修饰的类，需要立即初始化，比较重要**

> 也就是说，**类必须加载的时机其实是由于必须对类进行初始化了，然后之前就要有加载、验证、准备；因为这些在初始化之前开始**

！！！**还有一个重要的概念，上面六种场景的行为称为对一个类型进行主动引用，除此之外，其他所有引用方式都不会触发初始化，称为被动引用**

### 类加载过程

类加载的全过程即加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）

#### 加载

加载是整个“类加载”中的一个阶段，在此阶段，虚拟机任务如下：

- 通过一个类的全限定名来获取定义此类的二进制字节流。
  - 其实这个定义很灵活，**并没有指明二 进制字节流必须得从某个Class文件中获取**下面是一些实际应用，（也就是二进制字节流怎么生成的）
  - 运行时计算生成，**这种场景使用得最多的就是动态代理技术**，在java.lang.reflect.Proxy中，就是用 了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“$Proxy”的代理类的二进制字节流。
  - **由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。**
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口

这里对于数组类型和非数组类型的加载过程也有区别：

- 非数组类型：**开发人员可控性最强，加载阶段既可以使用Java虚拟机里内置的引导类加 载器来完成，也可以由用户自定义的类加载器去完成**。开发人员通过定义自己的类加载器去控制字节 流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用 程序获取运行代码的动态性
- 数组类型：数组类本身不通过类加载器创建，它是由Java虚拟机直接在 内存中动态构造出来的**，但是数组里面的元素类（就是item所属类）最终还是要靠类加载器来完成**

#### 验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

>比如使用纯粹的Java代码 无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码 行之类的事情，如果尝试这样去做了，编译器会毫不留情地抛出异常、拒绝编译。

从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证

- 文件格式验证：是否符合 Class 文件格式规范
  - 比如：验证文件开头 4 个字节是不是 “魔数” `0xCAFEBABE`
  - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。...
  - 目的是验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
- 元数据验证：保证字节码描述信息符号 Java 规范（语义分析）
  -  比如所有的类都应该有父类（除了object）
  - 如果父类是抽象类/接口，是否实现了其所有方法
  - 父类是不是继承了不能被继承的类（final修饰的类）
  - ..等等
  - 目的是保证不存在与《Java语言规范》定义相 悖的元数据信息
- 字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）
  - 上一阶段校验了元数据的数据类型，这阶段就要对类的方法体（code属性）进行校验分析
  - 目的是保证被校验类的方法在运行时不会做出危害 虚拟机安全的行为
- 符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验
  - **校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生**。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源
  - 比如：符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问；
  - 比如：符号引用中通过字符串描述的全限定名是否能找到对应的类。
  - 目的是确保程序能执行

#### 准备

**准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初 始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法**区中进行分配.

> 注意到方法区 本身是一个逻辑上的区域
>
> 在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这 种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，使用元数据来实现方法区

#### 解析

**解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程**

- 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。
  - 比如CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量

- 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。

**解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用分别进行**

> 这四种解析过程当然不一样，这里没做记录

#### 初始化

类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶 段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。

**直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程 序。**

>**进行准备阶段时，变量已经赋过一次系统要求的初始零值，**而在初始化阶段，则会根据程序员通 过程序编码制定的主观计划去初始化类变量和其他资源

**书里从另外一种更直接的形式来表 达：初始化阶段就是执行类构造器(clinit)方法的过程。**(clinit)并不是程序员在Java代码中直接编写 的方法，它是Javac编译器的自动生成物.

- **(clinit)**方法是**由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的**，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
- (clinit)方法与类的构造函数（即在虚拟机视角中的实例构造器()方法）不同**，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的(clinit)方法执行前，父类的(clinit)方法已经执行 完毕**。因此在Java虚拟机中第一个被执行的()方法的类型肯定是java.lang.Object。
- 由于父类的(clinit)方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值 操作。
- (clinit)方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的 赋值操作，那么编译器可以不为这个类生成()方法

### 类加载器

上面时java类的加载过程，而java通过类加载器完成上面的加载过程。

Java虚拟机设计团队有意把类加载阶段中的“**通过一个类的全限定名来获取描述该类的二进制字节 流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动 作的代码被称为“类加载器”（Class Loader）。**

> 就是加载阶段的那个规范，让一个类通过类的全限定名获取该类的二进制字节流这个过程，不需要必须从class文件中获取

**对于 任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每 一个类加载器，都拥有一个独立的类名称空间。**

更通俗的讲，比较两个类是否来源于同一个类：**只有在这两个类是由同一个类加载器加载的前提下才有意义**，否则，**即使这两个类来源于同一个 Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等**

>这里所指的“相等”，包**括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance() 方法的返回结果**，也包括了使用instanceof关键字做对象所属关系判定等各种情况。

> 总结一下，当且仅当两个类被同一个类加载器加载，才被认为这两个类是同一类的

#### 双亲委派模型

站在Java虚拟机的角度来看，只存在两种不同的类加载器：

- 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；
- 另外一种就是其他所有 的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。

当然，实际上，从开发人员的角度看，会划分的更细，实际上类加载器有三层（以jdk8为基础来介绍）。

- 启动类加载器（Bootstrap Class Loader）：**这个类加载器负责加载存放在 <JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的**，而且是Java虚拟机能够 识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类 库加载到虚拟机的内存中
  - 启动类加载器无法被Java程序直接引用
- 扩展类加载器（Extension Class Loader）:**这个类加载器是在类sun.misc.Launcher$ExtClassLoader 中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所 指定的路径中所有的类库**
  - 由于扩展类加载器是由Java代码实现 的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。
- 应用程序类加载器（Application Class Loader）：这个类加载器由 sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。**它负责加载用户类路径 （ClassPath）上所有的类库**
  - **开发者同样可以直接在代码中使用这个类加载器**
  - **如果应用程序中没有 自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。**

![image-20230722222133054](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230722222133054.png)

<center> 双亲委派模型</center>

上图展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）。

**双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器**。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用 组合（Composition）关系来复用父加载器的代码。

双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加 载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，**因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请 求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

> 这个名字比较难懂，理解如下：
>
> 1. 双亲（Parent）：在Java中，类加载器之间形成了一个层级关系，其中顶层的类加载器被称为"根类加载器"（Bootstrap Class Loader），它是由JVM实现并不是Java类。在**其下面，还有两个非常重要的类加载器：扩展类加载器（Extension Class Loader）和应用程序类加载器（Application Class Loader）。这些类加载器构成了双亲的层级结构**。
> 2. 委派（Delegation）：当一个类加载器加载类时，它首先不会尝试自己去加载，而是将这个任务委派给父类加载器去完成。每一级的类加载器都是如此，只有当父加载器无法加载时，子加载器才会尝试加载。**这种层级关系形成了一种委派机制，称为"双亲委派"。**

#### Java模块化系统

> JDK9引入，**为了能够实现模块化的关键目标——可配置的封装隔离机制**

JDK 9的模块不仅仅像之前的JAR包那样只是 简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容： 

- 依赖其他模块的列表。 
- 导出的包列表，即其他模块可以使用的列表。 
- 开放的包列表，即其他模块可反射访问模块的列表。 
- 使用的服务列表。 
- 提供服务的实现列表。

**可配置的封装隔离机制首先要解决JDK 9之前基于类路径（ClassPath）来查找依赖的可靠性问 题。**

> 此前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接 时才会报出运行的异常。而在JDK 9以后，如果启用了模块化进行封装，模块就可以声明对其他模块 的显式依赖，这样Java虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否 完备，如有缺失那就直接启动失败，从而避免了很大一部分由于类型依赖而引发的运行时异常。

