---
title: 后端编译优化
date: 2023-07-24
categories: 
  - 后端开发
  - 深入理解JVM
---

### 概述

如果我们把字节码看作程序语言的一种中间表示形式（Intermediate Representation，IR）的话（把javac干的事，也就是java代码转成字节码，可以称为**前端**）

那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相 关的二进制机器码，它都可以视为**整个编译过程的后端**

### 热点代码

主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过**解释器 （Interpreter）**进行解释执行的

当虚拟机发现某个方法或代码块的运行特别频繁，**就会把这些代码认 定为“热点代码”（Hot Spot Code）**，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，**运行时完成这个任务的后端编译器被称为即时编译器**

> 总结，即时编译器：把热点代码在运行时编译成本地机器码来提高热点代码的执行效率的

热点代码主要是

- 被多次调用的方法
- 被多次执行的循环体

### 解释器与编译器

如HotSpot、OpenJ9等，**内部都同时包含解释器与编译器。**

当程序需要迅速启动和执行的时候，**解释器可以首先发挥作用，省去编译的时间，立即运行。**

当程序启动后，随着时间的推移，**编译器逐渐发挥作用，把越来越多的代码编译成本地代码**，这样可以减少解释器的中间损耗，获得更高的执行效率。

Hotspot虚拟机即时编译器

- C1编译器，C2编译器，Graal编译器（JDK10出现）

### 编译对象和触发条件

**热点探测：**就是探测那些代码时热点代码的过程

方法：

- 基于采样的热点探测：采用这种方法的虚拟机会周期性 地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方 法”
  - 优：实现简单高效，还可以很容易地获取方法调用关系
  - 缺：是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测。
- 基于计数器的热点探测：采用这种方法的虚拟机会为 每个方法（甚至是代码块）建立计数器，**统计方法的执行次数，如果执行次数超过一定的阈值就认为 它是“热点方法”**
  - 优点是精确一点，缺点是实现麻烦

>Hotspot用的基于计数器的方法，为了实现热点计数，HotSpot为每个方法准备了 两类计数器：**方法调用计数器（Invocation Counter）和回边计数器**（Back Edge Count

### 提前编译

提前编译可能会影响java的某些特性，但是也可以获得性能上的提升？

提前编译有两条路径：

- 一条分支是做与传统C、C++编译器类似 的，在程序运行之前把程序代码编译成机器码的静态翻译工作；
- 另外一条分支是把原本即时编译器在 运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器 其他Java进程使用）时直接把它加载进来使用。

### 方法内联

**是编译器最重要的优化手段**

方法内联的优化行为理解起来是没有任何困难的，**不过就是把目标方法的代码原封不动地“复 制”到发起调用的方法之中，避免发生真实的方法调用而已。**

但是方法内联实施起来很有难度：**Java语言中默认的实例方法是虚方法，**对于一个虚方法，**编译器静态地去做内联的时候很难确定应该使用哪个方法版本**

> 只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会 在编译期进行解析
>
> 也就是说其他方法编译时都不能确定方法，都是多态的，

举例：

假 如有ParentB和SubB是两个具有继承关系的父子类型，并且子类重写了父类的get()方法，那么b.get()是 执行父类的get()方法还是子类的get()方法，**这应该是根据实际类型动态分派的，而实际类型必须在实 际运行到这一行代码时才能确定，编译器很难在编译时得出绝对准确的结论。**

>内联与 虚方法之间会产生“矛盾”，那是不是为了提高执行性能，就应该默认给每个方法都使用final关键字去 修饰呢？C和C++语言的确是这样做的，默认的方法是非虚方法，如果需要用到多态，就用virtual关键 字来修饰，但Java选择了在虚拟机中解决这个问题。

为了解决虚方法的内联问题，Java虚拟机首先引入了一种名**为类型继承关系分析（Class Hierarchy Analysis，CHA）的技术**.，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类 中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法 等信息。

### 逃逸分析

逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一 样，并不是直接优化代码的手段，**而是为其他优化措施提供依据的分析技术**

**逃逸分析的基本原理是**：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部 方法所引用，例如作为调用参数传递到其他方法中，**这种称为方法逃逸；**

- 甚至还有可能被外部线程访 问到，**譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；**

- 从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度

如果能**证明一个对象不会逃逸到方法或线程之外**（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者**逃逸程度比较低**（只逃逸出方法而不会逃逸出线程），就能对他进行一些优化

- 栈上分配
- 标量替换
- 同步消除

### 公共子表达式消除

公共子表达式：如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。

对于这种表达式，没有必要花时间再对它重新进行计算，**只需要直 接用前面计算过的表达式结果代替E**。

- 局部：如果这种优化仅限于程序基本块内，便可称为局部公共子表达 式消除（Local Common Subexpression Elimination）
- 全局：如果这种优化的范围涵盖了多个基本块，那就称 为全局公共子表达式消除（Global Common Subexpression Elimination）。

### 数组边界检查消除

数组边界检查消除（Array Bounds Checking Elimination）是**即时编译器中的一项语言相关的经典优 化技术**

Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样实质上就是 裸指针操作。**如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界 的范围检查，**

但是，频繁的并且可能不必要的检查也会带来开销。

举例

- 数组下标是一个常量，如foo[3]，只要 在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了。
-  更加常见的情况是，数组访问发生在循环之中，并且使用循环变量来进行数组的访问。如果编译器只 要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，**那么在循环中就可 以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。**
