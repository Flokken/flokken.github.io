---
title: Java运行时内存区域
date: 2023-07-13
categories: 
  - 后端开发
  - 深入理解JVM
---

> 除了《深入理解JVM虚拟机》，本系列笔记还参考了
>
> https://github.com/TangBean/understanding-the-jvm/blob/master
>
> https://github.com/maokuntao/understandingJVM

### 程序计数器

> Program Counter Register

一块较小的内存区域，是线程私有的内存

作用：

看做当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来确定下一条要执行的字节码指令的位置，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。在任一时刻，一个处理器（对于多核处理器来说，就是一个内核）只会执行一条线程中的指令。**因此，为了能够恢复线程切换之前的线程状态到正确位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响，独立存储，我们称这类内存区域为“线程私有”的内存**。

- 线程执行 Java 方法和 native 方法时的区别：
  - 执行 Java 方法时：记录虚拟机正在执行的字节码指令地址；
  - 执行 native 方法时：无定义；
- 是 5 个区域中唯一不会出现 OOM （OutOfMemoryError）的区域。

> 也就是说每个线程都有自己独立的程序计数器

### 虚拟机栈

**Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的**，它的生命周期与线程相同。**它描述的是Java方法执行的内存模型**：每个方法执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量、操作栈、动态链接、方法出口等信息。

**每一个方法被调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈中从入栈到出栈的过程。**

有人把Java内存区分为栈（Stack）和堆（Heap），这是比较粗糙的。实际上，**这里的“栈”指的就是现在的这个虚拟机栈，或者确切点说，是虚拟机栈中的局部变量表部分。局部变量表中存放了编译期可知的基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（refrence类型，可能是一个对象起始地址的应用指针、也可能是一个代表对象的句柄或者其它与此对象相关的地址）和returnAddress（指向了一条字节码指令的地址）。

> 从这里也可以看出栈和堆是比较关键的内存区域

- 64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型会占用一个

- **局部变量所占用的空间在编译期间完成分配**，当进入一个方法时，这个方法在帧中所需要分配的局部变量的空间时完全可以确定的，**在运行期间也不会改变这个空间的大小。**

- 如果线程请求的栈的深度大于虚拟机所能允许的深度，**会触发StackOverflowError异常**；如果虚拟机可以动态地扩展（当前大部分虚拟机都可以扩展，也可以指定固定长度），当扩展无法申请到足够的内存时，**会抛出OutOfMemoryError异**常

补充：本地方法栈

**本地方法栈（Native Method Stack）**与虚拟机栈的作用非常相似，只不过虚拟机栈是为虚拟机执行字节码（Java方法）服务，而本地方法栈是用来服务于虚拟机使用的Native方法服务。
具体的虚拟机可以自由实现它，甚至可以把它和虚拟机栈合二为一（譬如Sun HotSpot 虚拟机）。
与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryErroe异常。

> 虚拟机栈是方法执行的地方，线程私有

### Java堆

**Java堆（Java Heap）**是Java虚拟机所管理的内存中最大的一块。**是被所有的线程共享的一块内存区域**，在虚拟机启动时创建。

**此内存区域的唯一目的就是存放对象实例，**几乎所有的对象实例都在此分配内存。由于JIT编译器的发展与逃逸分析技术的发展，栈上分配、标量替换优化技术的进步，所有的对象实例都分配在堆上也不是那么绝对了。

Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”（Garbage Collection Heap）。**现在的收集器都是采用分代收集算法，所以Java堆中可以细分为：新生代和老生代。**

根据Java虚拟机规范，Java堆可以是处于物理上不连续的内存空间中，只要逻辑上连续即可。在实现上可以是固定大小，也可以是可扩展的，**主流的是可扩展方式。**

> 堆用来存放对象实例的，线程共享

### 方法区

**方法区（Method Area）**与Java堆一样，都是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。**

Java虚拟机规范对这个区域的限制非常松，除了和Java堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。

当方法区的内存大小无法满足内存分配需要的时候，将抛出OutOfMemory异常。

> 注意区别于堆，方法区别名非堆

#### 补充：

方法区只是一个定义，在早期的Java虚拟机实现中，方法区被实现为永久代（Permanent Generation），这是一个位于Java堆之外的内存区域。在永久代中，存放的是静态的、常驻的类信息和方法数据，这些信息很少发生变化。（现在被实现为元空间）

而"元空间"是Java虚拟机在Java 8版本中引入的一个新的实现，用于替代永久代。**元空间也用于存储类的元数据信息**，但它有一些重要的区别：

1. 实现位置：方法区通常是位于Java堆之外的一块连续内存区域（例如永久代），**而元空间使用的是本地内存（Native Memory）**，即位于操作系统的堆之外。
2. 自动内存管理：方法区中的元数据和常量池等数据由Java虚拟机进行自动的内存管理（垃圾回收），**而元空间中的元数据和常量池等数据不受Java虚拟机的自动内存管理控制。**
3. 垃圾回收：方法区可以进行垃圾回收，但永久代的垃圾回收通常是比较少见的。而元空间不进行垃圾回收，其管理方式转移到了Java虚拟机以外，**通常由操作系统来管理。**
4. 大小调整：方法区的大小可以通过Java虚拟机参数来调整，**而元空间的大小受限于系统可用的本地内存大小。**

总结，jdk8以前，方法区实现为永久代，但是性能不好，jdk8以后，用元空间来实现方法区，并且有很多区别。

#### 运行时常量池

**运行时常量池（Runtime Constant Pool）**是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息，**还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。**

> 运行时常量池相对于Class文件常量池的另外一个重要特征是**具备动态性**，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将将新的常量放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。
>
> 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时将会抛出OutOfMemoryError异常。

###  直接内存

**直接内存（Direct Memory）**并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且有可能导致OutOfMemoryError异常。

在JDK1.4种新加入了NIO（New Iuput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的**DirectByteBuffer对象作为这块内存的引用进行操作**。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

显然，本机直接内存非分配不会受到Java堆大小的限制，但是既然是内存，肯定会受到本机总内存的大小和处理器寻址空间的限制。所以也可能会抛出OutOfMemoryError异常。

> 感觉了解就行

### HotSpot 虚拟机堆中的对象

为了对内存区域有更直观感受，这里讲了 JVM 对 Java 堆中的对象的创建、布局和访问的全过程。

比如：

`Object obj = new Object();`

> 这里补充一下，那"Object obj"**这部分的语义将会反映到Java栈的本地变量中**，作为一个Reference类型数据出现。
>
> 而"new Object()"**这部分的语义将会反映到Java堆中**，形成一块儿存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块儿内存的大小是不固定的。
>
> 另外，在Java堆中，**还必须包含能包括能查到此对象类型数据（如，对象类型、父类、实现的接口、方法等）的地址信息，这些数据存储在方法区（JDK8之后是元数据区）中**。

#### 对象的创建（遇到一条 new 指令时）

1. 检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先把这个类加载进内存；
2. 类加载检查通过后，虚拟机将为新对象分配内存，此时已经可以确定存储这个对象所需的内存大小；
3. 在堆中为新对象分配可用内存；
4. 将分配到的内存初始化；
5. 设置对象头中的数据；
6. 此时，从虚拟机的角度看，对象已经创建好了，**但从 Java 程序的角度看，对象创建才刚刚开始，构造函数还没有执行。**

**第 3 步，在堆中为新对象分配可用内存时，会涉及到以下两个问题：**

**如何在堆中为新对象划分可用的内存？**

- 指针碰撞（内存分配规整）
  - 用过的内存放一边，没用过的内存放一边，中间用一个指针分隔；
  - 分配内存的过程就是将指针向没用过的内存那边移动所需的长度；
- 空闲列表（内存分配不规整）
  - 维护一个列表，记录哪些内存块是可用的；                                                                                                                 
  - 分配内存时，从列表上选取一块足够大的空间分给对象，并更新列表上的记录；

> 内存是否规整由java堆所采用得垃圾收集器是否带有空间压缩整理能力决定

**如何处理多线程创建对象时，划分内存的指针的同步问题？**

> 比如A正在分配内存，指针还没转过去，但是b又使用这个指针分配内存，就会有并发安全问题

- 对分配内存空间的动作进行同步处理（CAS）；
- 把内存分配动作按照线程划分在不同 的空间之中进行；
  - 每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）；
  - 哪个线程要分配内存就在哪个线程的 TLAB 上分配，TLAB 用完需要分配新的 TLAB 时，才需要同步锁定；
  - 通过 `-XX:+/-UseTLAB` 参数设定是否使用 TLAB。

#### 对象的内存布局

- 对象头：
  - 第一部分：存储对象自身运行时的数据，HashCode、GC分代年龄等（Mark Word）；
  - 第二部分：类型指针，指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例（HotSpot 采用的是直接指针的方式访问对象的）；
  - 如果是个数组对象，对象头中还有一块用于记录数组长度的数据。
- 实例数据：
  - 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，相同宽度的字段会被分配在一起，除了 oops，其他的长度由长到短；
  - 默认分配顺序下，父类字段会被分配在子类字段前面。

 *注：HotSpot VM要求对象的起始地址必须是8字节的整数倍，所以不够要补齐。*

#### 对象访问方式

Java 程序需要通过虚拟机栈上的 reference 数据来操作堆上的具体对象，reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：句柄访问和直接指针访问。

**访问方式有两种：使用句柄和直接指针。 **

- **句柄方式**，Java堆中将会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图：

  <img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230719200131962.png" style="zoom:70%">

  

- **指针方式**，reference变量中直接存储的就是对象的地址，而Java堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，如下图：

  <img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230719200148051.png" style="zoom:70%">

> 这两种对象的访问方式各有优势：

- 使用句柄访问方式的最大好处是reference中存贮的是稳定的句柄地址，在对象被移动（比如垃圾收集时，对象移动是非常普遍的行为）**时只会改变句柄中的实例数据指针，而reference本身不需要被修改。**
- 使用直接指针访问方式的最大好处就是速度更快**，它节省了一次指针定位的时间开销**，由于对象的访问在Java中非常频繁，因此这类开销积少成多也是一项非常可观的执行成本。

**本书讨论的sun HotSpot虚拟机，也是现在的主流虚拟机，使用的是直接指针方式**

### OutOfMemoryError异常

在《Java虚拟机规范》的规定里，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发 生OutOfMemoryError（下文称OOM）异常的可能

#### java堆溢出

Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径 来避免垃圾回收机制清除这些对象，**那么随着对象数量的增加，总容量触及最大堆的容量限制后就会 产生内存溢出异常。**

当然，创建这么大对象比较麻烦，所以可以先限制虚拟机的内存大小，来很快的到上限。

> 可以通过限制Java堆的大小，设置为不可扩展（将堆的最小值参数-Xms和最大值参数-Xmx设置成一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便以后进行分析。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230719201113755.png" style="zoom:80%">

**Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况**。出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们。

如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的**，那就应当检查Java虚拟机 的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运 行期的内存消耗。**

####  虚拟机栈和本地方法栈溢出

> **由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，**因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是无效的，栈容量只由-Xss参数设定。
> 关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

> 这里把异常分为两种情况，实际上却存在着一些互相重叠的地方：**当栈空间无法分配时，到底是内存太小，还是已使用的栈空间太大，其本质只是对同一事件的两种表述而已。**这个事件指的就是空间不够了，当然就既不能拓展深度，也不能申请到栈空间

#### 运行时常量池溢出

> 如果要向运行时常量池中添加内容，最简单的方法是使用String.intern()这个Native方法。该方法的作用时：如果池中包含了一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。**由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。**

#### 方法区溢出

> 方法区用于存放Class相关的信息，如类名、访问修饰符、常量池、字段描述、方法描述等。生成大量的动态类区填充方法区，可以触发此区域的溢出异常。 方法区溢出是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定的条件比较苛刻。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景出了CGLib字节码增强外，还有大量JSP或者基于OSGi的应用等。

#### 本机直接内存溢出

> DirectMemory可以通过-XX:MaxDirectMemorySize指定，**如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。**
