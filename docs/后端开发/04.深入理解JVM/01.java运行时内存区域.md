---
title: Java运行时内存区域
date: 2023-07-13
categories: 
  - 后端开发
  - 深入理解JVM
---

> 除了《深入理解JVM虚拟机》，本系列笔记还参考了
>
> https://github.com/TangBean/understanding-the-jvm/blob/master
>
> https://github.com/maokuntao/understandingJVM

**概览**

![image-20230728211323220](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230728211323220.png)

<center> Java运行时内存区域</center>

### 程序计数器

> Program Counter Register

一块较小的内存区域，是**线程私有的内存**

**作用：**

看做当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来确定下一条要执行的字节码指令的位置，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。在任一时刻，一个处理器（对于多核处理器来说，就是一个内核）只会执行一条线程中的指令。**因此，为了能够恢复线程切换之前的线程状态到正确位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响，独立存储，我们称这类内存区域为“线程私有”的内存**。

- 线程执行 Java 方法和 native 方法时的区别：
  - 执行 Java 方法时：记录虚拟机正在执行的字节码指令地址；
  - 执行 native 方法时：无定义；
- 是 5 个区域中唯一不会出现 OOM （OutOfMemoryError）的区域。

> 也就是说每个线程都有自己独立的程序计数器

### 虚拟机栈

**Java虚拟机栈（Java Virtual Machine Stack），线程私有的**，它的生命周期与线程相同。

#### 栈帧

**它描述的是Java方法执行的内存模型**：**每个方法执行的时候都会同时创建一个栈帧（Stack Frame）**。

栈帧结构：**局部变量变量表、操作栈(操作数栈)、动态链接、方法出口等信息。**

**每一个方法被调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈中从入栈到出栈的过程。**

> 虚拟机栈的每个栈帧都有一个对应的**局部变量表**。其中存放了编译期可知的基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用（refrence类型，可能是一个对象起始地址的应用指针、也可能是一个代表对象的句柄或者其它与此对象相关的地址）和returnAddress（指向了一条字节码指令的地址）。

- 64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型会占用一个
- **局部变量所占用的空间在编译期间完成分配**，当进入一个方法时，这个方法在帧中所需要分配的局部变量的空间时完全可以确定的，**在运行期间也不会改变这个空间的大小。**

**每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法**

**一个线程所需要的内存基本上就是虚拟机栈大小**

> 因为线程私有的还有PC（显然很小），本地方法栈这些，但是hotspot没有区分本地方法栈和虚拟机栈

#### Q&A

1.垃圾回收涉及栈内存吗？

A：垃圾回收（Garbage Collection）通常不涉及栈内存的回收，因为栈内存中存放的是局部变量和方法调用的相关信息，其生命周期是通过方法的调用和执行来管理的，具有明确的作用域和生存周期。栈内存的回收通常是由Java虚拟机栈的自动管理来处理的。每当一个方法调用结束，对应的栈帧就会被出栈，方法的局部变量和执行状态等数据也会随之被销毁，从而释放栈内存

2.方法内的局部变量是否线程安全？

A：如果方法内局部变量没有逃离方法的作用访问，它是线程安全的 

​	如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

### 本地方法栈

**本地方法栈（Native Method Stack），线程私有**，与虚拟机栈的作用非常相似，只不过虚拟机栈是为虚拟机执行字节码（Java方法）服务，而本地方法栈是用来服务于虚拟机使用的Native方法（本地方法）服务。
具体的虚拟机可以自由实现它，甚至可以把它和虚拟机栈合二为一（譬如Sun HotSpot 虚拟机）。
与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryErroe异常。

> 注意：HotSPot把虚拟机栈和本地方法栈合二为一的实现了

### 堆

**Java堆（Java Heap）**是Java虚拟机所管理的内存中最大的一块。**是被所有的线程共享的一块内存区域**，在虚拟机启动时创建。

> 因为是共享的，所以有线程安全问题！

**此内存区域的唯一目的就是存放对象实例，**几乎所有的对象实例都在此分配内存。由于JIT编译器的发展与逃逸分析技术的发展，栈上分配、标量替换优化技术的进步，所有的对象实例都分配在堆上也不是那么绝对了。

**Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”（Garbage Collection Heap）。**

**现在的收集器都是采用分代收集算法，所以Java堆中可以细分为：新生代和老生代。**

根据Java虚拟机规范，Java堆可以是处于物理上不连续的内存空间中，只要逻辑上连续即可。在实现上可以是固定大小，也可以是可扩展的，**主流的是可扩展方式。**



### 方法区

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230728214655434.png" style="zoom:90%">

<center> 方法区的实现</center>

> 方法区只是虚拟机规范的内存区域，在不同版本jdk实现不一样

**方法区（Method Area）**与Java堆一样，都是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。**

Java虚拟机规范对这个区域的限制非常松，除了和Java堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。

当方法区的内存大小无法满足内存分配需要的时候，将抛出OutOfMemory异常。

> 方法区不是堆，别名非堆

元空间和方法区实现的区别

1. 实现位置：方法区通常是位于Java堆之外的一块连续内存区域（例如永久代），**而元空间使用的是本地内存（Native Memory）**，即位于操作系统的堆之外。
2. 自动内存管理：方法区中的元数据和常量池等数据由Java虚拟机进行自动的内存管理（垃圾回收），**而元空间中的元数据和常量池等数据不受Java虚拟机的自动内存管理控制。**
3. 垃圾回收：方法区可以进行垃圾回收，但永久代的垃圾回收通常是比较少见的。而元空间不进行垃圾回收，其管理方式转移到了Java虚拟机以外，**通常由操作系统来管理。**
4. 大小调整：方法区的大小可以通过Java虚拟机参数来调整，**而元空间的大小受限于系统可用的本地内存大小。**

总结，jdk8以前，方法区实现为永久代，但是性能不好，jdk8以后，用元空间来实现方法区，并且有很多区别。

#### 运行时常量池

先看**常量池(class 文件的一部分)**：常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量 等信息

**运行时常量池（Runtime Constant Pool）**是方法区的一部分。常量池是 *.class 文件中的，当该类被加载，**它的常量池信息就会放入运行时常量 池，并把里面的符号地址变为真实地址**

> Class文件除了有类的版本、字段、方法、接口等描述信息，**还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。**

> 运行时常量池相对于Class文件常量池的另外一个重要特征是**具备动态性**，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将将新的常量放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。
>
> 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时将会抛出OutOfMemoryError异常。

#### String Table

String Table（字符串表）是JVM中的一种数据结构，它是在JVM启动时创建的，作为运行时常量池的一部分，用于存储运行时常量池中的字符串对象。

在JVM中，为了避免重复创建相同内容的字符串对象，字符串常量池会使用String Table来进行字符串的重用。这样做有助于节省内存和提高性能。

特性：

- 常量池中的字符串仅是符号，第一次用到时才变为对象 
- 利用串池的机制，来避免重复创建字符串对象 
- 字符串变量拼接的原理是 StringBuilder （1.8）
-  字符串常量拼接的原理是编译期优化

可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 

- 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回 
- 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份， 放入串池， 会把串池中的对象返回

#### 题目

```java
String s1 = "a";
String s2 = "b";
String s3 = "a" + "b";
String s4 = s1 + s2;
String s5 = "ab";
String s6 = s4.intern();
 // 问
System.out.println(s3 == s4);false
System.out.println(s3 == s5);true
System.out.println(s3 == s6);true
String x2 = new String("c") + new String("d");
String x1 = "cd";
x2.intern();
// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢
System.out.println(x1 == x2);
```

解析：

1.

- `String s1 = "a";`: 创建了一个字符串常量 "a" 并将其引用赋值给变量 s1。
- `String s2 = "b";`: 创建了一个字符串常量 "b" 并将其引用赋值给变量 s2。
- `String s3 = "a" + "b";`: 编译器在编译时会对字符串常量的连接进行优化，所以 s3 实际上是指向字符串常量 "ab" 的引用。
- `String s4 = s1 + s2;`: 这里进行了字符串拼接操作，s1 和 s2 都是变量，所以在运行时会通过 StringBuilder 来创建新的字符串对象。s4 引用的是一个新的字符串对象，内容为 "ab"。
- `String s5 = "ab";`: 创建了一个字符串常量 "ab" 并将其引用赋值给变量 s5。
- `String s6 = s4.intern();`: 调用 intern() 方法会将 s4 所引用的字符串对象放入字符串常量池，并返回常量池中该字符串的引用。**所以 s6 实际上指向的是字符串常量池中的 "ab"。**

2.

- `String x2 = new String("c") + new String("d");`: 这里创建了两个字符串对象 "c" 和 "d"，然后进行字符串拼接操作，创建了新的字符串对象 "cd"，并将其引用赋值给 x2。
- `String x1 = "cd";`: 创建了一个字符串常量 "cd" 并将其引用赋值给 x1。
- `x2.intern();`: 调用 intern() 方法会将 x2 引用的字符串对象 "cd" 放入字符串常量池，**但由于 x2 的 intern() 方法没有将返回值赋给任何变量，所以这一行代码没有实际效果。**

因此

- `System.out.println(x1 == x2);`: 输出 false。**x1 是指向字符串常量池中的 "cd"，而 x2 是指向堆中的新创建的 "cd"，它们引用的是两个不同的对象。**
- 如果调换了最后两行代码的位置：结果不变，输出 false。因为 `x2.intern();` **并没有改变 x2 引用的对象，仍然是之前堆中的 "cd"，而x1直接去引用已经存在的常量池中的"cd"**

在 JDK 1.6 中，输出结果也是一样的，因为x2的引用没有更改

> 改成x2=x2.intern()才行

###  直接内存

**直接内存（Direct Memory）**并不是虚拟机运行时数据区的一部分，**也不是Java虚拟机规范中定义的内存区域**，但是这部分内存也被频繁地使用，而且有可能导致OutOfMemoryError异常。

在JDK1.4种新加入了NIO（New Iuput/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的**DirectByteBuffer对象作为这块内存的引用进行操作**。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

显然，本机直接内存分配不会受到Java堆大小的限制，但是既然是内存，肯定会受到本机总内存的大小和处理器寻址空间的限制。所以也可能会抛出OutOfMemoryError异常。

总结一下：

- 常见于 NIO 操作时，用于数据缓冲区 
- 分配回收成本较高，但读写性能高 
- 不受 JVM 内存回收管理

> 感觉了解就行

### 内存溢出

在《Java虚拟机规范》的规定里，除了程序计数器外，**虚拟机内存的其他几个运行时区域都有发 生OutOfMemoryError（下文称OOM）异常的可能**

#### java堆溢出

Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径 来避免垃圾回收机制清除这些对象，**那么随着对象数量的增加，总容量触及最大堆的容量限制后就会 产生内存溢出异常。**

> 可以通过限制Java堆的大小，设置为不可扩展（将堆的最小值参数-Xms和最大值参数-Xmx设置成一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便以后进行分析。

**Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况**。出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们。

如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的**，那就应当检查Java虚拟机 的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运 行期的内存消耗。**

####  虚拟机栈和本地方法栈溢出

> **由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，**因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是无效的，栈容量只由-Xss参数设定。
> 关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

> 这里把异常分为两种情况，实际上却存在着一些互相重叠的地方：**当栈空间无法分配时，到底是内存太小，还是已使用的栈空间太大，其本质只是对同一事件的两种表述而已。**

#### 运行时常量池溢出

​	如果要向运行时常量池中添加内容，最简单的方法是使用String.intern()这个Native方法。

该方法的作用时：如果池中包含了一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。

**由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。**

#### 方法区溢出

​	方法区用于存放Class相关的信息，如类名、访问修饰符、常量池、字段描述、方法描述等。生成大量的动态类区填充方法区，可以触发此区域的溢出异常。 方法区溢出是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定的条件比较苛刻。

**在经常动态生成大量Class的应用中，需要特别注意类的回收状况**。这类场景出了CGLib字节码增强外，还有大量JSP或者基于OSGi的应用等。

#### 本机直接内存溢出

DirectMemory可以通过-XX:MaxDirectMemorySize指定，**如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。**

### Hotspot的对象

为了对内存区域有更直观感受，这里讲了 JVM 对 Java 堆中的对象的创建、布局和访问的全过程。

#### 对象的创建（遇到一条 new 指令时）

比如：

`Object obj = new Object();`

> 本地变量和局部变量是同一个概念，在Java中这两个词可以互换使用。它们指的是在方法或代码块内部声明的变量，其作用域和生命周期仅限于所在的方法或代码块。
>
> "Object obj"**这部分的语义将会反映到Java栈的本地变量中**，作为一个Reference类型数据出现。
>
> 而"new Object()"**这部分的语义将会反映到Java堆中**，形成一块儿存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块儿内存的大小是不固定的。
>
> 另外，在Java堆中，**还必须包含能包括能查到此对象类型数据（如，对象类型、父类、实现的接口、方法等）的地址信息，这些数据存储在方法区（JDK8之后是元数据区）中**。

1. 检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先把这个类加载进内存；
2. 类加载检查通过后，**虚拟机将为新对象分配内存，此时已经可以确定存储这个对象所需的内存大小（也就是类加载完成时已经可以确认对象所需内存大小）**；
3. 在堆中为新对象分配可用内存；
4. 将分配到的内存初始化；
5. 设置对象头中的数据；
6. 此时，从虚拟机的角度看，对象已经创建好了，**但从 Java 程序的角度看，对象创建才刚刚开始，构造函数还没有执行。**

**第 3 步，在堆中为新对象分配可用内存时，会涉及到以下两个问题：**

**如何在堆中为新对象划分可用的内存？**

- 指针碰撞（内存分配规整）
  - 用过的内存放一边，没用过的内存放一边，中间用一个指针分隔；
  - 分配内存的过程就是将指针向没用过的内存那边移动所需的长度；
- 空闲列表（内存分配不规整）
  - 维护一个列表，记录哪些内存块是可用的；                                                                                                                 
  - 分配内存时，从列表上选取一块足够大的空间分给对象，并更新列表上的记录；

> 内存是否规整由java堆所采用得垃圾收集器是否带有空间压缩整理能力决定

**如何处理多线程创建对象时，划分内存的指针的同步问题？**

> 比如A正在分配内存，指针还没转过去，但是b又使用这个指针分配内存，就会有并发安全问题

- 对分配内存空间的动作进行同步处理（CAS）；
- 把内存分配动作按照线程划分在不同 的空间之中进行；
  - 每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）；
  - 哪个线程要分配内存就在哪个线程的 TLAB 上分配，TLAB 用完需要分配新的 TLAB 时，才需要同步锁定；
  - 通过 `-XX:+/-UseTLAB` 参数设定是否使用 TLAB。

#### 对象的内存布局

**类加载时，JVM已经知道每个类对象的布局和大小（就是下面的的三项），因此可以在对象实例化时直接分配正确大小的内存空间**

>因为类的所有字段大小，以及一些额外的元数据信息，如对象的哈希码、类型指针等，还有对齐填充等等都已知，当然能确定对象的大小

- 对象头：
  - 第一部分：存储对象自身运行时的数据，HashCode、GC分代年龄等（Mark Word）；
  - 第二部分：类型指针，指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例（HotSpot 采用的是直接指针的方式访问对象的）；
  - 如果是个数组对象，对象头中还有一块用于记录数组长度的数据。
- 实例数据：
  - 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，相同宽度的字段会被分配在一起，除了 oops，其他的长度由长到短；
  - 默认分配顺序下，父类字段会被分配在子类字段前面。

- 对齐填充：HotSpot VM要求对象的起始地址必须是8字节的整数倍，所以不够要补齐。

#### 对象访问方式

**Java 程序需要通过虚拟机栈上的 reference 数据来操作堆上的具体对象，**reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：句柄访问和直接指针访问。

> reference是线程私有的，但是指向的对象是线程共有的

**访问方式有两种：使用句柄和直接指针。 **

- **句柄方式**，Java堆中将会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图：

  <img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230719200131962.png" style="zoom:70%">

  

- **指针方式**，reference变量中直接存储的就是对象的地址，而Java堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，如下图：

  <img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230719200148051.png" style="zoom:70%">

> 这两种对象的访问方式各有优势：

- 使用句柄访问方式的最大好处是reference中存贮的是稳定的句柄地址，在对象被移动（比如垃圾收集时，对象移动是非常普遍的行为）**时只会改变句柄中的实例数据指针，而reference本身不需要被修改。**
- 使用直接指针访问方式的最大好处就是速度更快**，它节省了一次指针定位的时间开销**，由于对象的访问在Java中非常频繁，因此这类开销积少成多也是一项非常可观的执行成本。

**本书讨论的sun HotSpot虚拟机，也是现在的主流虚拟机，使用的是直接指针方式**
