---
title: Go快速入门
date: 2023-06-03
categories: 
  - 后端开发
  - Go
---

> 参考：[8 小时学习Golang](https://www.yuque.com/aceld/mo95lb/zwukev)
>
> (很基础，从配环境讲起)



## Hello World

~~~go
package main

import "fmt"

func main() {
	fmt.Println("Hello Go")
}

~~~

`go run xxx.go`一步编译运行

- 第一行代码**package main**定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
- 下一行**import "fmt"**告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），**fmt 包实现了格式化 IO（输入/输出）的函数**。
- 下一行func main()是程序开始执行的函数。**main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。**
- 下一行fmt.Println(...)可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 使用 fmt.Print("hello, world\n") 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。

## 声明变量

声明变量的一般形式是使用 var 关键字

> 也可以指定类型，还是要用var

~~~go
package main

import "fmt"

func main() {
        //第一种 没有赋值，使用默认值，int的话是0
        var a int
        fmt.Printf("a = %d\n", a)


        //第二种
        var b int = 10
        fmt.Printf("b = %d\n", b)
			

        //第三种 省略后面的数据类型,自动匹配类型
        var c = 20
        fmt.Printf("c = %d\n", c)
		

        //第四种 省略var关键字
        d := 3.14
        fmt.Printf("d = %f\n", d)
    	//等价于var d=3.14   自动匹配为float类型
       //这种写法只能用户func 里面，如果在func外面，必须加var
}
~~~

### 多变量声明

~~~go
package main


import "fmt"


var x, y int
var ( //这种分解的写法,一般用于声明全局变量
        a int
        b bool
)

var c, d int = 1, 2
var e, f = 123, "liudanbing"

//这种不带声明格式的只能在函数体内声明
//g, h := 123, "需要在func函数体内实现"

func main() {
        g, h := 123, "需要在func函数体内实现"
        fmt.Println(x, y, a, b, c, d, e, f, g, h)

        //不能对g变量再次做初始化声明
        //g := 400这样会报错
        _, value := 7, 5  //实际上7的赋值被废弃，变量 _  不具备读特性
        //fmt.Println(_) //_变量的是读不出来的，也就是_不能当变量名
        fmt.Println(value) //5
}
~~~

## 常量

常量的定义格式：

```go
const identifier [type] = value
```

你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。

- 显式类型定义：

```go
const b string = "abc"
```

- 隐式类型定义：

```go
const b = "abc"
```

例如：

~~~go
package main

import "fmt"

func main() {
   const LENGTH int = 10
   const WIDTH int = 5   
   var area int
   const a, b, c = 1, false, "str" //多重赋值,也就是可以同时给不同类型的常量赋值
   area = LENGTH * WIDTH
   fmt.Printf("面积为 : %d\n", area)
   println(a, b, c)   
    //面积为 : 50
    //1 false str
}
~~~

常量还可以用作枚举：

```go
const (
    Unknown = 0
    Female = 1
    Male = 2
)
```

数字 0、1 和 2 分别代表未知性别、女性和男性。

**常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：**

```go
package main


import "unsafe"
const (
    a = "abc"
    b = len(a)
    c = unsafe.Sizeof(a)
)


func main(){
    println(a, b, c)
}
```

输出结果为：abc, 3, 16

>unsafe.Sizeof(a)返回类型字节大小，输出的结果是16 。
>
>字符串类型在 go 里是个结构, **包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。**

### 自增长

在 golang 中，一个方便的习惯就是使用`iota`标示符，**它简化了常量用于增长数字的定义，给以上相同的值以准确的分类。**

```go
const (
    CategoryBooks = iota // 0
    CategoryHealth       // 1
    CategoryClothing     // 2
)
```

### iota和表达式

`iota`可以做更多事情，而不仅仅是 increment。更精确地说，`iota`总是用于 increment，但是它可以用于表达式，在常量中的存储结果值。

> 从0开始增长

```go
type Allergen int


const (
    IgEggs Allergen = 1 << iota         // 1 << 0 which is 00000001
    IgChocolate                         // 1 << 1 which is 00000010
    IgNuts                              // 1 << 2 which is 00000100
    IgStrawberries                      // 1 << 3 which is 00001000
    IgShellfish                         // 1 << 4 which is 00010000
)
```

因为当你在一个`const`组中仅仅有一个标示符在一行的时候，它将使用增长的`iota`取得前面的表达式并且再运用它，。**在 Go 语言的[spec](https://legacy.gitbook.com/book/aceld/how-do-go/edit#)中， 这就是所谓的隐性重复最后一个非空的表达式列表.**

如果你对鸡蛋，巧克力和海鲜过敏，把这些 bits 翻转到 “on” 的位置（从左到右映射 bits）。然后你将得到一个 bit 值`00010011`，它对应十进制的 19。

~~~go
fmt.Println(IgEggs | IgChocolate | IgShellfish)


// output:
// 19
type ByteSize float64


const (
    _           = iota                   // ignore first value by assigning to blank identifier，因为第一个是0
    KB ByteSize = 1 << (10 * iota)       // 1 << (10*1)
    MB                                   // 1 << (10*2)
    GB                                   // 1 << (10*3)
    TB                                   // 1 << (10*4)
    PB                                   // 1 << (10*5)
    EB                                   // 1 << (10*6)
    ZB                                   // 1 << (10*7)
    YB                                   // 1 << (10*8)
)
~~~

### 如果有两个itoa在同一行

~~~go
const (
    Apple, Banana = iota + 1, iota + 2
    Cherimoya, Durian
    Elderberry, Fig
)
//两个分开计数的
// Apple: 1
// Banana: 2
// Cherimoya: 2
// Durian: 3
// Elderberry: 3
// Fig: 4
~~~

## 函数

### init函数与import

首先我们看一个例子：init函数：

init 函数可在package main中，可在其他package中，可在同一个package中出现多次。

### **main函数**

main 函数只能在package main中。

### **执行顺序**

**golang里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）**。这两个函数在定义时不能有任何的参数和返回值。

虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都**强烈建议用户在一个package中每个文件只写一个init函数。**

**go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。**

**程序的初始化和执行都起始于main包。**

如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。

当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。

等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1650528765014-63d3d631-428e-4468-bc95-40206d8cd252.png" style="zoom:70%">

#### 例子

![32-init.png](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/1650528772039-e4ba0169-fd2a-4505-9423-378337979276.png)

Lib1.go

```go
package InitLib1

import "fmt"

func init() {
    fmt.Println("lib1")
}
```

Lib2.go

```go
package InitLib2

import "fmt"

func init() {
    fmt.Println("lib2")
}
```

main.go

```go
package main

import (
    "fmt"
    _ "GolangTraining/InitLib1"//下划线加空格，然后写路径
    _ "GolangTraining/InitLib2"
)

func init() {
    fmt.Println("libmain init")
}

func main() {
    fmt.Println("libmian main")
}
```

代码很简单，只是一些简单的输出

```bash
lib1
lib2
libmain init
libmian main
```

输出的顺序与我们上面图给出的顺序是一致的

#### **注：**

如果main中，一个包会被多个包同时导入，那么它只会被导入一次

**我们现在就改动一个地方，Lib1包导入Lib2，main包不管**

```go
package InitLib1

import (
    "fmt"
    _ "GolangTraining/InitLib2"
)

func init() {
    fmt.P rintln("lib1")
}
```

输出：

```bash
lib2
lib1
libmain init
libmian main
```

**main包以及Lib1包都导入了Lib2，但是只出现一次，并且最先输出，**

**先输出lib2是因为main包中导入Lib1时，Lib1又导入了Lib2，会首先初始化Lib2包的东西**

### 参数

#### 值传递

值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

**默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。**

#### 传引用（指针传递）

Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。

我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。

Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。

以下实例演示了变量在内存中地址：

~~~go
package main
import "fmt"

func main() {
   var a int = 10   
   fmt.Printf("变量的地址: %x\n", &a  )
}
~~~

引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：

```go
/* 定义交换值函数*/
func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保持 x 地址上的值 */
   *x = *y      /* 将 y 值赋给 x */
   *y = temp    /* 将 temp 值赋给 y */
}
//.....
/* 调用 swap() 函数
   * &a 指向 a 指针，a 变量的地址
   * &b 指向 b 指针，b 变量的地址
   */
 swap(&a, &b)
```

> 和C++一样，传递的时候用&取地址，形参用*x,表示这是指针

### 返回值

Go 函数可以返回多个值，例如：

```go
package main


import "fmt"


func swap(x, y string) (string, string) {
   return y, x
}


func main() {
   a, b := swap("Mahesh", "Kumar")
   fmt.Println(a, b)
    //Kumar Mahesh
}
```

## defer

defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为延迟函数。

defer作用：

- 释放占用的资源(比如释放一个锁)
- 捕捉处理异常
- 输出日志

结果

**如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。**

~~~go
func Demo(){
	defer fmt.Println("1")
	defer fmt.Println("2")
	defer fmt.Println("3")
	defer fmt.Println("4")
}
func main() {
	Demo()
}
/*
*4
*3
*2
*1
*/
~~~

### recover错误拦截

Go中引入的Exception处理：defer, panic, recover。

>[Go语言 异常panic和恢复recover用法](https://www.jianshu.com/p/0cbc97bd33fb)

panic：
 1、内建函数
 2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行
 3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行，这里的defer 有点类似 try-catch-finally 中的 finally
 4、直到goroutine整个退出，并报告错误

recover：
 1、内建函数
 2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为
 3、一般的调用建议
 a). 在defer函数中，通过recever来终止一个gojroutine的panicking过程，从而恢复正常代码的执行
 b). 可以获取通过panic传递的error

运行时panic异常一旦被引发就会导致程序崩溃。

 Go语言提供了专用于“拦截”运行时panic的内建函数“recover”。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。

  **注意：**recover只有在defer调用的函数中有效。

~~~go
func recover interface{}
~~~

~~~go
package main

import "fmt"

func Demo(i int) {
	//定义10个元素的数组
	var arr [10]int
	//错误拦截要在产生错误前设置
	defer func() {
		//设置recover拦截错误信息
		err := recover()
		//产生panic异常  打印错误信息
		if err != nil {
			fmt.Println(err)
		}
	}()
	//根据函数参数为数组元素赋值
	//如果i的值超过数组下标 会报错误：数组下标越界
	arr[i] = 10

}

func main() {
	Demo(10)
	//产生错误后 程序继续
	fmt.Println("程序继续执行...")
}


//runtime error: index out of range
//程序继续执行...
~~~

## **slice和map**