---
title: Feign和Gateway
date: 2023-06-19
categories: 
  - 后端开发
  - 微服务
---

## Feign

先来看我们以前利用RestTemplate发起远程调用的代码：

![image-20230619164806129](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619164806129.png)

Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。

### quick-start

Feign的使用步骤引入

- 依赖添加@EnableFeignClients注解
- 编写FeignClient接口
- 使用FeignClient中定义的方法代替RestTemplate

引入依赖

~~~xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
~~~

在order-service的启动类添加注解开启Feign的功能：

![image-20230619164328673](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619164328673.png)

![image-20230619164426304](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619164426304.png)

主要是基于SpringMVC的注解来声明远程调用的信息，

比如：

- 服务名称：userservice
- 请求方式：GET请求
- 路径：/user/{id}
- 请求参数：Long id
- 返回值类型：User

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619164924840.png" style="zoom:80%">

### 自定义Feign配置

Feign运行自定义配置来覆盖默认配置，可以修改的配置如下：

![image-20230619165646926](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619165646926.png)

> 一般我们需要配置的就是日志级别。

#### 配置文件配置

![image-20230619165812134](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619165812134.png)

#### 写代码配置

![image-20230619165833870](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619165833870.png)

### Feign性能优化

Feign底层的客户端实现：

- URLConnection：默认实现，不支持连接池
- Apache HttpClient ：支持连接池OKHttp：支持连接池

因此优化Feign的性能主要包括：

- 使用连接池代替默认的URLConnection
- 日志级别，最好用basic或none

#### 连接池配置

![image-20230619170024869](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619170024869.png)

### 最佳实践

Feign的最佳实践（两种办法）

> 最佳实践就是怎么用这个Feign

- 让controller和FeignClient继承同一接口
- 将FeignClient、POJO、Feign的默认配置都定义到一个项目中，供所有消费者使用

![image-20230619170257914](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619170257914.png)

**方式二（抽取，一般用这个）**：将FeignClient抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用

![image-20230619170450979](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619170450979.png)

具体操作

- 首先创建一个module，命名为feign-api，

- ~~~xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <parent>
          <artifactId>cloud-demo</artifactId>
          <groupId>cn.itcast.demo</groupId>
          <version>1.0</version>
      </parent>
      <modelVersion>4.0.0</modelVersion>
  
      <artifactId>feign-api</artifactId>
  
      <properties>
          <maven.compiler.source>8</maven.compiler.source>
          <maven.compiler.target>8</maven.compiler.target>
      </properties>
  
      <dependencies>
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-starter-openfeign</artifactId>
          </dependency>
      </dependencies>
  </project>
  ~~~

- 然后引入feign的starter依赖将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中

- <img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619170623049.png"/>

- 在order-service中引入feign-api的依赖

- ~~~xml
  <dependency>
      <groupId>cn.itcast.demo</groupId>
      <artifactId>feign-api</artifactId>
      <version>1.0</version>
  </dependency>
  ~~~

- 修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包,比如：

- ![image-20230619170755595](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619170755595.png)

- 重启测试

当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种方式解决：

![image-20230619170552383](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619170552383.png)

## 统一网关Gateway

网关功能：

- 身份认证和权限校验
- 服务路由、负载均衡
- 请求限流

![image-20230619170933746](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619170933746.png)

在SpringCloud中网关的实现包括两种：

gatewayzuulZuul是基于Servlet的实现，属于阻塞式编程。

**而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。**

### 搭建网关服务

1创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖：

![image-20230619205800359](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619205800359.png)

~~~xml
<!--nacos服务注册发现依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
<!--网关gateway依赖-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
~~~

2编写路由配置及nacos地址

~~~yaml
server:
  port: 10010
logging:
  level:
    cn.itcast: debug
  pattern:
    dateformat: MM-dd HH:mm:ss:SSS
spring:
  application:
    name: gateway
  cloud:
    nacos:
      server-addr: nacos:8848 # nacos地址
    gateway:
      routes:
        - id: user-service # 路由标示，必须唯一
          uri: lb://userservice # 路由的目标地址
          predicates: # 路由断言，判断请求是否符合规则
            - Path=/user/** # 路径断言，判断路径是否是以/user开头，如果是则符合
~~~

![image-20230619210000997](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619210000997.png)

### 路由断言工厂Route Predicate Factory

**这个类的作用**是读取用户定义的断言条件（从配置文件中读取字符串再解析），对请求做出判断

上面可以看到，路由可以配置

路由id：路由的唯一标示

路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡

路由断言（predicates）：路由断言，判断请求是否符合要求，符合则转发到路由目的地

过滤器（filters）：对请求或响应做处理

> 我们在配置文件中写的断言规则是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件
>
> 例如Path=/user/**是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的
>
> 像这样的断言工厂在SpringCloudGateway还有十几个

Spring提供了11种基本的Predicate工厂：

![image-20230619214140850](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619214140850.png)

### 路由过滤器 GatewayFilter

GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619214323459.png" style="zoom:80%">

Spring提供了31种不同的路由过滤器工厂。例如：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619214407961.png" style="zoom:90%">

#### 案例

给所有进入userservice的请求添加一个请求头

给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!

实现方式：**在gateway中修改application.yml文件，给userservice的路由添加过滤器**：

~~~yaml
spring:
  application:
    name: gateway
  cloud:
    nacos:
      server-addr: nacos:8848 # nacos地址
    gateway:
      routes:
        - id: user-service # 路由标示，必须唯一
          uri: lb://userservice # 路由的目标地址
          predicates: # 路由断言，判断请求是否符合规则
            - Path=/user/** # 路径断言，判断路径是否是以/user开头，如果是则符合
        - id: order-service
          uri: lb://orderservice
          predicates:
            - Path=/order/**
      #通过这下面配置项实现
      # 对所有路由生效，要加default
      default-filters:
      #filters过滤器 用这个配置，配置该路由下的过滤器只对当前路由的请求生效
        - AddRequestHeader=Truth,Itcast is freaking awesome!
~~~

> 一个服务对于一个路由，所以对所有路由都生效的default-filter的意思是对所有服务来的请求都会加上那个请求头

### 全局过滤器 GlobalFilter

全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。

区别在于GatewayFilter通过配置定义，处理逻辑是固定的。**而GlobalFilter的逻辑需要自己写代码实现。定义方式是实现GlobalFilter接口。**

~~~java
public interface GlobalFilter {
    /**
    *处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理
    * @param exchange 请求上下文，里面可以获取Request、Response等信息
    * @param chain 用来把请求委托给下一个过滤器 
    * @return {@code Mono<Void>} 返回标示当前过滤器业务结束
    */
       Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}
~~~

#### 案例

定义全局过滤器，拦截并判断用户身份

定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：

- 参数中是否有authorization
- authorization参数值是否为admin

如果同时满足则放行，否则拦截

1 自定义类，实现GlobalFilter接口，添加@Order注解：

2添加@Order注解或实现Ordered接口

3编写处理逻辑

> 下面这个是实现了Ordered接口

~~~java
package cn.itcast.gateway;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.util.MultiValueMap;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

// @Order(-1)
@Component
public class AuthorizeFilter implements GlobalFilter, Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1.获取请求参数
        ServerHttpRequest request = exchange.getRequest();
        MultiValueMap<String, String> params = request.getQueryParams();
        // 2.获取参数中的 authorization 参数
        String auth = params.getFirst("authorization");
        // 3.判断参数值是否等于 admin
        if ("admin".equals(auth)) {
            // 4.是，放行
            return chain.filter(exchange);
        }
        // 5.否，拦截
        // 5.1.设置状态码
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        // 5.2.拦截请求
        return exchange.getResponse().setComplete();
    }

    @Override
    public int getOrder() {
        return -1;
    }
}

~~~

### 过滤器执行顺序

请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器

![image-20230619222040620](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230619222040620.png)

每一个过滤器都必须指定一个int类型的order值，**order值越小，优先级越高，执行顺序越靠前。**

GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定

路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。

**当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器 > GlobalFilter的顺序执行。**

> 可以参考下面源码
>
> org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。
>
> org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链
