---
title: L1 Introduction
date: 2023-12-08
tags: 
  - 操作系统
categories: 
  - 其他
  - mit6.828
---

这节课主要介绍操作系统中的一些基本概念和重要的名词。

操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信

- *xv6*：**一种在本课程中使用的类UNIX的教学操作系统**，运行在RISC-V指令集处理器上，本课程中将使用*QEMU*模拟器代替

## Kernal

**kernel(内核)：**为运行的程序提供服务的一种特殊程序。每个运行着的程序叫做进程，每个进程的内存中存储指令、数据和堆栈。一个计算机可以拥有多个进程，但是只能有一个内核

每当进程需要调用内核时，它会触发一个*system call*（系统调用），system call进入内核执行相应的服务然后返回。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231208165455028.png" alt="image-20231208165455028" style="zoom:50%;" />

下面是xv6提供部分system call截图:

| 系统调用  | 描述              |
| --------- | ----------------- |
| fork()    | 创建进程          |
| exit()    | 结束当前进程      |
| wait()    | 等待子进程结束    |
| kill(pid) | 结束 pid 所指进程 |
| getpid()  | 获得当前进程 pid  |
| sleep(n)  | 睡眠 n 秒         |

**Shell**:   shell 是一个普通程序，而不是内核的一部分。他接受用户输入的命令并执行他们，一般来说shell也是类Unix系统中最基本的用户界面。

> 正是因为shell不是内核的一部分，所以有各种各样的shell，xv6 shell 本质上是一个 Unix Bourne shell 的简单实现。

## Processes and Memory

一个 xv6 进程由两部分组成：kernel将每一个进程用一个**PID(process identifier)**指代。

- 一部分是用户内存空间（指令，数据，栈）
- 另一部分是仅对内核可见的进程状态（内核空间）。

常用systemcall

- `fork`：形式：`int fork()`。**其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程**。
  - **在父进程中，`fork`的返回值是这个子进程的PID，在子进程中，返回值是0**
- `exit`：形式：`int exit(int status)`。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出
- `wait`：形式：`int wait(int *status)`。等待子进程退出，返回子进程PID，子进程的退出状态存储到`int *status`这个地址中。如果调用者没有子进程，`wait`将返回-1

```C
int pid;
pid = fork();
if(pid > 0){
    printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
} else if(pid == 0){
    printf("child: exiting\n");
    exit();
} else {
    printf("fork error\n");
}
```

前两行输出可能是

```
parent: child=1234
child: exiting
```

也可能是

```
child: exiting
parent: child=1234
```

这是因为在fork了之后，父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。看哪个进程先判断好PID的值，以上输出顺序才会被决定。

最后一行输出为

```
parent: child 1234 is done
```

子进程在判断完`pid == 0`之后将`exit`，父进程发现子进程`exit`之后，`wait`执行完毕，打印输出

尽管`fork`了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程。

- `exec`：形式：`int exec(char *file, char *argv[])`。加载一个文件，获取执行它的参数，执行。如果执行错误返回-1，执行成功则不会返回，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。

  xv6 shell使用以上四个system call来为用户执行程序。在shell进程的`main`中主循环先通过`getcmd`来从用户获取命令，然后调用`fork`来运行一个和当前shell进程完全相同的子进程。父进程调用`wait`等待子进程`exec`执行完（在`runcmd`中调用`exec`）
