---
title: 创建者模式
date: 2023-12-27
tags: 
  - 设计模式
categories: 
  - 其他
  - 设计模式
---

**创建者模式提供创建对象的机制， 能够提升已有代码的灵活性和可复⽤性。**

创建者模式包括：⼯⼚⽅法、抽象⼯⼚、⽣成器、原型、单例，这5类。

## 工厂方法模式

工厂模式又称工厂方法模式，是一种创建新设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

> 工厂模式让子类去决定使用那个工厂类，使得创建对象的过程延迟到子类进行

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227162027818.png" alt="image-20231227162027818" style="zoom:67%;" />

### **场景**

多种类型商品不同接口，统一发奖服务

在营销场景中经常会有某个⽤户做了⼀些操作；打卡、分享、留⾔、邀请注册等等，进⾏返利积分，最 后通过积分在兑换商品，从⽽促活和拉新。 那么在这⾥我们模拟积分兑换中的发放多种类型商品，假如现在我们有如下三种类型的商品接⼝；

| 序 号 | 类型                | 接⼝                                                         |
| ----- | ------------------- | ------------------------------------------------------------ |
| 1     | 优惠券              | CouponResult sendCoupon(String uId, String couponNumber, String uuid) |
| 2     | 实物商品            | Boolean deliverGoods(DeliverReq req)                         |
| 3     | 第三⽅爱奇艺 兑换卡 | void grantToken(String bindMobileNumber, String cardId)      |

从以上接⼝来看有如下信息： 

- 三个接⼝返回类型不同，有对象类型、布尔类型、还有⼀个空类型。
-  ⼊参不同，发放优惠券需要仿᯿、兑换卡需要卡ID、实物商品需要发货位置(对象中含有)。 
- 另外可能会随着后续的业务的发展，会新增其他种商品类型。因为你所有的开发需求都是随着业务 对市场的拓展⽽带来的

### **实现**

我们可以用一坨的代码去实现，⼯程结构上⾮常简单，⼀个⼊参对象 AwardReq 、⼀个出参对象 AwardRes ，以及⼀个接⼝类 PrizeController

![image-20231227172714934](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227172714934.png)

然后把所有的if-else写在一起

```java
/**
 * 模拟发奖服务
 */
public class PrizeController {

    private Logger logger = LoggerFactory.getLogger(PrizeController.class);

    public AwardRes awardToUser(AwardReq req) {
        String reqJson = JSON.toJSONString(req);
        AwardRes awardRes = null;
        try {
            logger.info("奖品发放开始{}。req:{}", req.getuId(), reqJson);
            // 按照不同类型方法商品[1优惠券、2实物商品、3第三方兑换卡(爱奇艺)]
            if (req.getAwardType() == 1) {
                CouponService couponService = new CouponService();
                CouponResult couponResult = couponService.sendCoupon(req.getuId(), req.getAwardNumber(), req.getBizId());
                if ("0000".equals(couponResult.getCode())) {
                    awardRes = new AwardRes("0000", "发放成功");
                } else {
                    awardRes = new AwardRes("0001", couponResult.getInfo());
                }
            } else if (req.getAwardType() == 2) {
                GoodsService goodsService = new GoodsService();
                DeliverReq deliverReq = new DeliverReq();
                deliverReq.setUserName(queryUserName(req.getuId()));
                deliverReq.setUserPhone(queryUserPhoneNumber(req.getuId()));
                deliverReq.setSku(req.getAwardNumber());
                deliverReq.setOrderId(req.getBizId());
                deliverReq.setConsigneeUserName(req.getExtMap().get("consigneeUserName"));
                deliverReq.setConsigneeUserPhone(req.getExtMap().get("consigneeUserPhone"));
                deliverReq.setConsigneeUserAddress(req.getExtMap().get("consigneeUserAddress"));
                Boolean isSuccess = goodsService.deliverGoods(deliverReq);
                if (isSuccess) {
                    awardRes = new AwardRes("0000", "发放成功");
                } else {
                    awardRes = new AwardRes("0001", "发放失败");
                }
            } else if (req.getAwardType() == 3) {
                String bindMobileNumber = queryUserPhoneNumber(req.getuId());
                IQiYiCardService iQiYiCardService = new IQiYiCardService();
                iQiYiCardService.grantToken(bindMobileNumber, req.getAwardNumber());
                awardRes = new AwardRes("0000", "发放成功");
            }
            logger.info("奖品发放完成{}。", req.getuId());
        } catch (Exception e) {
            logger.error("奖品发放失败{}。req:{}", req.getuId(), reqJson, e);
            awardRes = new AwardRes("0001", e.getMessage());
        }

        return awardRes;
    }

    private String queryUserName(String uId) {
        return "花花";
    }

    private String queryUserPhoneNumber(String uId) {
        return "15200101232";
    }

}

```

> 暂时看来，这个代码没什么问题，但是如果迭代开发几轮，这代码就很麻烦了。重构成本⾼需要理清之前每⼀个接⼝的使⽤，测试回归验证时间⻓，需要全部验证⼀ 次。这也就是很多⼈并不愿意接⼿别⼈的代码，如果接⼿了⼜被压榨开发时间。那么可想⽽知这样 的 ifelse 还会继续增加。

**工厂模式优化代码**

工程结构

![image-20231227173153209](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227173153209.png)

我们将发奖这个行为抽象为一个接口，然后不同的奖品发放实现为不同的实现类。

```java
public interface ICommodity {
    void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception;
}

```

以优惠券为例

```java
package org.itstack.demo.design.store.impl;

public class CouponCommodityService implements ICommodity {

    private Logger logger = LoggerFactory.getLogger(CouponCommodityService.class);//我们发现Logger也是工厂模式实现的

    private CouponService couponService = new CouponService();

    public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
        CouponResult couponResult = couponService.sendCoupon(uId, commodityId, bizId);
        logger.info("请求参数[优惠券] => uId：{} commodityId：{} bizId：{} extMap：{}", uId, commodityId, bizId, JSON.toJSON(extMap));
        logger.info("测试结果[优惠券]：{}", JSON.toJSON(couponResult));
        if (!"0000".equals(couponResult.getCode())) throw new RuntimeException(couponResult.getInfo());
    }

}

```

**创建商店⼯⼚**

我们定义了⼀个商店的⼯⼚类，在⾥⾯按照类型实现各种商品的服务。可以⾮常⼲净整洁的处 理你的代码，后续新增的商品在这⾥扩展即可。

```java
public class StoreFactory {

    public ICommodity getCommodityService(Integer commodityType) {
        if (null == commodityType) return null;
        if (1 == commodityType) return new CouponCommodityService();
        if (2 == commodityType) return new GoodsCommodityService();
        if (3 == commodityType) return new CardCommodityService();
        throw new RuntimeException("不存在的商品服务类型");
    }

}
```

#### 测试

> 写⼀个单元测试来验证上⾯编写的接⼝⽅式，养成单元测试的好习惯会为你增强代码质量。

```java
public class ApiTest {

    @Test
    public void test_commodity() throws Exception {
        StoreFactory storeFactory = new StoreFactory();

        // 1. 优惠券
        ICommodity commodityService_1 = storeFactory.getCommodityService(1);
        commodityService_1.sendCommodity("10001", "EGM1023938910232121323432", "791098764902132", null);

        // 2. 实物商品
        ICommodity commodityService_2 = storeFactory.getCommodityService(2);
        Map<String,String> extMap = new HashMap<String,String>();
        extMap.put("consigneeUserName", "谢飞机");
        extMap.put("consigneeUserPhone", "15200292123");
        extMap.put("consigneeUserAddress", "吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109");

        commodityService_2.sendCommodity("10001","9820198721311","1023000020112221113",new HashMap<String, String>() {{
            put("consigneeUserName", "谢飞机");
            put("consigneeUserPhone", "15200292123");
            put("consigneeUserAddress", "吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109");
        }});

        // 3. 第三方兑换卡(爱奇艺)
        ICommodity commodityService_3 = storeFactory.getCommodityService(3);
        commodityService_3.sendCommodity("10001","AQY1xjkUodl8LO975GdfrYUio",null,null);

    }

}

```

测试结果

![image-20231227175030498](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227175030498.png)

### 总结

工厂模式的好处是：

- 避免创建者与具体的产品逻辑耦合
- 满足单一职责、每一个业务逻辑都在其所属类中完成
- 满足开闭原则，无需更改原有的代码，只需实现新的实现类，就可以在程序中引入新的产品类型