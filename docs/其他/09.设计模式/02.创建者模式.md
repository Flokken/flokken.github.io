---
title: 创建者模式
date: 2023-12-27
tags: 
  - 设计模式
categories: 
  - 其他
  - 设计模式
---

**创建者模式提供创建对象的机制， 能够提升已有代码的灵活性和可复⽤性。**

创建者模式包括：⼯⼚⽅法、抽象⼯⼚、⽣成器、原型、单例，这5类。

## 工厂方法模式

工厂模式又称工厂方法模式，是一种创建新设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

> 工厂模式让子类去决定使用那个工厂类，使得创建对象的过程延迟到子类进行

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227162027818.png" alt="image-20231227162027818" style="zoom:67%;" />

### **场景**

多种类型商品不同接口，统一发奖服务

在营销场景中经常会有某个⽤户做了⼀些操作；打卡、分享、留⾔、邀请注册等等，进⾏返利积分，最 后通过积分在兑换商品，从⽽促活和拉新。 那么在这⾥我们模拟积分兑换中的发放多种类型商品，假如现在我们有如下三种类型的商品接⼝；

| 序 号 | 类型                | 接⼝                                                         |
| ----- | ------------------- | ------------------------------------------------------------ |
| 1     | 优惠券              | CouponResult sendCoupon(String uId, String couponNumber, String uuid) |
| 2     | 实物商品            | Boolean deliverGoods(DeliverReq req)                         |
| 3     | 第三⽅爱奇艺 兑换卡 | void grantToken(String bindMobileNumber, String cardId)      |

从以上接⼝来看有如下信息： 

- 三个接⼝返回类型不同，有对象类型、布尔类型、还有⼀个空类型。
-  ⼊参不同，发放优惠券需要仿᯿、兑换卡需要卡ID、实物商品需要发货位置(对象中含有)。 
- 另外可能会随着后续的业务的发展，会新增其他种商品类型。因为你所有的开发需求都是随着业务 对市场的拓展⽽带来的

### **实现**

我们可以用一坨的代码去实现，⼯程结构上⾮常简单，⼀个⼊参对象 AwardReq 、⼀个出参对象 AwardRes ，以及⼀个接⼝类 PrizeController

![image-20231227172714934](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227172714934.png)

然后把所有的if-else写在一起

```java
/**
 * 模拟发奖服务
 */
public class PrizeController {

    private Logger logger = LoggerFactory.getLogger(PrizeController.class);

    public AwardRes awardToUser(AwardReq req) {
        String reqJson = JSON.toJSONString(req);
        AwardRes awardRes = null;
        try {
            logger.info("奖品发放开始{}。req:{}", req.getuId(), reqJson);
            // 按照不同类型方法商品[1优惠券、2实物商品、3第三方兑换卡(爱奇艺)]
            if (req.getAwardType() == 1) {
                CouponService couponService = new CouponService();
                CouponResult couponResult = couponService.sendCoupon(req.getuId(), req.getAwardNumber(), req.getBizId());
                if ("0000".equals(couponResult.getCode())) {
                    awardRes = new AwardRes("0000", "发放成功");
                } else {
                    awardRes = new AwardRes("0001", couponResult.getInfo());
                }
            } else if (req.getAwardType() == 2) {
                GoodsService goodsService = new GoodsService();
                DeliverReq deliverReq = new DeliverReq();
                deliverReq.setUserName(queryUserName(req.getuId()));
                deliverReq.setUserPhone(queryUserPhoneNumber(req.getuId()));
                deliverReq.setSku(req.getAwardNumber());
                deliverReq.setOrderId(req.getBizId());
                deliverReq.setConsigneeUserName(req.getExtMap().get("consigneeUserName"));
                deliverReq.setConsigneeUserPhone(req.getExtMap().get("consigneeUserPhone"));
                deliverReq.setConsigneeUserAddress(req.getExtMap().get("consigneeUserAddress"));
                Boolean isSuccess = goodsService.deliverGoods(deliverReq);
                if (isSuccess) {
                    awardRes = new AwardRes("0000", "发放成功");
                } else {
                    awardRes = new AwardRes("0001", "发放失败");
                }
            } else if (req.getAwardType() == 3) {
                String bindMobileNumber = queryUserPhoneNumber(req.getuId());
                IQiYiCardService iQiYiCardService = new IQiYiCardService();
                iQiYiCardService.grantToken(bindMobileNumber, req.getAwardNumber());
                awardRes = new AwardRes("0000", "发放成功");
            }
            logger.info("奖品发放完成{}。", req.getuId());
        } catch (Exception e) {
            logger.error("奖品发放失败{}。req:{}", req.getuId(), reqJson, e);
            awardRes = new AwardRes("0001", e.getMessage());
        }

        return awardRes;
    }

    private String queryUserName(String uId) {
        return "花花";
    }

    private String queryUserPhoneNumber(String uId) {
        return "15200101232";
    }

}

```

> 暂时看来，这个代码没什么问题，但是如果迭代开发几轮，这代码就很麻烦了。重构成本⾼需要理清之前每⼀个接⼝的使⽤，测试回归验证时间⻓，需要全部验证⼀ 次。这也就是很多⼈并不愿意接⼿别⼈的代码，如果接⼿了⼜被压榨开发时间。那么可想⽽知这样 的 ifelse 还会继续增加。

**工厂模式优化代码**

工程结构

![image-20231227173153209](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227173153209.png)

我们将发奖这个行为抽象为一个接口，然后不同的奖品发放实现为不同的实现类。

```java
public interface ICommodity {
    void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception;
}

```

以优惠券为例

```java
package org.itstack.demo.design.store.impl;

public class CouponCommodityService implements ICommodity {

    private Logger logger = LoggerFactory.getLogger(CouponCommodityService.class);//我们发现Logger也是工厂模式实现的

    private CouponService couponService = new CouponService();

    public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
        CouponResult couponResult = couponService.sendCoupon(uId, commodityId, bizId);
        logger.info("请求参数[优惠券] => uId：{} commodityId：{} bizId：{} extMap：{}", uId, commodityId, bizId, JSON.toJSON(extMap));
        logger.info("测试结果[优惠券]：{}", JSON.toJSON(couponResult));
        if (!"0000".equals(couponResult.getCode())) throw new RuntimeException(couponResult.getInfo());
    }

}

```

**创建商店⼯⼚**

我们定义了⼀个商店的⼯⼚类，在⾥⾯按照类型实现各种商品的服务。可以⾮常⼲净整洁的处 理你的代码，后续新增的商品在这⾥扩展即可。

```java
public class StoreFactory {

    public ICommodity getCommodityService(Integer commodityType) {
        if (null == commodityType) return null;
        if (1 == commodityType) return new CouponCommodityService();
        if (2 == commodityType) return new GoodsCommodityService();
        if (3 == commodityType) return new CardCommodityService();
        throw new RuntimeException("不存在的商品服务类型");
    }

}
```

#### 测试

> 写⼀个单元测试来验证上⾯编写的接⼝⽅式，养成单元测试的好习惯会为你增强代码质量。

```java
public class ApiTest {

    @Test
    public void test_commodity() throws Exception {
        StoreFactory storeFactory = new StoreFactory();

        // 1. 优惠券
        ICommodity commodityService_1 = storeFactory.getCommodityService(1);
        commodityService_1.sendCommodity("10001", "EGM1023938910232121323432", "791098764902132", null);

        // 2. 实物商品
        ICommodity commodityService_2 = storeFactory.getCommodityService(2);
        Map<String,String> extMap = new HashMap<String,String>();
        extMap.put("consigneeUserName", "谢飞机");
        extMap.put("consigneeUserPhone", "15200292123");
        extMap.put("consigneeUserAddress", "吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109");

        commodityService_2.sendCommodity("10001","9820198721311","1023000020112221113",new HashMap<String, String>() {{
            put("consigneeUserName", "谢飞机");
            put("consigneeUserPhone", "15200292123");
            put("consigneeUserAddress", "吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109");
        }});

        // 3. 第三方兑换卡(爱奇艺)
        ICommodity commodityService_3 = storeFactory.getCommodityService(3);
        commodityService_3.sendCommodity("10001","AQY1xjkUodl8LO975GdfrYUio",null,null);

    }

}

```

测试结果

![image-20231227175030498](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227175030498.png)

### 总结

工厂模式的好处是：

- 避免创建者与具体的产品逻辑耦合
- 满足单一职责、每一个业务逻辑都在其所属类中完成
- 满足开闭原则，无需更改原有的代码，只需实现新的实现类，就可以在程序中引入新的产品类型

## 抽象工厂模式

抽象⼯⼚模式与⼯⼚⽅法模式虽然主要意图都是为了解决，接⼝选择问题。但在实现上**，抽象⼯⼚是⼀ 个中⼼⼯⼚，创建其他⼯⼚的模式。**

![image-20231227211549096](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227211549096.png)

举例

不同系统内的回⻋换⾏ 

1. Unix系统⾥，每⾏结尾只有 <换⾏>，即 \n ；
2. Windows系统⾥⾯，每⾏结尾是 <换⾏><回⻋>，即 \n\r ；
3.  Mac系统⾥，每⾏结尾是 <回⻋>

### 场景

![image-20231227211742728](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227211742728.png)

一开始可能由于预估 QPS较低 、 系统压⼒较⼩ 、 并发访问不⼤，所以我们直接用了单机的redis

但随着业务超过预期的快速发展，系统的负载能⼒也要随着跟上。原有的单机 Redis 已经满⾜不了系 统需求。这时候就需要更换为更为健壮的**Redis集群服务**，虽然需要修改但是不能影响⽬前系统的运 ⾏，还要平滑过渡过去。

随着这次的升级，可以预⻅的问题会有：

1. 很多服务⽤到了Redis需要⼀起升级到集群。 
1.  需要兼容集群A和集群B，便于后续的灾备。 
1.  两套集群提供的接⼝和⽅法各有差异，需要做适配。 
1. 不能影响到⽬前正常运⾏的系统。

模拟工程结构

![image-20231227212010561](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227212010561.png)

其中：

EGM是一个Redis集群的服务

IIR是另一个Redis集群的服务

RedisUtils是单机的redis服务



### 实现

**用ifelse 一坨·代码达成目的**

此时的实现⽅式并不会修改类结构图，也就是与上⾯给出的类层级关系⼀致。通过在接⼝中添加类型字 段区分当前使⽤的是哪个集群，来作为使⽤的判断。

![image-20231227212306455](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227212306455.png)

代码类似这样

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227212344928.png" alt="image-20231227212344928" style="zoom:80%;" />

**用抽象工厂模式重构**



这⾥的抽象⼯⼚的创建和获取⽅式，会采⽤代理类的⽅式进⾏实现。所被代理的类就是⽬前的Redis操 作⽅法类，让这个类在不需要任何修改下，就可以实现调⽤集群A和集群B的数据服务。

 并且这⾥还有⼀点⾮常重要，**由于集群A和集群B在部分⽅法提供上是不同的，因此需要做⼀个接⼝适 配，⽽这个适配类就相当于⼯⼚中的⼯⼚，⽤于创建把不同的服务抽象为统⼀的接⼝做相同的业务。**这 ⼀块与我们上⼀章节中的 工厂方法模型 类型，可以翻阅参考

工程项目结构如下：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227212533415.png" alt="image-20231227212533415" style="zoom: 67%;" />

抽象工厂设计结构

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227212611534.png" alt="image-20231227212611534" style="zoom:67%;" />

⼯程中涉及的部分核⼼功能代码，如下；

- ` ICacheAdapter` ，定义了适配接⼝，分别包装两个集群中差异化的接⼝名 称。 `EGMCacheAdapter` 、` IIRCacheAdapter `
- `JDKProxy` 、` JDKInvocationHandler` ，是代理类的定义和实现，这部分也就是抽象⼯⼚的 另外⼀种实现⽅式。通过这样的⽅式可以很好的把原有操作Redis的⽅法进⾏代理操作，通过 控制不同的⼊参对象，控制缓存的使⽤。



//TODO  把详细实现代码沾上来，感觉还挺有意义的



## 建造者模式

**建造者模式所完成的内容就是通过将多个简单对象通过⼀步步的组装构建出⼀个复杂对象的过程。**

比如我们要建造一个机器人，先装躯干，然后是手，头，脚等

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227215419225.png" alt="image-20231227215419225" style="zoom:67%;" />

### 场景

这⾥我们模拟装修公司对于设计出⼀些套餐装修服务的场景。

很多装修公司都会给出⾃家的套餐服务，⼀般有；欧式豪华、轻奢⽥园、现代简约等等，⽽这些套餐的 后⾯是不同的商品的组合。例如；⼀级&⼆级吊顶、多乐⼠涂料、圣象地板、⻢可波罗地砖等等，按照 不同的套餐的价格选取不同的品牌组合，最终再按照装修⾯积给出⼀个整体的报价。 这⾥我们就模拟装修公司想推出⼀些套餐装修服务，按照不同的价格设定品牌选择组合，以达到使⽤建 造者模式的过程。 

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227215952420.png" alt="image-20231227215952420" style="zoom: 80%;" />

在模拟⼯程中提供了装修中所需要的物料； ceilling(吊顶) 、 coat(涂料) 、 floor(地板) 、 tile(地砖) ，这么四项内容。



### 实现

if -else实现

这里我们依然通过方案编号，将这些方案实现再一个类里面

![image-20231227220213846](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227220213846.png)

>以上这段使⽤ ifelse ⽅式实现的 代码，⽬前已经满⾜的我们的也许功能。但随着⽼板对业务的快速发展要求，会提供很多的套餐针 对不同的户型。那么这段实现代码将迅速扩增到⼏千⾏，甚⾄在修修改改中，已经像膏药⼀样难以 维护。

**建造者模式重构**

![image-20231227220256540](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227220256540.png)

建造者模型结构

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227220321811.png" alt="image-20231227220321811" style="zoom:80%;" />

⼯程中有三个核⼼类和⼀个测试类，核⼼类是建造者模式的具体实现。与 ifelse 实现⽅式相⽐，多出 来了两个⼆外的类。具体功能如下:

1.Builder ，建造者类具体的各种组装由此类实现。 

2.DecorationPackageMenu ，是 IMenu 接⼝的实现类，主要是承载建造过程中的填充器。相当于 这是⼀套承载物料和创建者中间衔接的内容。 好，那么接下来会分别讲解⼏个类的具体实现。

//TODO粘贴具体实现代码