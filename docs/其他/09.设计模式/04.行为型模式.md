---
title: 行为型模式
date: 2023-01-01
tags: 
  - 设计模式
categories: 
  - 其他
  - 设计模式
---

## 策略模式

策略模式指的是定义了一系列算法，并将他们封装起来，使得他们可以互相替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，他通过对算法进行封装，把使用的算法的责任和算法的实现分割开，并让不同的对象对这些算法进行管理。

> 策略模式是一种行为模式，也是替代大量`ifelse`的利器。它所能帮你解决的是场景，一般是具有同类可替代的行为逻辑算法场景。比如；不同类型的交易方式(信用卡、支付宝、微信)、生成唯一ID策略(UUID、DB自增、DB+Redis、雪花算法、Leaf算法)等，都可以使用策略模式进行行为包装，供给外部使用。

### 场景模拟

**在本案例中我们模拟在购买商品时候使用的各种类型优惠券(满减、直减、折扣、n元购)**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/itstack-demo-design-20-03.png" alt="场景模拟；商品支付使用营销优惠券" style="zoom:80%;" />

这个场景几乎也是大家的一个日常购物省钱渠道，购买商品的时候都希望找一些优惠券，让购买的商品更加实惠。而且到了大促的时候就会有更多的优惠券需要计算那些商品一起购买更加优惠！！！

这样的场景有时候用户用起来还是蛮爽的，但是最初这样功能的设定以及产品的不断迭代，对于程序员👨‍💻‍开发还是不太容易的。**因为这里包括了很多的规则和优惠逻辑，所以我们模拟其中的一个计算优惠的方式，使用策略模式来实现。**

我们用传统的面向过程开发

```java
/**
 * 博客：https://bugstack.cn - 沉淀、分享、成长，让自己和他人都能有所收获！
 * 公众号：bugstack虫洞栈
 * Create by 小傅哥(fustack) @2020
 * 优惠券折扣计算接口
 * <p>
 * 优惠券类型；
 * 1. 直减券
 * 2. 满减券
 * 3. 折扣券
 * 4. n元购
 */
public class CouponDiscountService {

    public double discountAmount(int type, double typeContent, double skuPrice, double typeExt) {
        // 1. 直减券
        if (1 == type) {
            return skuPrice - typeContent;
        }
        // 2. 满减券
        if (2 == type) {
            if (skuPrice < typeExt) return skuPrice;
            return skuPrice - typeContent;
        }
        // 3. 折扣券
        if (3 == type) {
            return skuPrice * typeContent;
        }
        // 4. n元购
        if (4 == type) {
            return typeContent;
        }
        return 0D;
    }

}

```

- 以上是不同类型的优惠券计算折扣后的实际金额。
- 入参包括；优惠券类型、优惠券金额、商品金额，因为有些优惠券是满多少减少多少，所以增加了`typeExt`类型。这也是方法的不好扩展性问题。
- 最后是整个的方法体中对优惠券抵扣金额的实现，最开始可能是一个最简单的优惠券，后面随着产品功能的增加，不断的扩展`if`语句。实际的代码可能要比这个多很多

### 策略模式重构

工程结构

```java
itstack-demo-design-20-02
└── src
    └── main
        └── java
            └── org.itstack.demo.design
                ├── event
                │    └── MJCouponDiscount.java
                │    └── NYGCouponDiscount.java
                │    └── ZJCouponDiscount.java
                │    └── ZKCouponDiscount.java
                ├── Context.java
                └── ICouponDiscount.java

```

整体结构

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240101135830523.png" alt="image-20240101135830523" style="zoom:67%;" />

- 整体的结构模式并不复杂，主要体现的不同类型的优惠券在计算优惠券方式的不同计算策略。
- 这里包括一个接口类(`ICouponDiscount`)以及四种优惠券类型的实现方式。
- 最后提供了策略模式的上下控制类处理，整体的策略服务。

**优惠券接口**

```java
public interface ICouponDiscount<T> {

    /**
     * 优惠券金额计算
     * @param couponInfo 券折扣信息；直减、满减、折扣、N元购
     * @param skuPrice   sku金额
     * @return           优惠后金额
     */
    BigDecimal discountAmount(T couponInfo, BigDecimal skuPrice);

}

```

- 定义了优惠券折扣接口，也增加了泛型用于不同类型的接口可以传递不同的类型参数。
- 接口中包括商品金额以及出参返回最终折扣后的金额，这里在实际开发中会比现在的接口参数多一些，但核心逻辑是这些。

####  接口实现类

满减

```java
public class MJCouponDiscount implements ICouponDiscount<Map<String,String>>  {

    /**
     * 满减计算
     * 1. 判断满足x元后-n元，否则不减
     * 2. 最低支付金额1元
     */
    public BigDecimal discountAmount(Map<String,String> couponInfo, BigDecimal skuPrice) {
        String x = couponInfo.get("x");
        String o = couponInfo.get("n");

        // 小于商品金额条件的，直接返回商品原价
        if (skuPrice.compareTo(new BigDecimal(x)) < 0) return skuPrice;
        // 减去优惠金额判断
        BigDecimal discountAmount = skuPrice.subtract(new BigDecimal(o));
        if (discountAmount.compareTo(BigDecimal.ZERO) < 1) return BigDecimal.ONE;

        return discountAmount;
    }
}

```

直减

```java
public class ZJCouponDiscount implements ICouponDiscount<Double>  {

    /**
     * 直减计算
     * 1. 使用商品价格减去优惠价格
     * 2. 最低支付金额1元
     */
    public BigDecimal discountAmount(Double couponInfo, BigDecimal skuPrice) {
        BigDecimal discountAmount = skuPrice.subtract(new BigDecimal(couponInfo));
        if (discountAmount.compareTo(BigDecimal.ZERO) < 1) return BigDecimal.ONE;
        return discountAmount;
    }

}

```

折扣

```java
public class ZKCouponDiscount implements ICouponDiscount<Double> {


    /**
     * 折扣计算
     * 1. 使用商品价格乘以折扣比例，为最后支付金额
     * 2. 保留两位小数
     * 3. 最低支付金额1元
     */
    public BigDecimal discountAmount(Double couponInfo, BigDecimal skuPrice) {
        BigDecimal discountAmount = skuPrice.multiply(new BigDecimal(couponInfo)).setScale(2, BigDecimal.ROUND_HALF_UP);
        if (discountAmount.compareTo(BigDecimal.ZERO) < 1) return BigDecimal.ONE;
        return discountAmount;
    }

}

```

N元购

~~~java
public class NYGCouponDiscount implements ICouponDiscount<Double> {

    /**
     * n元购购买
     * 1. 无论原价多少钱都固定金额购买
     */
    public BigDecimal discountAmount(Double couponInfo, BigDecimal skuPrice) {
        return new BigDecimal(couponInfo);
    }

}

~~~

#### 策略控制类

```java
public class Context<T> {

    private ICouponDiscount<T> couponDiscount;

    public Context(ICouponDiscount<T> couponDiscount) {
        this.couponDiscount = couponDiscount;
    }

    public BigDecimal discountAmount(T couponInfo, BigDecimal skuPrice) {
        return couponDiscount.discountAmount(couponInfo, skuPrice);
    }

}

```

- 策略模式的控制类主要是外部可以传递不同的策略实现，在通过统一的方法执行优惠策略计算。
- 另外这里也可以包装成map结构，让外部只需要对应的泛型类型即可使用相应的服务。

###  测试

这里以满减优惠为例

```java
@Test
public void test_mj() {
    // 满100减10，商品100元
    Context<Map<String,String>> context = new Context<Map<String,String>>(new MJCouponDiscount());
    //要采用哪个算法，就用哪个算法的实现类去实例化这个接口，这里其实也是由于泛型和接口的支撑，才能有这些设计模式
    Map<String,String> mapReq = new HashMap<String, String>();
    mapReq.put("x","100");
    mapReq.put("n","10");
    BigDecimal discountAmount = context.discountAmount(mapReq, new BigDecimal(100));
    logger.info("测试结果：满减优惠后金额 {}", discountAmount);
}

//output

15:43:42.695 [main] INFO  org.itstack.demo.design.test.ApiTest - 测试结果：满减优惠后金额 90

Process finished with exit code 0

```

总结：

- 以上的策略模式案例相对来说不并不复杂，主要的逻辑都是体现在关于不同种类优惠券的计算折扣策略上。结构相对来说也比较简单，在实际的开发中这样的设计模式也是非常常用的。另外这样的设计与命令模式、适配器模式结构相似，但是思路是有差异的。
- 通过策略设计模式的使用可以把我们方法中的if语句优化掉，大量的if语句使用会让代码难以扩展，也不好维护，同时在后期遇到各种问题也很难维护。在使用这样的设计模式后可以很好的满足隔离性与和扩展性，对于不断新增的需求也非常方便承接。
- `策略模式`、`适配器模式`、`组合模式`等，在一些结构上是比较相似的，但是每一个模式是有自己的逻辑特点，在使用的过程中最佳的方式是经过较多的实践来吸取经验，为后续的研发设计提供更好的技术输出。