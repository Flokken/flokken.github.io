---
title: 结构型模式
date: 2023-12-28
tags: 
  - 设计模式
categories: 
  - 其他
  - 设计模式

---

## 适配器模式

> Adapter

适配器模式的主要作⽤就是把原本不兼容的接⼝，通过适配修改做到统⼀，方便用户进行使用。就像我 们提到的万能充、数据线、MAC笔记本的转换头。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231228172146685.png" alt="image-20231228172146685" style="zoom: 67%;" />

### 场景

模拟多个MQ消息体，用统一接口接入他们

背景：

随着公司的业务的不断发展，当基础的系统逐步成型以后。业务运营就需要开始做⽤户的拉新和促活， 从⽽保障 DUA 的增速以及最终 ROI 转换。 ⽽这时候就会需要做⼀些营销系统，大部分常见的都是裂变、拉客，例如；你邀请⼀个⽤户开户、或者 邀请⼀个⽤户下单，那么平台就会给你返利，多邀多得。

同时随着拉新的量越来越多开始设置每⽉下单 都会给首单奖励，等等，各种营销场景。 那么这个时候做这样⼀个系统就会接收各种各样的MQ消息或者接口，如果⼀个个的去开发，就会耗费 很⼤的成本，同时对于后期的拓展也有⼀定的难度。

**此时就会希望有⼀个系统可以配置⼀下就把外部的 MQ接⼊进⾏，这些MQ就像上⾯提到的可能是⼀些注册开户消息、商品下单消息等等**

> 适配器不仅用于适配接口，也可以适配属性等等

场景模拟工程

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231228172818605.png" alt="image-20231228172818605" style="zoom:67%;" />

其中

- 这里模拟了三个不同类型的MQ消息，而在消息体中都有一些必要的字段，比如；用户ID、时间、业务ID，但是每个MQ的字段属性并不一样。就像用户ID在不同的MQ里也有不同的字段：uId、userId等。
- 同时还提供了两个不同类型的接口，一个用于查询内部订单订单下单数量，一个用于查询第三方是否首单。
- 后面会把这些不同类型的MQ和接口做适配兼容

我们接下来也是先体现一下这种方式的实现模拟，但是这样的实现有一个很大的问题就是，当MQ消息越来越多后，甚至几十几百以后，你作为中台要怎么优化呢？

**一坨代码实现**

>其实大部分时候接MQ消息都是创建一个类用于消费，通过转换他的MQ消息属性给自己的方法。

如果我们没有什么好想法，那么直接对于三个不同的MQ消息类，我们就给他对应三个消息处理的类。

> 这样当然可以，但是如果MQ类越来越多，就不太好了

 工程结构

```java
itstack-demo-design-6-01
└── src
    └── main
        └── java
            └── org.itstack.demo.design
                └── create_accountMqService.java
                └── OrderMqService.java
                └── POPOrderDeliveredService.java
```

目前需要接收三个MQ消息，所有就有了三个对应的类，和我们平时的代码几乎一样。如果你的MQ量不多，这样的写法也没什么问题，但是随着数量的增加，就需要考虑用一些设计模式来解决。

以其中一个为例

```java
public class create_accountMqService {

    public void onMessage(String message) {

        create_account mq = JSON.parseObject(message, create_account.class);

        mq.getNumber();
        mq.getAccountDate();

        // ... 处理自己的业务
    }

}
 
```

其他两个也差不多。

## 适配器模式重构代码

适配器模式要解决的主要问题就是多种差异化类型的接⼝做统⼀输出，这在我们学习⼯⼚⽅法模式中也 有所提到不同种类的奖品处理，其实那也是适配器的应⽤。 在本⽂中我们还会再另外体现出⼀个多种MQ接收，使⽤MQ的场景。来把不同类型的消息做统⼀的处 理，便于减少后续对MQ接收。

在这⾥如果你之前没要开发过接收MQ消息，可能听上去会有些不理解这样的场景。对此，我个⼈建议 先了解下MQ。另外就算不了解也没关系，不会影响对思路的体会。

再者，本⽂所展示的MQ兼容的核⼼部分，也就是处理适配不同的类型字段。⽽如果我们接收MQ后，在 配置不同的消费类时，如果不希望⼀个个开发类，那么可以使⽤代理类的⽅式进⾏处理。

```java
itstack-demo-design-6-02
└── src
    └── main
        └── java
            └── org.itstack.demo.design
                ├── impl
                │   ├── InsideOrderService.java
                │   └── POPOrderAdapterServiceImpl.java
                ├── MQAdapter,java
                ├── OrderAdapterService,java
                └── RebateInfo,java

```

- 这里包括了两个类型的适配；接口适配、MQ适配。之所以不只是模拟接口适配，因为很多时候大家都很常见了，所以把适配的思想换一下到MQ消息体上，增加大家多设计模式的认知。
- **先是做MQ适配**，接收各种各样的MQ消息。当业务发展的很快，需要对下单用户首单才给奖励，在这样的场景下再增加对**接口的适配**操作。

###  

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231228182133552.png" alt="image-20231228182133552" style="zoom: 80%;" />

#### 统一的MQ消息体

```java
public class RebateInfo {

    private String userId;  // 用户ID
    private String bizId;   // 业务ID
    private Date bizTime;   // 业务时间
    private String desc;    // 业务描述
    
    // ... get/set
}
 
        @小傅哥: 代码已经复制到剪贴板
    
```

- MQ消息中会有多种多样的类型属性，虽然他们都有同样的值提供给使用方，但是如果都这样接入那么当MQ消息特别多时候就会很麻烦。
- 所以在这个案例中我们定义了通用的MQ消息体，后续把所有接入进来的消息进行统一的处理

#### MQ消息体适配类

```java
public class MQAdapter {

    public static RebateInfo filter(String strJson, Map<String, String> link) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        return filter(JSON.parseObject(strJson, Map.class), link);
    }

    public static RebateInfo filter(Map obj, Map<String, String> link) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        RebateInfo rebateInfo = new RebateInfo();
        for (String key : link.keySet()) {
            Object val = obj.get(link.get(key));
            RebateInfo.class.getMethod("set" + key.substring(0, 1).toUpperCase() + key.substring(1), String.class).invoke(rebateInfo, val.toString());
        }
        return rebateInfo;
    }

}

```

- 这个类里的方法非常重要，主要用于把不同类型MQ种的各种属性，映射成我们需要的属性并返回。就像一个属性中有`用户ID;uId`，映射到我们需要的；`userId`，做统一处理。
- 而在这个处理过程中需要把映射管理传递给`Map<String, String> link`，也就是准确的描述了，当前MQ中某个属性名称，映射为我们的某个属性名称。
- 最终因为我们接收到的`mq`消息基本都是`json`格式，可以转换为MAP结构。最后使用反射调用的方式给我们的类型赋值。

#### 接口使用适配

就像我们前面提到随着业务的发展，营销活动本身要修改，不能只是接了MQ就发奖励。因为此时已经拉新的越来越多了，需要做一些限制。

因为增加了只有首单用户才给奖励，也就是你一年或者新人或者一个月的第一单才给你奖励，而不是你之前每一次下单都给奖励。

那么就需要对此种方式进行限制，而此时MQ中并没有判断首单的属性。只能通过接口进行查询，而拿到的接口如下；

| 接口                                                         | 描述                      |
| ------------------------------------------------------------ | ------------------------- |
| org.itstack.demo.design.service.OrderService.queryUserOrderCount(String userId) | 出参long，查询订单数量    |
| org.itstack.demo.design.service.OrderService.POPOrderService.isFirstOrder(String uId) | 出参boolean，判断是否首单 |

- 两个接口的判断逻辑和使用方式都不同，不同的接口提供方，也有不同的出参。一个是直接判断是否首单，另外一个需要根据订单数量判断。
- 因此这里需要使用到适配器的模式来实现，当然如果你去编写if语句也是可以实现的，但是我们经常会提到这样的代码很难维护。

####  定义统一适配接口

```java
public interface OrderAdapterService {

    boolean isFirst(String uId);

}

```

>后面的实现类都需要完成此接口，并把具体的逻辑包装到指定的类中，满足单一职责。

####  分别实现两个不同的接口

内部商品接口

```java
public class InsideOrderService implements OrderAdapterService {

    private OrderService orderService = new OrderService();

    public boolean isFirst(String uId) {
        return orderService.queryUserOrderCount(uId) <= 1;
    }

}

```

第三方商品接口

```java
public class POPOrderAdapterServiceImpl implements OrderAdapterService {

    private POPOrderService popOrderService = new POPOrderService();

    public boolean isFirst(String uId) {
        return popOrderService.isFirstOrder(uId);
    }

}

```

- 在这两个接口中都实现了各自的判断方式，尤其像是提供订单数量的接口，需要自己判断当前接到mq时订单数量是否`<= 1`，以此判断是否为首单。

 **测试**

```java
@Test
public void test_itfAdapter() {
    OrderAdapterService popOrderAdapterService = new POPOrderAdapterServiceImpl();
    System.out.println("判断首单，接口适配(POP)：" + popOrderAdapterService.isFirst("100001"));   

    OrderAdapterService insideOrderService = new InsideOrderService();
    System.out.println("判断首单，接口适配(自营)：" + insideOrderService.isFirst("100001"));
}

```

结果

```java
23:25:47.076 [main] INFO  o.i.d.design.service.POPOrderService - POP商家，查询用户的订单是否为首单：100001
判断首单，接口适配(POP)：true
23:25:47.079 [main] INFO  o.i.d.design.service.POPOrderService - 自营商家，查询用户的订单是否为首单：100001
判断首单，接口适配(自营)：false

Process finished with exit code 0

```

- 从测试结果上来看，此时已经的接口已经做了统一的包装，外部使用时候就不需要关心内部的具体逻辑了。而且在调用的时候只需要传入统一的参数即可，这样就满足了适配的作用。

### 总结

- 从上文可以看到不使用适配器模式这些功能同样可以实现，但是使用了适配器模式就可以让代码：干净整洁易于维护、减少大量重复的判断和使用、让代码更加易于维护和拓展。
- **尤其是我们对MQ这样的多种消息体中不同属性同类的值，进行适配再加上代理类**，就可以使用简单的配置方式接入对方提供的MQ消息，而不需要大量重复的开发。非常利于拓展。
- 设计模式的学习过程可能会在一些章节中涉及到其他设计模式的体现，只不过不会重点讲解，避免喧宾夺主。但在实际的使用中，往往很多设计模式是综合使用的，并不会单一出现。

