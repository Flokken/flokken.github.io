---
title: 刷LeetCode时java的常用方法
date: 2023-12-06
tags: 
  - STL
categories:  
  - 算法
  - leetcode
---

> 参考：[jdk在线文档](https://www.matools.com/api/java8)

这里注意记录一些刷leetcode时java常用的方法，免得到处搜。

## 新特性

### 不可变集合

> https://blog.csdn.net/hdakj22/article/details/129396820

**不可变集合：** **不可以被修改的集合**。

- 不能修改长度
- 不能修改内容

有一些题目，我们需要定义一些转换，就可以利用不可变集合。

  **在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合。**

```java
MAp<Character,Integer>map=Map.of("Hello", 1, "World", 2);//不可变集合
Set<String> set = Set.of("张三","李四","王五","赵六");
List<String> stringList = List.of("a", "b", "c");
```

**注意，map不能超过10个键值对，也就是20个元素，超过则报错。**

> map:元素不能重复、键值对数量最多是10个，超过10个用ofEntries方法。

## Map

1.初始化并赋值，java8

```java
HashMap<String, String > myMap  = new HashMap<String, String>(){{  
      put("a","b");  
      put("b","b");       
}};  //第一层大括号，匿名内部类
//第二层大括号，匿名内部类初始化块

```

2.遍历一个String[]数组words，并且统计String出现次数

```java
 for(String s:words){
            map.put(s,map.getOrDefault(s,0)+1);//注意这种写法，经常用到
}
```

3.内部Pair节点

```java
 Class Pair{
        int index;
        double value;
        //构造函数参数列表初始化
           Pair(int index, double value) {
        this.index = index;
        this.value = value;
        }
    }   
```

>**注意java没有构造函数参数列表初始化！！！**        `Pair(int in,double va):index(index),value(va);`,
>
>老老实实赋值！构造函数

常用方法

| 方法名                              | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| V put(K key,V value)                | 添加元素                                                     |
| V get(K key)                        | 根据key返回value，不存在返回null                             |
| V remove(Object key)                | 根据键删除键值对元素                                         |
| void clear()                        | 移除所有的键值对元素                                         |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键                                     |
| boolean containsValue(Object value) | 判断集合是否包含指定的值                                     |
| **V getOrDefault(key, default)**    | 如果有key，根据key返回value，如果没有对应键值对，返回default |
| List values()                       | 返回所有的values组成的列表                                   |
| boolean isEmpty()                   | 判断集合是否为空                                             |
| int size()                          | 集合的长度，也就是集合中键值对的个数                         |

## List

1.List初始化，如果带值，可以用Arrays.asList()

```java
List<String> stringList = Arrays.asList("a", "b", "c");
```

## 数组

初始化并赋值

```java
int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
```

## String

### 常见名词

字母异位词：也就是重排。重排的特点是单词排序后显然是相同的

单射，满射和双射：https://leetcode.cn/problems/isomorphic-strings/solutions/1645867/by-jyd-i4wt



### 常用方法

| 方法名                                     | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| int length()                               | 返回字符串长度                                               |
| byte[] getBytes()                          | 转换字符串内容为byte[]数组，可作为String构造方法参数         |
| char[] toCharArray()                       | 转换字符串内容为char[]数组，可作为String构造方法参数         |
| **boolean equals(str1,str2)**              | 比较**字符串内容**是否相等并返回，返回值为 **boolean** 类型  |
| **boolean contains(CharSequence)**         | 参数CharSequence 为一个接口，CharSequence 是 char 值的可读序列，参数可以为String、StringBuilder、StringBuffer等类型 |
| **char charAt(int index)**                 | 用于返回字符串指定位置的字符，返回值为 **char** 类型，参数为 **int** 类型 |
| String trim()                              | 返回去掉前导和尾随空白的字符串，返回值为 **String** 类型     |
| String toUpperCase()与String toLowerCase() | 返回字符串的大写形式或者小写形式                             |
| **String[] split(String regex)**           | 参数regex为正则表达式（比如空格），以regex所表示的字符串为分隔符，将字符串拆分成字符串数组 |
| **String substring(.....)**                | 返回子串，有两种重载                                         |
| boolean isEmpty()                          | 判断字符串是否为空，返回值为 **boolean** 类型，查看该方法的源码可知字符串的 length 为0则为空 |

注意：

1 isEmpty() 方法：判断字符串是否为空，返回值为 boolean 类型，查看该方法的源码可知字符串的 length 为0则为空

2.substring，注意返回范围是左闭右开的

- substring(int beginIndex, int endIndex) 方法：**返回字符串中从下标 beginIndex(包括) 开始到 endIndex(不包括) 结束的子字符串**，返回值为 String 类型，参数为 int 类型
- substring(int beginIndex) 方法：**返回字符串中从下标 beginIndex(包括) 开始到字符串结尾的子字符串**，返回值为 String 类型，参数为 int 类型
- 举例，  substring(1,4),实际上截取[1,3],如果所以j可以等于string.length,有时候这很有用

3.split，注意这里的字符串regex，是字符串，所以应该是`""`,而不是`''`

### StringBuilder

**初始化**

```java
String result = new StringBuilder();
```

**常用方法**

| 方法名                                | 说明                                          |
| ------------------------------------- | --------------------------------------------- |
| public StringBuilder append(任意类型) | 添加数据，并返回对象本身                      |
| public StringBuilder reverse()        | 反转容器中内容                                |
| public int length()                   | 返回长度（字符个数）                          |
| public String toString()              | 通过toString()可以把StringBuilder转换成String |

## Queue



### Deque

java里用双端队列来模拟栈，stack已经弃用

Deque是一个接口，其定义如下

- `public interface **Deque<E>**extends Queue<E>`

>一个线性 collection，支持在两端插入和移除元素。名称 *deque* 是“double ended  queue（双端队列）”的缩写，通常读为“deck”。大多数 `Deque`  实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 

此接口扩展了 Queue接口。在将双端队列用作队列时，将得到  FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 `Queue` 接口继承的方法完全等效于  `Deque` 方法，如下表所示： 

| **`Queue` 方法** | **等效 `Deque` 方法** |
| ---------------- | --------------------- |
| add(e)           | addLast(e)            |
| offer(e)         | offerLast(e)          |
| remove()         | removeFirst()         |
| poll()           | pollFirst()           |
| element()        | getFirst()            |
| peek()           | peekFirst()           |

**双端队列也可用作 LIFO（后进先出）堆栈**,堆栈方法完全等效于 `Deque` 方法，如下表所示： 

| **堆栈方法** | **等效 `Deque` 方法** |
| ------------ | --------------------- |
| push(e)      | addFirst(e)           |
| pop()        | removeFirst()         |
| peek()       | peekFirst()           |
### 字符串数组

我们很多时候为了方便操作，会将字符串转换为字符串数组再来操作（特别是输入只包括大小写字符和字符数字这些简单的情况）。

### 容易出错的坑

1.==和equals（犯过好几次了，谨记！）

java中，==运算符可以用来判断基本数据类型的变量是否相等，但是对于引用类型的变量（**比如字符串**），比较的是他们的地址。

所以对于引用类型不能用==，要用其引用类型提供的`equals`方法。

> 所以我们新建一个类，如果要比较这个类的对象也要自己重写equals方法。因为默认的equals就是用==直接比较，这肯定是不对的
>
> ```java
> public boolean equals(Object obj) {
>     return (this == obj);
> }
> ```

## Arrays



## Collectons
