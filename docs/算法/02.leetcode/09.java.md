---
title: 刷LeetCode时java的常用方法
date: 2023-12-06
tags: 
  - STL
categories:  
  - 算法
  - leetcode
---

这里注意记录一些刷leetcode时java常用的方法，免得到处搜。

## 新特性

### 不可变集合

> https://blog.csdn.net/hdakj22/article/details/129396820

**不可变集合：** **不可以被修改的集合**。

- 不能修改长度
- 不能修改内容

有一些题目，我们需要定义一些转换，就可以利用不可变集合。

  **在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合。**

```java
MAp<Character,Integer>map=Map.of("Hello", 1, "World", 2);//不可变集合
Set<String> set = Set.of("张三","李四","王五","赵六");
List<String> stringList = List.of("a", "b", "c");
```

**注意，map不能超过10个键值对，也就是20个元素，超过则报错。**

> map:元素不能重复、键值对数量最多是10个，超过10个用ofEntries方法。

## Map

初始化并赋值，java8

```java
HashMap<String, String > myMap  = new HashMap<String, String>(){{  
      put("a","b");  
      put("b","b");       
}};  //第一层大括号，匿名内部类
//第二层大括号，匿名内部类初始化块

```

常用方法

| 方法名                              | 说明                                 |
| ----------------------------------- | ------------------------------------ |
| V put(K key,V value)                | 添加元素                             |
| V remove(Object key)                | 根据键删除键值对元素                 |
| void clear()                        | 移除所有的键值对元素                 |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |
| boolean containsValue(Object value) | 判断集合是否包含指定的值             |
| boolean isEmpty()                   | 判断集合是否为空                     |
| int size()                          | 集合的长度，也就是集合中键值对的个数 |

## List

1.List初始化，如果带值，可以用Arrays.asList()

```java
List<String> stringList = Arrays.asList("a", "b", "c");
```

## 数组

初始化并赋值

```java
int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
```

## String

常用方法

### 常用方法

| 方法名                                     | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| int length()                               | 返回字符串长度                                               |
| byte[] getBytes()                          | 转换字符串内容为byte[]数组，可作为String构造方法参数         |
| char[] toCharArray()                       | 转换字符串内容为char[]数组，可作为String构造方法参数         |
| **boolean equals(str1,str2)**              | 比较**字符串内容**是否相等并返回，返回值为 **boolean** 类型  |
| **boolean contains(CharSequence)**         | 参数CharSequence 为一个接口，CharSequence 是 char 值的可读序列，参数可以为String、StringBuilder、StringBuffer等类型 |
| **char charAt(int index)**                 | 用于返回字符串指定位置的字符，返回值为 **char** 类型，参数为 **int** 类型 |
| String trim()                              | 返回去掉前导和尾随空白的字符串，返回值为 **String** 类型     |
| String toUpperCase()与String toLowerCase() | 返回字符串的大写形式或者小写形式                             |
| **String[] split(String regex)**           | 参数regex为正则表达式，以regex所表示的字符串为分隔符，将字符串拆分成字符串数组 |
| **String substring(.....)**                | 返回子串，有两种重载                                         |
| boolean isEmpty()                          | 判断字符串是否为空，返回值为 **boolean** 类型，查看该方法的源码可知字符串的 length 为0则为空 |

注意：

1 isEmpty() 方法：判断字符串是否为空，返回值为 boolean 类型，查看该方法的源码可知字符串的 length 为0则为空

2.substring，注意返回范围是左闭右开的

- substring(int beginIndex, int endIndex) 方法：**返回字符串中从下标 beginIndex(包括) 开始到 endIndex(不包括) 结束的子字符串**，返回值为 String 类型，参数为 int 类型
- substring(int beginIndex) 方法：**返回字符串中从下标 beginIndex(包括) 开始到字符串结尾的子字符串**，返回值为 String 类型，参数为 int 类型
- 举例，  substring(1,4),实际上截取[1,3],如果所以j可以等于string.length,有时候这很有用

### StringBuilder

**初始化**

```java
String result = new StringBuilder();
```

**常用方法**

| 方法名                                | 说明                                          |
| ------------------------------------- | --------------------------------------------- |
| public StringBuilder append(任意类型) | 添加数据，并返回对象本身                      |
| public StringBuilder reverse()        | 反转容器中内容                                |
| public int length()                   | 返回长度（字符个数）                          |
| public String toString()              | 通过toString()可以把StringBuilder转换成String |

## Queue



### Deque

java里用双端队列来模拟栈，stack已经弃用

Deque是一个接口，其定义如下

- `public interface **Deque<E>**extends Queue<E>`

>一个线性 collection，支持在两端插入和移除元素。名称 *deque* 是“double ended  queue（双端队列）”的缩写，通常读为“deck”。大多数 `Deque`  实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 

此接口扩展了 Queue接口。在将双端队列用作队列时，将得到  FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 `Queue` 接口继承的方法完全等效于  `Deque` 方法，如下表所示： 

| **`Queue` 方法** | **等效 `Deque` 方法** |
| ---------------- | --------------------- |
| add(e)           | addLast(e)            |
| offer(e)         | offerLast(e)          |
| remove()         | removeFirst()         |
| poll()           | pollFirst()           |
| element()        | getFirst()            |
| peek()           | peekFirst()           |

**双端队列也可用作 LIFO（后进先出）堆栈**,堆栈方法完全等效于 `Deque` 方法，如下表所示： 

| **堆栈方法** | **等效 `Deque` 方法** |
| ------------ | --------------------- |
| push(e)      | addFirst(e)           |
| pop()        | removeFirst()         |
| peek()       | peekFirst()           |
