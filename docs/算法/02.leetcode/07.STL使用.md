---
title: STL使用
date: 2023-08-30
tags: 
  - STL
categories:  
  - 算法
  - leetcode
---

主要是方法和函数的使用，为了刷算法题而使用，并不涉及源码。

> 资料来源于[C语言中文网STL教程](http://m.biancheng.net/view/6675.html)
>
> 由于主要后面工作使用java，所以放弃stl，用java刷题去了。。。。

## STL介绍

通常认为，[STL](http://m.biancheng.net/stl/) 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的。

| STL的组成  | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| 容器       | 一些封装[数据结构](http://m.biancheng.net/data_structure/)的模板类，例如 vector 向量容器、list 列表容器等。 |
| 算法       | STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件` <algorithm>` 中，少部分位于头文件 `<numeric>` 中。 |
| 迭代器     | 在 [C++](http://m.biancheng.net/cplus/) STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。 |
| 函数对象   | 如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 |
| 适配器     | 可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 |
| 内存分配器 | 为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 |

### STL容器

简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。STL 提供有 3 类标准容器，分别是**序列容器、排序容器和哈希容器**，其中后两类容器有时也统称为**关联容器**。

<center>表 容器分类</center>

| 容器种类 | 功能                                                         |
| -------- | ------------------------------------------------------------ |
| 序列容器 | 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。 |
| 排序容器 | 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。**排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置**。所以关联容器在查找时具有非常好的性能。 |
| 哈希容器 | [C++](http://m.biancheng.net/cplus/) 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 |

>注意，由于哈希容器直到 C++ 11 才被正式纳入 C++ 标准程序库，而在此之前，“民间”流传着 hash_set、hash_multiset、hash_map、hash_multimap 版本，不过该版本只能在某些支持 C++ 11 的编译器下使用（如 VS），有些编译器（如 gcc/g++）是不支持的。
>
>机试用到序列容器和排序容器就OK了，一般也用不到C++11

### 迭代器

无论是序列容器还是关联容器，**最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器**（iterator）”来实现。那么，迭**代器到底是什么呢？**

尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。

既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，**它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。**

这是泛型思维发展的必然结果，于是迭代器就产生了。**简单来讲，迭代器和 [C++](http://m.biancheng.net/cplus/) 的[指针](http://m.biancheng.net/c/80/)非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。**

常用的迭代器按功能强弱分为输入迭代器、输出迭代器、**前向迭代器、双向迭代器、随机访问迭代器 5 种。主要关注后面这 3 种迭代器。**

>输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。有关这 2 个迭代器，我们会在后续章节做详细介绍。

#### 分类

**1 前向迭代器（forward iterator）**
假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个前向迭代器可以互相赋值。

**2 双向迭代器（bidirectional iterator）**
双向迭代器具有前向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（**即一次向后移动一个位置**）。

**3 随机访问迭代器（random access iterator**）
随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：

- p+=i：使得 p 往后移动 i 个元素。
- p-=i：使得 p 往前移动 i 个元素。
- p+i：返回 p 后面第 i 个元素的迭代器。
- p-i：返回 p 前面第 i 个元素的迭代器。
- **p[i]：返回 p 后面第 i 个元素的引用。**这个很常用，比如vector直接用下标访问


此外，两个随机访问迭代器 p1、p2 还可以用 <、>、<=、>= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）

<center>表 C++11标准中容器支持的迭代器</center>

| 容器                               | 对应的迭代器类型 |
| ---------------------------------- | ---------------- |
| array                              | 随机访问迭代器   |
| vector                             | 随机访问迭代器   |
| deque                              | 随机访问迭代器   |
| list                               | 双向迭代器       |
| set / multiset                     | 双向迭代器       |
| map / multimap                     | 双向迭代器       |
| forward_list                       | 前向迭代器       |
| unordered_map / unordered_multimap | 前向迭代器       |
| unordered_set / unordered_multiset | 前向迭代器       |
| stack                              | 不支持迭代器     |
| queue                              | 不支持迭代器     |

尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如表 1 所示。

#### 定义方式

| 迭代器定义方式 | 具体格式                                   |
| -------------- | ------------------------------------------ |
| 正向迭代器     | 容器类名::iterator 迭代器名;               |
| 常量正向迭代器 | 容器类名::const_iterator 迭代器名;         |
| 反向迭代器     | 容器类名::reverse_iterator 迭代器名;       |
| 常量反向迭代器 | 容器类名::const_reverse_iterator 迭代器名; |

> 值得一提的是，表 2 中的反向迭代器全称为 "反向迭代器适配器"，后续章节会做详细讲解，这里读者只需要知道其用法即可。

通过定义以上几种迭代器，就可以读取它指向的元素，`*迭代器名`就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：

- 对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；
- 而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。

> 注意，虽然迭代器定义方式一样，但是容器支持的迭代器类型不一样，其就是支持的操作不一样

先以vector为例，vector支持随机访问迭代器，因此可以支持迭代器的所有操作,

~~~C++
//遍历 vector 容器
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> v={1,2,3,4,5,6,7,8,9,10}; //v被初始化成有10个元素
    
    cout << "第一种遍历方法：" << endl;
    //size返回元素个数
    for (int i = 0; i < v.size(); ++i)
        cout << v[i] <<" "; //像普通数组一样使用vector容器
    
    
    //创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式
       cout << endl << "第二种遍历方法：" << endl;
       vector<int>::iterator i;
    //用 != 比较两个迭代器
    for (i = v.begin(); i != v.end(); ++i)
        cout << *i << " ";
    
       cout << endl << "第三种遍历方法：" << endl;
    for (i = v.begin(); i < v.end(); ++i) //用 < 比较两个迭代器
        cout << *i << " ";
   
    
       cout << endl << "第四种遍历方法：" << endl;
    i = v.begin();
    while (i < v.end()) { //间隔一个输出
        cout << *i << " ";
        i += 2; // 随机访问迭代器支持 "+= 整数"  的操作
    }
}
~~~

再以list容器为例，list 容器的迭代器是双向迭代器。

~~~C++
//创建一个 v list容器
list<int> v;
//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。
list<int>::const_iterator i;
~~~

以下代码是合法的：

```C++
for(i = v.begin(); i != v.end(); ++i)    cout << *i;
```

以下代码则不合法，**因为双向迭代器不支持用“<”进行比较：**

```C++
for(i = v.begin(); i < v.end(); ++i)    cout << *i;
```

以下代码也不合法，**因为双向迭代器不支持用下标随机访问元素：**

```c++
for(int i=0; i<v.size(); ++i)    cout << v[i];
```

> 其实在 C++ 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，**int * 类型的指针就是其迭代器**。则 a、a+1、a+2 都是 a 的迭代器。



## 关联容器

### pair类

我们知道，关联式容器存储的是“键值对（key-value）”形式的数据

考虑到“键值对”并不是普通类型数据，C++标准库提供了 pair 类模板，**其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素`<first, second>`**

注意，pair 类模板定义在`<utility>`头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：

```C++
#1) 默认构造函数，即创建空的 pair 对象
pair();
#2) 直接使用 2 个元素初始化成 pair 对象
pair (const first_type& a, const second_type& b);
#3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象
template<class U, class V> pair (const pair<U,V>& pr);
```

创建pair对象示例

>最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。

~~~C++
#include <iostream>
#include <utility>      // pair
#include <string>       // string
using namespace std;
int main() {
    // 调用构造函数 1，也就是默认构造函数
    pair <string, double> pair1;
    // 调用第 2 种构造函数
    pair <string, string> pair2("苹果","apple");  
    // 调用拷贝构造函数
    pair <string, string> pair3(pair2);
    
    //访问元素
    cout<<pair2.first;//“苹果”
    
    //pair提供的swap
     pair<string, string>pair4("香蕉","balana"); 
     pair2.swap(pair4);//交换两个pair，注意key和value对应的类型都要一样

}
~~~

### Map容器

作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++基本数据类型（int、double 等）、使用结构体或类自定义的类型。

> 通常情况下，**map 容器中存储的各个键值对都选用 string 字符串作为键的类型。**

与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。

默认情况下，map 容器选用`std::less<T>`排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。

> 也就是map默认升序排序，不过可以自定义排序规则

当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 [STL](http://m.biancheng.net/stl/) 标准库中提供的其它排序规则（比如`std::greater<T>`），也可以自定义排序规则。

**另外需要注意的是，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。**

> 前面提到，map 容器存储的都是 pair 类型的键值对元素，**更确切的说，该容器存储的都是 pair<const K, T> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。**

使用map

~~~C++
#include<map>
using namespace std;
~~~

map 容器提供的常用成员方法以及各自的功能。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| end()            | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| find(key)(*)     | 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；       <br />**没有找到，则返回和 end() 方法一样的迭代器**。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(key) | 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(key) | 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(key) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 |
| empty()          | 若容器为空，则返回 true；否则 false。                        |
| size()           | 返回当前 map 容器中存有键值对的个数。                        |
| max_size()       | 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
| operator[]       | map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 |
| at(key)          | 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。 |
| insert()         | 向 map 容器中插入键值对。注意，用这个的话要先定义一个键值对，再插入，比较麻烦 |
| erase()          | 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。 |
| swap()           | 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 |
| clear()          | 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。   |
| emplace()(*)     | 在当前 map 容器中的指定位置处构造新键值对并插入。其效果和插入键值对一样，但效率更高，更方便 |
| emplace_hint()   | 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 |
| count(key)       | 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。 |

使用示例

~~~C++
#include <iostream>
#include <map>      // map
#include <string>       // string
using namespace std;

int main() {
    //创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序
    map<string, string, greater<string>>myMap;
    //调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对,因为是hash，所以这个位置是系统自己指定
    myMap.emplace("C语言教程","http://c.biancheng.net/c/");
    
    //输出当前 myMap 容器存储键值对的个数
    cout << "myMap size==" << myMap.size() << endl;
    
    //判断当前 myMap 容器是否为空
    if (!myMap.empty()) {
        //借助 myMap 容器迭代器，将该容器的键值对逐个输出
        for (auto i = myMap.begin(); i != myMap.end(); ++i) {
            cout << i->first << " " << i->second << endl;
        }
    }  
    map<int,int>test;
    int x=1,y=2;
    //插入
    test[x]=y;
    test.emplace(x,y);
    
    //迭代器
    map<int,int>::iterator tmp;
    //查询
    tmp=test.find(x);
    return 0;
}
~~~

## 适配器

### stack适配器

stack 栈适配器是一种单端开口的容器，实际上该容器模拟的就是栈存储结构，即无论是向里存数据还是从中取数据，都只能从这一个开口实现操作。

栈核心就四个操作**，栈长，取栈顶，pop,push**

> 后进先出



![stack适配器示意图](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/2-1P913101Q4T2.jpg)



**成员函数**

<center>表stack容器适配器支持的成员函数 </center>

| 成员函数                     | 功能                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| **empty()**                  | 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。 |
| **size()**                   | 返回 stack 栈中存储元素的个数。                              |
| **top()**                    | 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。  |
| **push(const T& val)**       | 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。 |
| push(T&& obj)                | 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 |
| **pop()**                    | 弹出栈顶元素。                                               |
| emplace(arg...)              | arg... 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。 |
| swap(stack<T> & other_stack) | 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |

**举例**

~~~C++
#include <stack>
using namespace std;
//创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器（底层）
stack<int> values={ 1, 2, 3 };
//指定底层是list的stack
//list<int> values {1, 2, 3};
//stack<int,list<int>> my_stack (values);

//遍历栈
 while (!values.empty())
    {  
        cout << values.top() << endl;
        //将栈顶元素弹栈
        values.pop();
    }
~~~

Q：为什么要叫stack适配器？

A：`stack<T,Container=deque<T>>` 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用出 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即.

序列式容器中同时包含这 5 个成员函数的，**有 vector、deque(默认底层) 和 list 这 3 个容器**。因此，stack 适配器的基础容器可以是它们 3 个中任何一个。例如，下面展示了如何定义一个使用 list 基础容器的 stack 适配器：

## Algorithm

这里对常用的STL中的algorithm总结

**排序**

| 函数名                    | 用法                                                         |
| ------------------------- | ------------------------------------------------------------ |
| sort (first, last)        | 对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。 |
| stable_sort (first, last) | 和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。 |

用法

sort() 函数有 2 种用法，其语法格式分别为：

```C++
//对 [first, last) 区域内的元素做默认的升序排序
void sort (RandomAccessIterator first, RandomAccessIterator last);
//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);

//示例
vector<int> myvector{ 32, 71, 12, 45, 26, 80, 53, 33 };
//排序一部分
sort(myvector.begin(), myvector.begin() + 4);//(12 32 45 71) 26 80 53 33，注意这里是左闭右开
//全部排序
sort(myvector.begin(), myvector.end());
```

需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：

1. 容器支持的迭代器类型必须为随机访问迭代器。这意味着，**sort() 只对 array、vector、deque 这 3 个容器提供支持。**
2. 如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持`<`小于运算符；同样，如果选用标准库提供的其它排序规则，**元素类型也必须支持该规则底层实现所用的比较运算符；**
3. sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是**自定义的类对象**，**则该类的内部必须提供移动构造函数和移动赋值运算符。**

还有就是自定义排序功能

~~~C++
#include <iostream>   
#include <algorithm>   
#include <vector>       
using namespace std;
//以普通函数的方式实现自定义排序规则
bool cmp(int i, int j) {
    return (i < j);
}

~~~

