---
title: DP题单1
date: 2024-04-22
tags: 
  - null
categories:  
  - 算法
  - 题单分类
---

## 入门DP

### 爬楼梯



#### 70. 爬楼梯

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

![image-20240405110042383](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240405110042383.png)

> 灵神题解：https://leetcode.cn/problems/climbing-stairs/solutions/2560716/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-7zm1

思路：

回溯三连：

**原问题**：从第n阶爬到0有多少种方法

- 当前操作：第i次操作选择爬到i-1，还是i-2
- 子问题：从0到第n阶有多少种方法
- 下一个子问题？分类讨论
  - 选i+1, 那么从0到n-1楼梯中获取方法数
  - 选i+2,那么从0到n-2楼梯中获取方法数

$dfs(n)=dfs(n-1)+dfs(n-2)$​

边界:

当n=0或者n=1时，返回1

> 从0爬到0，从0爬到1

```java
class Solution {
    int []f;//记忆化
    public int climbStairs(int n) {
       f=new int[n+2];
       Arrays.fill(f,-1);
       return dfs(n);
      
    }
    public int dfs(int n){
        if(n==0||n==1) return 1;
        if(f[n]!=-1) return f[n];
        return f[n]=dfs(n-1)+dfs(n-2);
    }
}
```

**转换为递推**

dfs转移方程

$f[i]=f[i-1]+f[i-2]$​

注意$0<=i<=n$，所以也存在负数下标问题。

但是这里和打家劫舍的区别是，没有$nums$数组

- 所以这里可以让$i$从2开始遍历即可，也就是$2<=i<=n$

边界

$f[0]=1,f[1]=1$

返回值

$f[n]$

```java
class Solution {
    public int climbStairs(int n) {
       int []f=new int[n+1];
       f[0]=1;
       f[1]=1;
       for(int i=2;i<=n;i++){
            f[i+]=f[i-1]+f[i-2];
       }
       return f[n];  
    }
}
```

**空间优化**

```java
class Solution {
    public int climbStairs(int n) {
        int f0=1,f1=1;//上上个状态和上一个状态
        for(int i=2;i<=n;i++){//注意这里我们看成f0有一种方法，f1有一种方法，所以f2刚好也就有两种方法
            int new_f = f0+f1;//当前状态
            f0=f1;//f0更新
            f1=new_f;//f1更新
            //因为我们下一次循环只用到这两个状态
        }
        return f1;

    }
}
```

#### 746. 使用最小花费爬楼梯

原问题：

注意总共有$0-n$也就是$n+1$个楼梯。我们对于第$n$阶楼梯，要么从$n-1$来，要么从$n-2$来。并且要分别加上$cost[n-1],cost[n-2]$。

转移方程

- $dfs(n)=min(dfs(n-1)+cost[n-1],dfS(n-2)+cost[n-2])$

边界：

- 我们一开始就可以跨一步或者两步，那么我们需要从$dfs(0),dfs(1)$转移过来（当n=1或者n=2），那么他们应该是0。才正确

返回值

- $dfs(n)$。注意这里是$0-n$，所以不是$n-1$。

> 其实可以代入边界到转移方程中，这样更好理解

记忆化搜索写法

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        @cache
        def dfs(i:int) -> int:
            if i<=1:
                return 0
            return min(dfs(i-1)+cost[i-1],dfs(i-2)+cost[i-2])
        return dfs(len(cost))
```

递推写法

- $f[n]=min(f[n-1]+cost[n-1],f[n-2]+cost[n-2])$

> 这里不用给f插入空位，只需要从2开始就可以避免负数下标。

空间优化：

更简单的，我们发现当前状态是和上个状态$f[n-1]$和上上个状态$f[n-2]$

所以可以只使用两个变量，这样就不用使用数组

返回值

- 这里观察到最后结果存在了f1里，所以返回f1，实际上就是$f[n]$

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int f0=0,f1=0;
        int n=cost.length;
        for(int i=2;i<=n;i++){//0-n
            int new_f=Math.min(f0+cost[i-2],f1+cost[i-1]);
            f0=f1;
            f1=new_f;
        }
        return f1;
    }
}
```

#### 377. 组合总和 Ⅳ(不会转化)

[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423191301940.png" alt="image-20240423191301940" style="zoom:80%;" />

**思路：**

> 灵神题解：https://leetcode.cn/problems/combination-sum-iv/solutions/2706336/ben-zhi-shi-pa-lou-ti-cong-ji-yi-hua-sou-y52j
>
> 最关键的话。
>
> ![image-20240423193817480](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423193817480.png)

如果我们枚举每一种组合/序列，那么就肯定可以得到所有组合/序列个数了。

**Q&A:**

$Question:这里可以用选或不选的思路吗或者说为什么这道题不是完全背包？$

Ans：选/不选是子集型问题的思路，背包问题也是子集型问题。但是这道题选出的是**不同的序列，而不是子集**

**问题定义：**

$dfs(n,target)$表示我们要从前n个数中，选出和为target的组合数目

> 上面这个就是背包问题的定义，但是这不是背包问题。

所以定义应该是$dfs(target)$，表示从nums中选出和为target的组合数目

> Question：如果一个数只能用一次呢？
>
> Ans：这个时候就需要这个状态了，帮助我们排除nums中的数据

**转移方程：**

对于nums[i]，如果他比target小才能选。

$dfs(target)=\sum dfs(target-nums[i])$

边界：

$target=0$时，应该返回1，表示返回一种方案

```java
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        @cache
        def dfs(target:int) -> int:
            if(target==0):
                return 1
            ans=0
            for x in nums:
                if x<=target:
                    ans+=dfs(target-x)
            return ans
        return dfs(target)
```

**转化成递推**

这里其实并没有懂，因为他是类似背包那样转化的。

#### 2466. 统计构造好字符串的方案数

[2466. 统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423211014800.png" alt="image-20240423211014800" style="zoom:80%;" />

思路：

> 本质上仍然是**爬楼梯：**
>
> 灵神题解：https://leetcode.cn/problems/count-ways-to-build-good-strings/solutions/1964910/by-endlesscheng-4j22

**起点都是空**，每次操作都是在末尾添加0-1，那么答案是可以枚举出来的。

当然，暴力枚举肯定超时。我们可以从空开始，每次可以进行添加0/添加1，只要最后得到的字符串长度刚好在$[low,high]$中就能算一种。

状态定义：

定义$dfs(n)$为根据上面的操作，生成的不同字符串长度为$n$中的数目

转移方程

$dfs(n)=dfs(n-zero)+dfs(n-one)$

边界

当`n==zero||n==one`时，dfs(0)就会递归到0，此时应该代表着空串，所以返回1

也即是$dfs(0)=1$

> Question：边界为什么不是`n==zero||n==one`
>
> Ans:我们是从空串开始，他们算是第二步了。
>
> 再者，如果是以n=zero为边界，那么zero==one,时又怎么初始化，所以这并不是边界

所以答案应该是sum(dfs(low-right))

```java
class Solution {
    public int countGoodStrings(int low, int high, int zero, int one) {
        int mod = (int)1e9+7;

        int []dp =new int[high+1];
        // dp[one]=1;
        // dp[zero]=1;
        dp[0]=1;
        int ans=0;
        for(int i=0;i<=high;i++){
            if(i>=zero) dp[i]=(dp[i-zero]+dp[i])%mod;
            if(i>=one) dp[i]=(dp[i-one]+dp[i])%mod;
        }
        for(int i=low;i<=high;i++) ans=(ans+dp[i])%mod;
        return ans;
    }
}
```

#### 2266. 统计打字方案数（分组+乘法原理）

[2266. 统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/)

题目很长，看网址

思路：

- 假设有字符串"222"，那么就可能是“aaa”,"ab","ba",c"。所以对于一种数字，操作时有限的

- 对于"222""777"，有的方法数显然是两者相乘，**符合乘法原理**
- 那么我们可以使用dp算出每一种字符的方法数（**分组**），再乘起来即可。

首先好像需要构建一个map，把a-z先映射为2-9组成各个字符串。

仔细想想，不需要！，因为这道题并没有让我们构造出字符串，所以我们可以**只根据三个字符和四个字符的按键进行分组即可**！！

> 抽象到这一步真的很困难，只能多刷题试试了

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423221519992.png" alt="image-20240423221519992" style="zoom:80%;" />

边界：

如果是0个2，那么表示空，只有一种可能""

- 为什么不是0？我们发现如果是0，那么f[3]=3，所以不对。

如果只有一个，2,那么只有一种可能 a

如果是两个，22，那么可以是2种可能 aa b

如果是3个，222，那么可能有4可能 ab ba aaa c

所以无论是对于三个字符的情况还是对于四个字符的情况（7,9），都可以这么初始化

```java
class Solution {
    public int countTexts(String s) {
        int mod = (int)1e9+7;
        int mx = (int)1e5+1;
        int []f = new int[mx],g = new int[mx];
        f[0]=g[0]=1;
        f[1]=g[1]=1;
        f[2]=g[2]=2;
        f[3]=g[3]=4;
        for(var i=4;i<mx;i++){//直接算到数据上限，那么后面可以直接拿来用
            f[i] =(int)(((long)f[i-1]+f[i-2]+f[i-3])%mod);
            g[i]=(int)(((long)g[i-1]+g[i-2]+g[i-3]+g[i-4])%mod);
        }

        int ans=1,cnt=0;
        for(var i=0;i<s.length();i++){
            cnt++;
            var c=s.charAt(i);
            if(i==s.length()-1||c!=s.charAt(i+1)){//分组
                ans = (int)((long)ans*(c!='7'&&c!='9'?f[cnt]:g[cnt])%mod);//乘法原理
                cnt=0;
            }
        }
        return ans;


    }
}
```







## 总结

### 思路启发

如何着手一个问题。

- 如果是两端的那种问题，从问题的起点/终点状态分析会更容易，因为此时只需要考虑一边，另一边是边界。

- 如果是统计，遍历，或者是需要暴力的，那么也可以搜索或者DP。因为本质上他们就是暴力，只是更优雅

