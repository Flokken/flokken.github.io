---
title: DP题单1
date: 2024-04-22
tags: 
  - null
categories:  
  - 算法
  - 题单分类
---

## 入门DP

### 爬楼梯



#### 70. 爬楼梯

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

![image-20240405110042383](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240405110042383.png)

> 灵神题解：https://leetcode.cn/problems/climbing-stairs/solutions/2560716/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-7zm1

思路：

回溯三连：

**原问题**：从第n阶爬到0有多少种方法

- 当前操作：第i次操作选择爬到i-1，还是i-2
- 子问题：从0到第n阶有多少种方法
- 下一个子问题？分类讨论
  - 选i+1, 那么从0到n-1楼梯中获取方法数
  - 选i+2,那么从0到n-2楼梯中获取方法数

$dfs(n)=dfs(n-1)+dfs(n-2)$​

边界:

当n=0或者n=1时，返回1

> 从0爬到0，从0爬到1

```java
class Solution {
    int []f;//记忆化
    public int climbStairs(int n) {
       f=new int[n+2];
       Arrays.fill(f,-1);
       return dfs(n);
      
    }
    public int dfs(int n){
        if(n==0||n==1) return 1;
        if(f[n]!=-1) return f[n];
        return f[n]=dfs(n-1)+dfs(n-2);
    }
}
```

**转换为递推**

dfs转移方程

$f[i]=f[i-1]+f[i-2]$​

注意$0<=i<=n$，所以也存在负数下标问题。

但是这里和打家劫舍的区别是，没有$nums$数组

- 所以这里可以让$i$从2开始遍历即可，也就是$2<=i<=n$

边界

$f[0]=1,f[1]=1$

返回值

$f[n]$

```java
class Solution {
    public int climbStairs(int n) {
       int []f=new int[n+1];
       f[0]=1;
       f[1]=1;
       for(int i=2;i<=n;i++){
            f[i+]=f[i-1]+f[i-2];
       }
       return f[n];  
    }
}
```

**空间优化**

```java
class Solution {
    public int climbStairs(int n) {
        int f0=1,f1=1;//上上个状态和上一个状态
        for(int i=2;i<=n;i++){//注意这里我们看成f0有一种方法，f1有一种方法，所以f2刚好也就有两种方法
            int new_f = f0+f1;//当前状态
            f0=f1;//f0更新
            f1=new_f;//f1更新
            //因为我们下一次循环只用到这两个状态
        }
        return f1;

    }
}
```

#### 746. 使用最小花费爬楼梯

原问题：

注意总共有$0-n$也就是$n+1$个楼梯。我们对于第$n$阶楼梯，要么从$n-1$来，要么从$n-2$来。并且要分别加上$cost[n-1],cost[n-2]$。

转移方程

- $dfs(n)=min(dfs(n-1)+cost[n-1],dfS(n-2)+cost[n-2])$

边界：

- 我们一开始就可以跨一步或者两步，那么我们需要从$dfs(0),dfs(1)$转移过来（当n=1或者n=2），那么他们应该是0。才正确

返回值

- $dfs(n)$。注意这里是$0-n$，所以不是$n-1$。

> 其实可以代入边界到转移方程中，这样更好理解

记忆化搜索写法

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        @cache
        def dfs(i:int) -> int:
            if i<=1:
                return 0
            return min(dfs(i-1)+cost[i-1],dfs(i-2)+cost[i-2])
        return dfs(len(cost))
```

递推写法

- $f[n]=min(f[n-1]+cost[n-1],f[n-2]+cost[n-2])$

> 这里不用给f插入空位，只需要从2开始就可以避免负数下标。

空间优化：

更简单的，我们发现当前状态是和上个状态$f[n-1]$和上上个状态$f[n-2]$

所以可以只使用两个变量，这样就不用使用数组

返回值

- 这里观察到最后结果存在了f1里，所以返回f1，实际上就是$f[n]$

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int f0=0,f1=0;
        int n=cost.length;
        for(int i=2;i<=n;i++){//0-n
            int new_f=Math.min(f0+cost[i-2],f1+cost[i-1]);
            f0=f1;
            f1=new_f;
        }
        return f1;
    }
}
```

#### 377. 组合总和 Ⅳ(不会转化)

[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423191301940.png" alt="image-20240423191301940" style="zoom:80%;" />

**思路：**

> 灵神题解：https://leetcode.cn/problems/combination-sum-iv/solutions/2706336/ben-zhi-shi-pa-lou-ti-cong-ji-yi-hua-sou-y52j
>
> 最关键的话。
>
> ![image-20240423193817480](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423193817480.png)

如果我们枚举每一种组合/序列，那么就肯定可以得到所有组合/序列个数了。

**Q&A:**

$Question:这里可以用选或不选的思路吗或者说为什么这道题不是完全背包？$

Ans：选/不选是子集型问题的思路，背包问题也是子集型问题。但是这道题选出的是**不同的序列，而不是子集**

**问题定义：**

$dfs(n,target)$表示我们要从前n个数中，选出和为target的组合数目

> 上面这个就是背包问题的定义，但是这不是背包问题。

所以定义应该是$dfs(target)$，表示从nums中选出和为target的组合数目

> Question：如果一个数只能用一次呢？
>
> Ans：这个时候就需要这个状态了，帮助我们排除nums中的数据

**转移方程：**

对于nums[i]，如果他比target小才能选。

$dfs(target)=\sum dfs(target-nums[i])$

边界：

$target=0$时，应该返回1，表示返回一种方案

```java
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        @cache
        def dfs(target:int) -> int:
            if(target==0):
                return 1
            ans=0
            for x in nums:
                if x<=target:
                    ans+=dfs(target-x)
            return ans
        return dfs(target)
```

**转化成递推**

这里其实并没有懂，因为他是类似背包那样转化的。

#### 2466. 统计构造好字符串的方案数

[2466. 统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423211014800.png" alt="image-20240423211014800" style="zoom:80%;" />

思路：

> 本质上仍然是**爬楼梯：**
>
> 灵神题解：https://leetcode.cn/problems/count-ways-to-build-good-strings/solutions/1964910/by-endlesscheng-4j22

**起点都是空**，每次操作都是在末尾添加0-1，那么答案是可以枚举出来的。

当然，暴力枚举肯定超时。我们可以从空开始，每次可以进行添加0/添加1，只要最后得到的字符串长度刚好在$[low,high]$中就能算一种。

状态定义：

定义$dfs(n)$为根据上面的操作，生成的不同字符串长度为$n$中的数目

转移方程

$dfs(n)=dfs(n-zero)+dfs(n-one)$

边界

当`n==zero||n==one`时，dfs(0)就会递归到0，此时应该代表着空串，所以返回1

也即是$dfs(0)=1$

> Question：边界为什么不是`n==zero||n==one`
>
> Ans:我们是从空串开始，他们算是第二步了。
>
> 再者，如果是以n=zero为边界，那么zero==one,时又怎么初始化，所以这并不是边界

所以答案应该是sum(dfs(low-right))

```java
class Solution {
    public int countGoodStrings(int low, int high, int zero, int one) {
        int mod = (int)1e9+7;

        int []dp =new int[high+1];
        // dp[one]=1;
        // dp[zero]=1;
        dp[0]=1;
        int ans=0;
        for(int i=0;i<=high;i++){
            if(i>=zero) dp[i]=(dp[i-zero]+dp[i])%mod;
            if(i>=one) dp[i]=(dp[i-one]+dp[i])%mod;
        }
        for(int i=low;i<=high;i++) ans=(ans+dp[i])%mod;
        return ans;
    }
}
```

#### 2266. 统计打字方案数（分组+乘法原理）

[2266. 统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/)

题目很长，看网址

思路：

- 假设有字符串"222"，那么就可能是“aaa”,"ab","ba",c"。所以对于一种数字，操作时有限的

- 对于"222""777"，有的方法数显然是两者相乘，**符合乘法原理**
- 那么我们可以使用dp算出每一种字符的方法数（**分组**），再乘起来即可。

首先好像需要构建一个map，把a-z先映射为2-9组成各个字符串。

仔细想想，不需要！，因为这道题并没有让我们构造出字符串，所以我们可以**只根据三个字符和四个字符的按键进行分组即可**！！

> 抽象到这一步真的很困难，只能多刷题试试了

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240423221519992.png" alt="image-20240423221519992" style="zoom:80%;" />

边界：

如果是0个2，那么表示空，只有一种可能""

- 为什么不是0？我们发现如果是0，那么f[3]=3，所以不对。

如果只有一个，2,那么只有一种可能 a

如果是两个，22，那么可以是2种可能 aa b

如果是3个，222，那么可能有4可能 ab ba aaa c

所以无论是对于三个字符的情况还是对于四个字符的情况（7,9），都可以这么初始化

```java
class Solution {
    public int countTexts(String s) {
        int mod = (int)1e9+7;
        int mx = (int)1e5+1;
        int []f = new int[mx],g = new int[mx];
        f[0]=g[0]=1;
        f[1]=g[1]=1;
        f[2]=g[2]=2;
        f[3]=g[3]=4;
        for(var i=4;i<mx;i++){//直接算到数据上限，那么后面可以直接拿来用
            f[i] =(int)(((long)f[i-1]+f[i-2]+f[i-3])%mod);
            g[i]=(int)(((long)g[i-1]+g[i-2]+g[i-3]+g[i-4])%mod);
        }

        int ans=1,cnt=0;
        for(var i=0;i<s.length();i++){
            cnt++;
            var c=s.charAt(i);
            if(i==s.length()-1||c!=s.charAt(i+1)){//分组
                ans = (int)((long)ans*(c!='7'&&c!='9'?f[cnt]:g[cnt])%mod);//乘法原理
                cnt=0;
            }
        }
        return ans;


    }
}
```

### 打家劫舍

#### 198打家劫舍

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424082346414.png" alt="image-20240424082346414" style="zoom:80%;" />

思路：

我们从第$n$个房屋考虑，那么当前结果只能从前$n-1$和前$n-2$加上nums[n]来。

状态定义:

- dfs(i)表示前i户能偷到的最大值

起点:

- dfs(n-1)

边界:

- i<0 ,返回0

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        #dfs(i)=max(dfs(i-1)+cost[i],dfs(i-2))
        @cache
        def dfs(i:int) -> int:
            if(i<0):
                return 0
            return max(dfs(i-2)+nums[i],dfs(i-1))
        return dfs(len(nums)-1)
```

转化为递推:

- 由于可能存在负数下标，所以f数组前面填充2，那么返回值就是f[n+1];

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        int []f = new int[n+2];
        //f[i+2]=max(f[i+1],f[i]+nums[i]);
        for(int i=0;i<n;i++){
            f[i+2]=Math.max(f[i]+nums[i],f[i+1]);
        }
        return f[n+1];
    }
}
```

**空间优化**

由于每次只使用了上一次状态和上上次状态，因此可以优化

- f0上上次状态
- f1上次状态

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        int []f = new int[n+2];
        int f0=0,f1=0;
        //f[i+2]=max(f[i+1],f[i]+nums[i]);
        for(int i=0;i<n;i++){
            int new_f = Math.max(f0+nums[i],f1);
            f0=f1;
            f1=new_f;
        }
        return f1;
    }
}
```

#### 740. 删除并获得点数

[740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424085123244.png" alt="image-20240424085123244" style="zoom:80%;" />

思路：

由于这里影响的是$nums[i],nums[i]-1,nums[i]+1$，所以我们应该关注的是值。

那么我们可以想到，如果当前是$i$，那么其最大点数要么从前$i-2$转移来，要么从$i-1$转移来。

- 如果要删当前元素，那么上一个元素就不能删，只能从上上个状态来

状态定义：

- dfs(i)表示从0删到i，能获得的最大点数
- $cnt[i]$表示$i$在数组中出现次数，辅助操作。

转移方程：

- $dfs(i)=max(dfs(i-2)+i ,dfs(i-1))$

- 注意这里和打家劫舍的细微区别，这里影响的是$i-1$，打家劫舍影响的是数组中的上一个元素，所以是$nums[i]$。

边界:

- i<mn，那么就是0，为了方便，我们可以直接从0开始

返回值

- dfs(mx)
- mx是数组中最大值

因为有负数下标，所以下面是在f数组前面填充了2，因此返回$f[mx+2]$

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        //cnt数组记录出现的值和次数，辅助删除
        //
        int mx = 0,n=nums.length;
        for(var x:nums) mx = Math.max(x,mx);
        int cnt[] = new int [mx+1];
        for(var x:nums) cnt[x]++;
        int f[] = new int [mx+3];
        for(int i=0;i<=mx;i++){
            f[i+2]=Math.max(f[i]+cnt[i]*i,f[i+1]);
        }
        return f[mx+2];
    }
}
```

**空间优化**

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int mx = 0,n=nums.length;
        for(var x:nums) mx = Math.max(x,mx);
        int cnt[] = new int [mx+1];
        for(var x:nums) cnt[x]++;
        int f0=0,f1=0;
        for(int i=0;i<=mx;i++){
            int new_f = Math.max(f0+cnt[i]*i,f1);
            f0=f1;
            f1=new_f;
        }
        return f1;
    }
}
```

#### 2320. 统计放置房子的方式数(乘法原理)

[2320. 统计放置房子的方式数](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424091533447.png" alt="image-20240424091533447" style="zoom:67%;" />

思路：

首先左右两个互不影响，所以可以先算出一遍，然后乘起来。

由于相邻不能放房子，那么对于当前的$i$，其放房子的方案数就是$i-1$和$i-2$而来

状态定义：

$dfs(i)$表示，从0到$i$个地块可以放的房子数。

转移方程

- $dfs(i)=dfs(i-2)+dfs(i-1)$

边界：

边界怎么找？我们直接代入，0,1发现不能算，所以需要初始值。

代入到2时，可以了，所以不是边界了。

- i=0，没有地块，不放房子，所以返回1
- i=1时，有放一个房子，或者不放房子，所以返回2

**返回值：**

$dfs(n)$，注意是包括n。

```java
class Solution {
    public int countHousePlacements(int n) {
        int mod =(int)1e9+7;
        int f0=1,f1=2;
        //dfs(i)=dfs(i-2)+dfs(i-1);
        for(int i=2;i<=n;i++){
            int new_f=(f0+f1)%mod;;
            f0=f1;
            f1=new_f;
        }
        return (int)((long)f1*f1 %mod);
    }
}
```

#### 213. 打家劫舍 II

[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424092557520.png" alt="image-20240424092557520" style="zoom:80%;" />

思路：

注意这里说第$n$个房子和第$1$个房子连通，所以这两个不能连续偷了。

所以核心在于讨论一下$nums[0]$能不能偷。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424094719236.png" alt="image-20240424094719236" style="zoom:80%;" />

> 灵神的版本更好，这样讨论更简单。
>
> 灵神版本也是讨论$nums[0]$选不选，但是避免了特判n==1的情况。

状态定义：

如果我们用$dfs(i)$表示偷到$i$的最大金额。那么对于第$n$个房屋，他不能以$dfs(0)$为起点，只能以$dfs(1)$开始。

但是此时$dfs(n-1)$和$dfs(n)$大的大小关系我们不能确定了。所以应该两者之间取最大值

- **因为两者初始状态不一样。**

**转移方程**

- $dfs(i)=max(dfs(i-1),dfs(i-2)+nums[i])$

**边界：**

- i<0，返回0

**返回值**

- $max(dfs(n-1),dfs(n-2))$。因为这里是下标。上面分析说的是第$n$个房子

我的版本：

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        if(n==1) return nums[0];
        int f0=0,f1=0;
        int x=0;
        for(int i=1;i<n;i++){
            int new_f = Math.max(f0+nums[i],f1);
            f0=f1;
            f1=new_f;
        }
        x=f1;
        f0=0;
        f1=0;
        for(int i=0;i<n-1;i++){
            int new_f = Math.max(f0+nums[i],f1);
            f0=f1;
            f1=new_f;
        }
        return Math.max(f1,x);
    }
}
```

**灵神版本:学习！！**

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        return Math.max(nums[0]+rob1(nums,2,n-1),rob1(nums,1,n));
    }
    public int rob1(int[]nums,int start,int end){
        int f0=0,f1=0;
        for(int i=start;i<end;i++){
            int new_f=Math.max(f1,f0+nums[i]);
            f0=f1;
            f1=new_f;
        }
        return f1;
    }
}
```

### 最大子数组和(子段和)

#### 通用思路

给一个数组，数组中**有正数也有负数**，求最大子数组和

- 变形题1，求最小的子数组和？
- 变形题2，连续/重复的子数组怎么思考(1191,918)都是这种类型。
  - 看918题灵神怎么分类讨论的。
  - 主要是要分为数组跨过边界/没有跨过边界
    - 特殊情况：整个数组就是最小子数组

两种做法：

- 定义状态$f[i]$表示以$a[i]$结尾的最大子数组和，不和$i$左边拼起来（因为可能负数），就是$f[i]=a[i]$。和$i$左边拼起来就是$f[i]=f[i-1]+a[i]$。取最大值，转移方程就是$f[i]=max(f[i-1],0)+a[i]$。
  - 答案应该是$max(f)$
  - 空间优化，由于只需要上一个状态，所以只需要一个$fMax$变量记录上一个最大值即可。
  - 如果是求最小，那么转移方程变为$f[i]=min(f[i-1],0)+a[i]$即可
- 前缀和解决。

#### 53. 最大子数组和

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

采用上面的思路1，也就是DP求解。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int []f =new int [n+1];
        int ans = Integer.MIN_VALUE;
        for(int i=0;i<n;i++){
            f[i+1]=Math.max(f[i],0)+nums[i];
            ans=Math.max(f[i+1],ans);
        }
        return ans;
    }
}
```

空间优化：

- 空间优化后无需处理f[0]，因为fMax会被赋值为nums[0]

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int ans = Integer.MIN_VALUE;
        int fMax=0;
        for(int i=0;i<n;i++){
            fMax=Math.max(fMax,0)+nums[i];
            ans=Math.max(fMax,ans);
        }
        return ans;
    }
}
```



#### 2606. 找到最大开销的子字符串

[2606. 找到最大开销的子字符串](https://leetcode.cn/problems/find-the-substring-with-maximum-cost/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424104202186.png" alt="image-20240424104202186" style="zoom:80%;" />

思路：

我们先用一个cnt数组，记录每个字符对应的值。那么剩下的就是求最大子数组和了。

- 注意题目要求，最小是0，可以一个都不选。

```java
class Solution {
    public int maximumCostSubstring(String S, String chars, int[] vals) {
        int []cnt = new int[26];
        char []s =S.toCharArray();
        int n=s.length;
        int []f =new int[n];
        for(int i=0;i<26;i++) cnt[i]=i+1;
        for(int i=0;i<chars.length();i++){
            cnt[chars.charAt(i)-'a']=vals[i];
        }
        f[0]=cnt[s[0]-'a'];
        for(int i=1;i<n;i++){
            f[i]=Math.max(f[i-1],0)+cnt[s[i]-'a'];
        }
        int ans=Integer.MIN_VALUE;
        for(var x:f) ans=Math.max(x,ans);
        return ans<0?0:ans;
    }
}
```

#### 1749. 任意子数组和的绝对值的最大值

[1749. 任意子数组和的绝对值的最大值](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424104408227.png" alt="image-20240424104408227" style="zoom:80%;" />

思路：

我们求绝对值最大的子数组，那么绝对值最大可以转化为**子数组和最大以及子数组和最小**。

所以分别求最大子数组和以及最小子数组和，然后求最大绝对值即可。

```java
class Solution {
    public int maxAbsoluteSum(int[] nums) {
        int n=nums.length;
        int ans=0,fMin=0,fMax=0;
        for(int i=0;i<n;i++){
            fMax=Math.max(fMax,0)+nums[i];
            fMin=Math.min(fMin,0)+nums[i];
            ans =Math.max(ans,Math.max(fMax,-fMin));
        }
        return ans;
    }   
}

```

#### 1191. K 次串联后最大子数组之和（不会）

[1191. K 次串联后最大子数组之和](https://leetcode.cn/problems/k-concatenation-maximum-sum/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424111322837.png" alt="image-20240424111322837" style="zoom:80%;" />

思路：

首先，重复1次就相当于又加了一个arr在arr末尾，所以此时可以看成最大子数组和的变形。

- 如果不跨界，那么就是最大子数组和maxS
- 如果跨界，那么即使sum(arr)-minS

那么剩余重复k-2次如何考虑？

- 如果$sum(arr)>0$那么才可以有盈余到下一次重复。不然不会超过上面求出来的最大值。
- 举例  [1,-2,1]，k=5,sum（arr）=0，所以其最大值为2，也就是[1,-2,1,1,2-,1]这里求出来的最大值。
- 举例 [1,2]，k-3,sum(arr)>0,所以最大值是9=sum(arr)+(1)*3=9

```java
```

#### 918. 环形子数组的最大和

[918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424122812184.png" alt="image-20240424122812184" style="zoom:80%;" />

思路：



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424122844446.png" alt="image-20240424122844446" style="zoom: 67%;" />



```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int maxS= Integer.MIN_VALUE;
        int minS =0;
        int maxF=0,minF=0,sum=0;
        for(int x:nums){
            // 以 nums[i-1] 结尾的子数组选或不选（取 max）+ x = 以 x 结尾的最大子数组和
            maxF = Math.max(maxF,0)+x;
            maxS = Math.max(maxS,maxF);//最大的子数组和
           /
           / 以 nums[i-1] 结尾的子数组选或不选（取 min）+ x = 以 x 结尾的最小子数组和
            minF  =Math.min(minF,0)+x;
            minS = Math.min(minS,minF);//最小的子数组和
            sum+=x;//前缀和，也就是整个数组和。
        }
        return sum==minS?maxS:Math.max(maxS,sum-minS);
    }
}
```

#### 2321. 拼接数组的最大分数

[2321. 拼接数组的最大分数](https://leetcode.cn/problems/maximum-score-of-spliced-array/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424133326098.png" alt="image-20240424133326098" style="zoom:80%;" />

思路：

如何转换题目条件？也就是交换子数组？

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424134901482.png" alt="image-20240424134901482" style="zoom:80%;" />

> 灵神题解：https://leetcode.cn/problems/maximum-score-of-spliced-array/solutions/1626030/by-endlesscheng-fm8l

```java
class Solution {
    public int maximumsSplicedArray(int[] nums1, int[] nums2) {
       return Math.max(slove(nums1,nums2),slove(nums2,nums1));
    }
    public int slove(int []nums1, int[] nums2){
        int n=nums1.length;
        int sum=0, maxS=0, mx=0;
        for(int i=0;i<n;i++){
            sum+=nums1[i];
            maxS=Math.max(maxS,0)+nums2[i]-nums1[i];
            //这里更严谨的应该是maxS=Math.max(maxS+nums2[i]-nums1[i],0);
            //因为题目要求这个最大值最小时可以是0，
            mx=Math.max(maxS,mx);
        }
        return sum+mx;
    }
}
```

#### 363. 矩形区域不超过 K 的最大数值和

[363. 矩形区域不超过 K 的最大数值和](https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424135231470.png" alt="image-20240424135231470" style="zoom:80%;" />

思路：看上去就不会做。

可以用二维前缀和来暴力枚举最大的。但是很可能超时。

```java
class Solution {
    public int maxSumSubmatrix(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;
        int[][] sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }
        int ans = Integer.MIN_VALUE;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                for (int p = i; p <= m; p++) {
                    for (int q = j; q <= n; q++) {
                        //求子矩阵的和
                        int cur = sum[p][q] - sum[i - 1][q] - sum[p][j - 1] + sum[i - 1][j - 1];
                        if (cur <= k) {
                            ans = Math.max(ans, cur);
                        } 
                    }
                }
            }
        }
        return ans;
    }
}
```

#### 152. 乘积最大子数组

[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424135925162.png" alt="image-20240424135925162" style="zoom:80%;" />

思路：

假设最大子数组以$nums[i]$结尾，那么此时有两种情况，如果$nums[i]$是负数，那么他需要乘一个最小的数。

如果是正数，则需要乘一个最大的数。

所以此题可以类比最大子数组和，但是同时维护一个最大乘积和最小乘积。

$maxf[i]=max(f[i-1]*nums[i]，nums[i])$

$minf[i]=min(f[i-1]*nums[i],nums[i])$

- 如果当前数是负数，那么当前的最大值就是这个负数*最小值。最小值就是当前最大值乘这个负数
- 如果当前数是正数，那么当前的最大值就是这个正数*最大值。最小值就是当前最小值乘这个正数

最后取最大值中的最大值即可。

```java
class Solution {
    public int maxProduct(int[] nums) {
        int maxS=1;
        int minS=1,n=nums.length;
        int ans=Integer.MIN_VALUE;;
        for(int i=0;i<n;i++){
            int tmp=maxS;
            maxS=Math.max(maxS*nums[i],Math.max(minS*nums[i],nums[i]));
            //注意这里maxS被覆盖了，所以上面用一个tmp给他存起来
            minS = Math.min(minS*nums[i],Math.min(tmp*nums[i],nums[i]));
            ans = Math.max(maxS,ans);
        }
        return ans;
    }
}
```

## 网格图DP

### LCR 166. 珠宝的最高价值（例题）

[LCR 166. 珠宝的最高价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424144849371.png" alt="image-20240424144849371" style="zoom:80%;" />

思路：

详细讲解看灵神的：https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solutions/2153802/jiao-ni-yi-bu-bu-si-kao-dpcong-hui-su-da-epvl

这里精要的说一下网格图DP的问题。

从$(0,0)$出发到$(m,n)$的最大价值是多少呢？

**状态定义：**

定义$dfs(i,j)$表示从左上角即$(0,0)$到$(i,j)$的最高价值。

**转移方程**

那么这个点**只能来自于其左上角和上方，**所以转移方程式

$dfs(i,j)=Math.max(dfs(i-1,j),dfs(i,j-1))+grid[i][j]$

**入口**:

$dfs(n-1,m-1)$。

边界:

$i<0||j<0$，返回0。

**细节：**

- 我们虽然是从$(n-1,m-1)$开始，但是我们是在[归的过程中计算]，所以仍然是从左上角计算到右下角

- 倒着思考，利于转化为递推



**1:1转化为递推：**

这里转化时，为了不产生负数下标，所以都需要给第一维和第二维填充1位。（也就是填充1行一列）

```java
class Solution {
    public int jewelleryValue(int[][] frame) {
        int n=frame.length,m=frame[0].length;
        int [][]f =new int[n+1][m+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                f[i+1][j+1]=Math.max(f[i+1][j],f[i][j+1])+frame[i][j];
            }
        }
        return f[n][m];
    }
}
```

**空间优化**

这里可以采用类似完全背包的空间优化。

我们只需要使用一个数组来记录。把$i$这个一维去掉。

![image-20240424163231590](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424163231590.png)

顺序

- $i$从$i-1$转移而来，所以是正序
- $j$从$j-1$转移而来，所以也是正序

```java
class Solution {
    public int jewelleryValue(int[][] frame) {
        int n=frame.length,m=frame[0].length;
        int []f =new int[m+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                f[j+1]=Math.max(f[j],f[j+1])+frame[i][j];
            }
        }
        return f[m];
    }
}
```

### 62. 不同路径

[62. 不同路径](https://leetcode.cn/problems/unique-paths/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424160108994.png" alt="image-20240424160108994" style="zoom:80%;" />

思路

显然就是网格dp了，状态定义依然是$dfs(i,j)$表示从左上角到$(i,j)$所需步数

$dfs(i,j)=dfs(i-1,j)+dfs(i,j-1)$

边界：

$i==0||j==0$，返回1，对应首行首列的格子，只有一种方法到达

**入口**:

$dfs(m-1,n-1)$

- 注意这里是从$(1,1)$开始。所以从（1,1）到（m,n），也可以写成(0,0)到(m-1,n-1)

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        @cache
        def dfs(i:int ,j:int) -> int:
            if i==0 or j==0:
                return 1
            return dfs(i-1,j)+dfs(i,j-1)
        return dfs(m-1,n-1)
  

#更严谨的写法，因为第一行和第一列的1，实际上也是(0,0)转移而来，所以应该只有(0,0)返回1，
# class Solution:
#     def uniquePaths(self, m: int, n: int) -> int:
#         @cache
#         def dfs(i:int ,j:int) -> int:
#             if i<0 or j<0:
#                 return 0
#             if i==0 and j==0:
#                 return 1
#             return dfs(i-1,j)+dfs(i,j-1)
#         return dfs(m-1,n-1)
```

**1:1递推**

注意：这里由于我们处理了第一行第一列，所以可以直接从1开始处理，而没必要填充空位。

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int [][]f =new int [m+1][n+1];
        for(int i=0;i<m;i++) f[i][0]=1;
        for(int j=0;j<n;j++) f[0][j]=1;
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                f[i][j]=f[i][j-1]+f[i-1][j];
            }
        }
        return f[m-1][n-1];
    }
}
```

**空间优化**

我们依然可以只保留一维。

首先是优化到两个数组，然后分析一下，发现可以省到用一个数组。

- 第二维需要都初始化为1。和二维时一样

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int []f =new int [n];
        Arrays.fill(f,1);
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                f[j]=f[j-1]+f[j];
            }
        }
        return f[n-1];
    }
}
```

### 63. 不同路径 II

[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

![image-20240424204048501](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424204048501.png)

思路：

回溯想法：

- 可以直接用62的代码，只不过当$grid[i][j]==1$时，因为是障碍物，所以可以直接返回0

```python
class Solution:
    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:
        @cache
        def dfs(i:int ,j:int) -> int:
            if(grid[i][j]==1):#起点也可能是障碍物，所以这个优先级最高
                return 0
            if(i<0 or j<0):
                return 0
            if(i==0 and j==0):
                return 1
            return dfs(i-1,j)+dfs(i,j-1)
        return dfs(len(grid)-1,len(grid[0])-1)
```

1:1转化为递推



$f[i][j]=f[i-1][j]+f[i][j-1]$

**边界**

这里注意，起点以及第一行和第一列都可能存在障碍。所以不能直接初始化他们为1

> 第一行/第一列的1，本来也是起点(0,0)转移过去的

**我们要判断当前节点之前是不是有障碍，如果有，那么之后都初始化为0,否则为1**

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] grid) {
        int n=grid.length,m = grid[0].length;
        int [][]f =new int[n][m];
        for(int i=0;i<n;i++){
            if(grid[i][0]==1) break;
            f[i][0]=1;
        }
        for(int j=0;j<m;j++){
            if(grid[0][j]==1) break;
            f[0][j]=1;
        }
        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                if(grid[i][j]==1) f[i][j]=0;
                else
                    f[i][j]=f[i-1][j]+f[i][j-1];
            }
        }
        return f[n-1][m-1];
    }
}
```

### 64. 最小路径和

[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240424210706449.png" alt="image-20240424210706449" style="zoom:80%;" />

思路：







## 总结

### 思路启发

如何着手一个问题。

- 如果是两端的那种问题，从问题的起点/终点状态分析会更容易，因为此时只需要考虑一边，另一边是边界。

- 如果是统计，遍历，或者是需要暴力的，那么也可以搜索或者DP。因为本质上他们就是暴力，只是更优雅

