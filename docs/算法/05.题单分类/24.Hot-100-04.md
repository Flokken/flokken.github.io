---
title: Hot100题单-04
date: 2024-07-22
tags: 
  - null
categories:  
  - 算法
  - 题单分类
---

## 70.爬楼梯

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240722105551173.png" alt="image-20240722105551173" style="zoom:80%;" />

思路：

先用回溯思考，从n开始思路，问题可以转化到n-1和n-2，那么

 $dfs(n)=dfs(n-1)+dfs(n-2)$

  边界:

 dfs(0)=1,dfs(1)=1,dfs(2)=2

空间优化：

由于只用到了两个值，所以可以只有两个变量来代替数组

- 注意f1原来的值会被覆盖，所以可以先用一个临时变量存下来

```java
class Solution {
    public int climbStairs(int n) {
        int f0=1,f1=1;
        for(int i=2;i<=n;i++){
            int newf=f0+f1;
            f0=f1;
            f1=newf;
        }
        return f1;
    }
}
```

## 118. 杨辉三角

[118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240722105852665.png" alt="image-20240722105852665" style="zoom:80%;" />

思路：

对于$dfs(i,j)$，有$dfs(i,j)=dfs(i-1,j-1)+dfs(i,j-1)$

边界：

对于第$i$行，

- 第一个元素的$j$是0，$j-1$是负数，越界了，需要特判
- 最后一个元素的$j$是$ans.get(i-1).size()$，也越界了，需要特判

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>>ans = new ArrayList<>();
        ans.add(new ArrayList<>(Arrays.asList(1)));
        //[0,numRows]行
        for(int i=1;i<numRows;i++){
            List<Integer>cur = new  ArrayList<>();
            for(int j=0;j<=i;j++){
                int x=0;
                if(j-1>=0) x+=ans.get(i-1).get(j-1);
                if(j<ans.get(i-1).size()) x+=ans.get(i-1).get(j);
                cur.add(x);
            }
            ans.add(cur);
        }
        return ans;
    }
}
```

## 198. 打家劫舍

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240722111816343.png" alt="image-20240722111816343" style="zoom:80%;" />

思路：

先回溯的想，对于第$n$间房子(区间是[0,n)，可以偷/不偷

- 偷，转移到$dfs(n-2)$，因为不能偷连续的；然后加上$nums[n]$
  - 注意数组下标是0到n-1,
- 不偷，转移到$dfs(n-1)$

所以有$dfs(i)=max(dfs(i-1),dfs(i-2)+nums[i])$

**转移为递推：**

$f[i]=max(f[i-1],f[i-2]+nums[i])$

边界：

如果i为0/1时，会出现负数下标，因此改造为

- $f[i+2]=max(f[i+1],f[i]+nums[i])$

- 同时根据题意，i=1或者0时，对应的f就是0

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        int []f= new int[n+2];
        for(int i=0;i<n;i++){
            f[i+2]=Math.max(f[i+1],f[i]+nums[i]);
        }
        return f[n+1];
    }
}
```

**空间优化**

由于只用了两个变量，所以可以省略数组

- 同样的，为了避免覆盖的问题，所以用一个临时变量把f1存起来

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        int f0=0,f1=0;
        for(int i=0;i<n;i++){
            int newf=f1;
            f1=Math.max(f1,f0+nums[i]);
            f0=newf;
        }
        return f1;
    }
}
```

