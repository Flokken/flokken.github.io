---
title: 区间DP
date: 2024-08-07
tags: 
  - null
categories:  
  - 算法
  - 题单分类
---

### 基础知识

线性DP(最常见的)：我们遇到的大部分DP题，一般是在数组前缀/后缀上转移（比如打家劫舍，编辑距离等等）。

区间DP:假设$(i,j)$代表一个区间，那么区间DP是从从小区间转移到大区间

DP和递归一样，一般都是两种思路，

- 起点/终点开始思考
  - 对于区间DP，起点就对应于小区间。而不像线性DP起点就是数组起点/终点

- 选或不选
  - 从两侧向内缩小问题规模，**同时也是从小区间转移到大区间**
    - 5 最长回文子串
    - 516最长回文子序列
- 枚举选哪个



### 516最长回文子序列

[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

我们这里采用选/不选的思路：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240219152631794.png" alt="img" style="zoom:80%;" />

因为子序列可以删除，所以我们可以从两端向内侧不断缩小，来确定最长的回文子序列。**注意这是递归的做法**

如果是循环来枚举时，仍然是从小区间到大区间。我们这里重点讲循环的做法

**状态定义：**

我们定义$f[i][j]$表示$s[i]$到$s[j]$中的最长回文子序列的长度。

- 注意，因为子序列是可以删除的，所以如果$(i,j)$是回文子序列，那么$x<i,y>j$的最长回文子序列也至少是$(i,j)$。也就是可以转移的

**转移方程：**

$f(i,j)= \begin{cases} 0&i>j \\ 1&i==j\\ f[i+1,j-1]+2& \text{s[i]=s[j]}\\ max(f[i+1,j],f[i,j-1])& \text{s[i]!=s[j]} \end{cases}$

**循环顺序**

- $f[i]$从$f[i+1]$转移过来，0所以$i$​需要**倒序枚举**
  - 这是显然是，如果正序枚举，我们计算$f[i]$是需要$f[i+1]$，但是这是$f[i+1]$​还没被更新，所以要倒序枚举

- $f[i][j]$从$f[i][j-1]$转移过来，所以$j$​是**正序枚举**
  - 首先，对于第二位，肯定需要先固定第一维，在都是$i$的情况下，$j$从$j-1$​​​而来，所以需要正序枚举
- 我们可以发现，这样的循环顺序正好也保证了$(i,j)$从小区间到大曲酒

**返回值**

$f[0][n-1]$

### 5. 最长回文子串

[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的 子串。

思路：

子串和子序列的区别在于不能删除元素了。那么上面那种定义状态表示长度的方法显然就不对。

- 比如"acaba",aca是回文子串，但是acaba不是。

**状态定义：**

定义$f[i][j]$表示字符串$s[i]$到$s[j]$是否为回文字符串

- 如果$f[i][j]==truw$，那么$j-i+1$就是这个回文子串的长度

**状态转移：**

分类讨论：

- 如果$s[i]==s[j]$，那么$f[i][j]= f[i-1][j+1]$

- 如果不相等，肯定是false

**特殊情况**，

- 如果是两个相等的相邻字符，也一定是回文子串。如`aa`，`bb`这种

- 如果$j-i==1 \quad and \quad s[i]==s[j]$，直接$dp[i][j]=true$

- 相当**于边界了，不需要再从上一个状态转移**，
  - 比如`f[1][2]`，他们应该从`f[2][1]`转移，而是直接为true


**循环顺序**

- $f[i]$从$f[i+1]$转移过来，0所以$i$​需要**倒序枚举**
  - 这是显然是，如果正序枚举，我们计算$f[i]$是需要$f[i+1]$，但是这是$f[i+1]$​还没被更新，所以要倒序枚举

- $f[i][j]$从$f[i][j-1]$转移过来，所以$j$​是**正序枚举**
  - 首先，对于第二位，肯定需要先固定第一维，在都是$i$的情况下，$j$从$j-1$​​​而来，所以需要正序枚举
- 我们可以发现，这样的循环顺序正好也保证了$(i,j)$从小区间到大曲酒

**初始化：**

对于一个字符串，肯定是$true$，所以$dp[i][i]=true$

```java
class Solution {
    public String longestPalindrome(String S) {
        char []s = S.toCharArray();
        int n=s.length;
        boolean [][]f = new boolean[n][n];
        int l=0,r=0,len=1;
        for(int i=0;i<n;i++) f[i][i]=true;
       for(int i=n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if(s[i]!=s[j]){
                    f[i][j]=false;
                }else{
                    if(j-i==1) {
                        f[i][j]=true;
                    }
                    else f[i][j]=f[i+1][j-1];
                }
                if(j-i+1>len &&f[i][j]){
                    l=i;
                    r=j;
                    len=j-i+1;
                }
            }  
        }
        return S.substring(l,r+1);
    }
}
```

