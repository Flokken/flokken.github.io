---
title: Hot100题单
date: 2024-06-27
tags: 
  - null
categories:  
  - 算法
  - 题单分类
---

## 常见术语

1.异位词，也称为重排，意思就是两个`tea`和`eat`这样的单词，他们根据同一方法排序后的字符串是一样的。

- 异位词的字符出现次数是一样的。   如果要分组可以**使用哈希表对排序后数组分组**

**2.子串，子序列。**

无论**子序列，子串，都是顺序有关的**，也就是不能对$s$重新排序

- 子串：下标连续
  - 举例：p="abc"
- 子序列，下标可以不连续
  - 举例：p="abd"

**3.子数组**

子数组也是顺序有关的

这里顺便引入一下子数组的概念，也经常见到。

子数组是数组中元素的连续非空序列。

比如数组[1,2,3,4,5]，那么[1,2]是子数组，[1,3]不是







## 练习

### 字母异位词

#### 49. 字母异位词分组]

[[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)](https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240627163615516.png" alt="image-20240627163615516" style="zoom:80%;" />

思路：

对于字母异位置词，他的字母都是一样的，所以可以直接比较排序后的字符串， 相等的分到一个组。

使用`<String,List<String>>`的哈希表会更好写

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {

        Map<String,List<String>>mp=new HashMap<>();
        for(String str:strs){
            char []s = str.toCharArray();
            Arrays.sort(s);
            mp.computeIfAbsent(new String(s),k->new ArrayList<>()).add(str);
            //**如果key存在则直接返回val，否则执行function得到value**，并且将(key,value)加入map中
        }
        return new ArrayList<>(mp.values());

    }
}
```



### 滑动窗口

#### 3. 无重复字符的最长子串

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

![image-20240630114514359](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240630114514359.png)

思路：

维护一个map，记录不重复的子串。

然后同向双指针，这是不定长滑动窗口，所以l，r都会用到

- r不断右移，如果mp中包含r指向的字符，那么说明这段序列有重复了
  - 那么需要不断让左侧的l左移，直到没有重复字符
- 更新答案。$r-l+1$即为序列长度

```java
class Solution {
    public int lengthOfLongestSubstring(String S) {
        char []s =S.toCharArray();
        Map<Character,Integer>mp = new HashMap<>();
        int l=0,r=0,n=s.length;
        int ans=0;
        while(r<n){
            while(mp.containsKey(s[r])){
                mp.remove(s[l]);
                l++;
            }
            mp.put(s[r],1);
            ans = Math.max(r-l+1,ans);
            r++;
        }
        return ans;
    }
}
```

#### 438. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

![image-20240630162754978](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240630162754978.png)

思路：

p的长度是固定的，所以对应的s中子串长度也应该固定。可以用一个哈希表维护p的中的字符个数**，然后对应子串如果字符统计完全一样，就说明是字母异位词**

具体算法：

- 使用长度为k的定长滑动窗口，利用指针r遍历子串，
  - 然后如果字符统计一样，就记录起始索引。
  - 然后r指向的字符加入统计，r-k指向的字符移除。对应就是次数+1/-1

```java
class Solution {;
    int []cnt1 =new int [26];
    int []cnt2 =new int [26];
    public List<Integer> findAnagrams(String S, String p) {
        char []s=S.toCharArray();
        int n=s.length,k=p.length();
        for(int i=0;i<k;i++){
            cnt2[p.charAt(i)-'a']++;
        }
        List<Integer>ans =new ArrayList<>();
        Map<Character,Integer>mp =new HashMap<>();
        for(int i=0;i<n;i++){
            cnt1[s[i]-'a']++;
            if(i>=k-1){
                if(equals()){
                    ans.add(i-k+1);
                }
                cnt1[s[i-k+1]-'a']--;
            }
        }
        return ans;
    }
    Boolean equals(){
        for(int i=0;i<26;i++){
            if(cnt1[i]!=cnt2[i]) return false;
        }
        return true;
    }
}
```

### 子串

#### 560. 和为 K 的子数组（前缀和）

[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

![image-20240630171915219](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240630171915219.png)

思路：

转换问题，既然子数组是连续的，那么就是求这个数组中，哪些区间的连续和是刚好为$k$。

那么就可以转换为前缀和的问题了，因为前缀和可以O(1)时间求区间连续和。

- 定义：$s[0]=0,s[1]=s[0]+nums[0],...s[i+1]=s[i]+nums[i]$

下标$i,j-1$的非空连续子数组和为$k$，那么

$s[j]-s[i]=k$可以转化成$s[i]=s[j]-k$

- **这里还要注意考虑 s[j]=k的情况，此时s[i]=0**

这样问题就再次转化为,统计有多少个$i$且$s[i]=s[j]-k$。**此时我们枚举$s[j]-k$的值即可，这样只需要一重循环**

> 我们之所以要这样转换，是因为暴力去枚举i，j是O(n2)的

**注意**：这里面存在一个问题，就是$s[0]=k=0$的情况，**因为前缀和数组第一项是0，那么如果k也为0，肯定就会多统计了答案。**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240702094359185.png" alt="image-20240702094359185" style="zoom:67%;" />

我们遍历$s$​数组时，可以先更新ans，再更新mp。

**这样刚开始枚举$s[0]=0$时，就不会多统计一次**

算法：

使用哈希表记录$s[]$即每个前缀和出现次数

- 注意需要加入$s[0]=0$也加入map中，因为这道题存在一个数=k的情况。
- 要想把任意子数组都表示成两个前缀和的差，必须添加 *s*[0]=0，**否则当子数组是前缀时，没法减去一个数**
- 注意需要先更新$ans$再更新$mp$

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n=nums.length;
        int []s = new int [n+1];
        Map<Integer,Integer>mp =new HashMap<>();
        for(int i=0;i<n;i++){
            s[i+1]=s[i]+nums[i];
        }
        int ans=0;
        for(int j=0;j<=n;j++){//枚举前缀和,注意从0开始枚举
            ans+=mp.getOrDefault(s[j]-k,0);//先更新答案，再更新统计，避免k=0的情况，多计数答案
            mp.put(s[j],mp.getOrDefault(s[j],0)+1);
        }
        return ans;
    }
}
```

#### 239. 滑动窗口最大值(注意list转int)

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

![image-20240702102954499](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240702102954499.png)

思路：

暴力做法：

每次新加入一个数时，就去找当前这个窗口里的最大值。这样的显然是O(n2)复杂度

**稍微好一点的想法：**

维护一个优先队列，每次移除第$i-k$元素，然后加入第$i$个元素。

这样做删除元素和加入元素都是O(logn)

**更好的做法，单调队列：**

维护一个单调队列（单减），然后用长度为k的窗口遍历数组。

遍历数组时：

- 加入元素，那么维护队尾，O(1)。
  - 把加入的元素与队尾比较，更小的元素不断出队
- 移除队首（保证在k的范围内），也是O(1)
  - 判断队首元素下标在不在$[i-k+1,i]$​这个范围内，不在则出队
    - 代入特殊值，[i,i+1]是两个数，那么如果k=2，对应就是[i-2+1,i]，所以是$[i-k+1,i]$

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer>qu= new ArrayDeque<>();
        List<Integer>ans =new ArrayList<>();
        //维护一个单调队列（单减）
        for(int i=0;i<nums.length;i++){
            //维护队尾
            while(!qu.isEmpty()&&nums[i]>=nums[qu.peekLast()]){
                qu.pollLast();
            }
            qu.addLast(i);
            //维护队首，保证队首在窗口内
            while(!qu.isEmpty()&&i-qu.peekFirst()>=k){
                qu.pollFirst();
            }
            //更新答案
            if(i>=k-1){//[0,k-1]是k个数
                ans.add(nums[qu.peekFirst()]);
            }

        }
        //先将ans这个列表转换为一个流，然后利用mapToInt对每个元素都转换成int  ,最后用toArrray收集到int型数组中
        //Integer::valueof就是Integer转int
        //注意这里的toArray()和list的不一样，这里没有传参数是因为，这里的toArray是 stream的，他知道元素是int型的，所以可以直接调用。
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

#### 76. 最小覆盖子串（注意同时有大小写字母如何处理）

[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

![image-20240702192406070](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240702192406070.png)

思路：

子串是顺序相关的，所以我们可以滑动窗口能不能做。

如果维护一个窗口，内部统计字符数，然后与$t$的比较，那么遍历一边更新最小值即可。

具体做法：由于不确定最小的窗口大小，所以这是不定长滑动窗口

- 每次$r$指向元素进入窗口，更新统计
- 尝试移除左端点字符，如果依然覆盖了$t$字符，就移除，否则不移除。
- 更新答案。
- 这样遍历一遍，答案集合中包含了所有可能的窗口，所以是正确的。

注意：

- 这道题还有一个难点，输入是既有大写也有小写字母的，因此用字符数组处理时得判断是大写还是小写的
- 这种情况

```java
class Solution {
      char []cnt1 =new char [128];
        char []cnt2 =new  char[128];
    public String minWindow(String S, String t) {
  
        char []s = S.toCharArray();
        for(int i=0;i<t.length();i++){
            cnt2[trans(t.charAt(i))]++;
        }
        int l=0,r=0,n=s.length;
        int x=-1,y=-1,ans=1000000;
        while(r<n){
            cnt1[trans(s[r])]++;
            while(contains()){
                cnt1[trans(s[l])]--;
                l++;
                if(!contains()){//贪心找最小窗口的情况
                    l--;
                    cnt1[trans(s[l])]++;
                    break;
                }
            }
            if((r-l+1<ans)&&contains()){//可以更新答案
                x=l;
                y=r;
                ans=r-l+1;
            }
            r++;
        }
        return x==-1?"":S.substring(x,y+1);
    }
    public Boolean contains(){
        for(int i=0;i<128;i++){
            if(cnt1[i]<cnt2[i]){
                return false;
            }
        }
        return true;
    }
    public int trans(char c){
        if(c>='A'&&c<='Z'){
            return c-'A';
        }else{
            return c-'a'+32;//在ascii码表中，'A'在前，'a'在后，并且差就是32
        }
    }
}
```

**代码优化：**

对于其中的左端点更新和答案更新，其实可以放到一起。

因为只有$contains()$为真时才可以更新答案，并且试探操作也只有为真时才需要试探。

```java
class Solution {
      char []cnt1 =new char [128];
        char []cnt2 =new  char[128];
    public String minWindow(String S, String t) {
  
        char []s = S.toCharArray();
        for(int i=0;i<t.length();i++){
            cnt2[trans(t.charAt(i))]++;
        }
        int l=0,r=0,n=s.length;
        int x=-1,y=-1,ans=1000000;
        while(r<n){
            cnt1[trans(s[r])]++;
            while(contains()){
                if(r-l+1<ans){
                    x=l;
                    y=r;
                    ans=r-l+1;
                }
                cnt1[trans(s[l])]--;
                l++;
            }
            r++;
        }
        return x==-1?"":S.substring(x,y+1);
    }
    public Boolean contains(){
        for(int i=0;i<128;i++){
            if(cnt1[i]<cnt2[i]){
                return false;
            }
        }
        return true;
    }
    public int trans(char c){
        if(c>='A'&&c<='Z'){
            return c-'A';
        }else{
            return c-'a'+32;//在ascii码表中，'A'在前，'a'在后，并且差就是32
        }
    }
}
```

### 普通数组

#### 53. 最大子数组和

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

![image-20240703090008125](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703090008125.png)

思路：

最大子数组有个常用的DP递推式。

$dp[i]=max(dp[i-1]+nums[i],nums[i])$

思想也很简单，我们从数组最后一个数字开始考虑，如果前面的数组和与当前nums[i]更大，那么需要更新答案。如果不是。那么就说明前面的是负数，我们记录当前值就是子数组的最大值（只有一个数）

算法：

状态定义：

定义$dp[i]$表示以$nums[i]$结尾的最大子数组和

分类讨论：

- $nums[i]$单独为一个子数组，那么$dp[i]=nums[i]$
- $nums[i]$和前面的子数组拼起来，也就是和以$nums[i-1]$结尾的最大子数组拼接

转移方程

- $dp[i]=nums[i]$

- $dp[i]=max(dp[i],0)+nums[i]$​

空间优化

由于只使用了上一个状态，因此可以用一个变量代替dp数组

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int []dp = new int[n+1];
        int max=nums[0];
        for(int i=0;i<n;i++){
            dp[i+1]=Math.max(dp[i]+nums[i],nums[i]);
            max=Math.max(dp[i+1],max);
        }
        return max;
    }
}
```

空间优化代码

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int pre=0;
        int dp=0;
        int max=nums[0];
        for(int i=0;i<n;i++){
            dp=Math.max(pre+nums[i],nums[i]);
            pre=dp;
            max=Math.max(dp,max);
        }
        return max;
    }
}
```

#### 56. 合并区间（注意怎么给点数组排序以及list转数组）

[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

思路：

没有什么很好的做法，这道题是模拟。

既然需要按照重叠来合并区间，那么我们可以先排序，这样可以减少变量。比如先对左端点升序排列，那么对于相邻的两个区间$[a_1,b_1]$和$[a_2,b_2]$，肯定有$a2>=a1$，那么有

- 如果$a2>b1$​，说明没有重叠
- 如果$a2<=b1$，说明有重叠，此时比较$b1,b2$
  - 如果$b1>b2$，那么合并后右端点是$b1$
  - 否则是$b2$​

**具体做法：**

维护一个答案集合，每次取最末尾的数组出去和当前数组的数组进行合并，然后在加入集合之中即可，一遍遍历可以实现，

- 注意要答案中有区间才从里面取，所以需要一个判断

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(x,y)->x[0]-y[0]);//左端点从小到大排序
        List<int []>ans =new ArrayList<>();
        for(int []p:intervals){
            int m=ans.size();
            if(m>0&&p[0]<=ans.get(m-1)[1]){//m>0表示答案集合中有数据才去取,后面那个是合并条件
                ans.get(m-1)[1]=Math.max(ans.get(m-1)[1],p[1]);//更新右端点最大值
            }else{//不相交，那么把现在这个区间加入答案集合
                ans.add(p);
            }
        }
        return ans.toArray(new int [ans.size()][]);//List转数组
    }
}
```

#### 189. 轮转数组

[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

![image-20240703114257729](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703114257729.png)

轮转相当于循环右移，那么对于$i$的数，移位后位置就在$(i+k)\%n$,n=nums.length

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n=nums.length;
        int []ans =new int[n];
        for(int i=0;i<n;i++){
            ans[i]=nums[i];
        }
        for(int i=0;i<n;i++){
            nums[(i+k)%n]=ans[i];
        }
    }
}
```

#### 238. 除自身以外数组的乘积

[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

![image-20240703114735065](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703114735065.png)

思路：

前后缀分解。分别用两个数组记录前缀的乘积和后缀的乘积。

那么$ans[i]=pre[i-1]*suf[i-1]$​

注意：

- 考虑边界0,n-1。为了避免出现负数，我们最好把$pre,suf$都弄成0-n。然后$pre[0]=1,suf[n]=1$。这样可以避免求ans的时候需要特判

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int []pre = new int[n];
        pre[0]=nums[0];
        for(int i=1;i<n;i++){
            pre[i]=pre[i-1]*nums[i];
        }
        int []suf = new int[n];
        suf[n-1]=nums[n-1];
        for(int i=n-2;i>=0;i--){
            suf[i]=suf[i+1]*nums[i];
        }
        List<Integer>ans=new ArrayList<>();
        ans.add(suf[1]);
        for(int i=1;i<n-1;i++){
            ans.add(pre[i-1]*suf[i+1]);
        }
        ans.add(pre[n-2]);
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

#### 41. 缺失的第一个正数

[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

![image-20240703195313195](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703195313195.png)

思路：

1.如果使用O(n)的额外空间，可以有一个好想的思路。因为数组长度是10^5,那么可以一遍遍历统计1-1e5的数出现过没有。

在一遍遍历找第一个没出现的数即可。

- 根据题意，负数和零不需要统计

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int []cnt=new int[100002];
        int max=0;
        for(int num:nums){
            if(num>=1&&num<=100000){
                cnt[num]=1;
                max=Math.max(max,num);
            }
        }
        int ans=0;
        for(int i=1;i<=max+1;i++){
            if(cnt[i]!=1){
                ans=i;
                break;
            }
        }
        return ans;

    }
}
```

2.不使用额外空间，那么肯定就是要原地操作$nums$数组，根据上面的做法可以发现，长度为n的数组，最小的正整数一定在$[1,n+1]$之间。我们可以在遍历数组时，将$num>=1\quad and\quad nums<=n$都换到正确的num的位置中，然后再从1开始找最小即可。

### 矩阵

#### 73. 矩阵置零

[73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

![image-20240703213606392](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703213606392.png)

思路：

如果0在首行/首列，那么这一行一列置零即可。如果不是就比较麻烦。

所以可以想到，先遍历一次矩阵，如果某个点为0，就把其在首行/首列对应的点标记为零

- 注意，不能直接处理首行首列，必须用标记数组来记录，。
- 因为直接处理首行首列会导致后面也跟着变，没法迭代处理，**只能先用标记数组存起来。**

然后再遍历一遍矩阵，如果其对应首行/首列有零，就应该标记为零。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m=matrix.length,n=matrix[0].length;
        int []L =new int[m];
        int []H=new  int [n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]==0){
                    L[i]=1;
                    H[j]=1;
                }
            }
        }
        for(int i=0;i<m;i++){
           for(int j=0;j<n;j++){
                if(L[i]==1||H[j]==1){
                    matrix[i][j]=0;
                }
           }
        }
    
    }
}
```

#### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704082407357.png" alt="image-20240704082407357" style="zoom:80%;" />

思路：

其实就是蛇形数组。对于下标的变化，就是四个方向，可以用一个位置变量来表示当前的方向，每次遇到边界就换方向。

还有一点就是边界是会变的，所以可以用标记数字记录已经访问的数字，这个也可以比较方便的判断边界。

具体做法：

- 移动一般用数组表示,这里是蛇形数组，对应是$dx=[0,1,0,-1],dy=[1,0,-1,0]$​
- 每次输出一个点后就标记这个点，标记后的点也算边界
  - 由于是从(0,0)出发，边界判断就是$x==m|| y==n  || x<0 || y<0 || vis[x][y]==1$​
  - 为了方便边界处理，可以先每次算出下一个点之后，再去判断边界，如果是边界，再变换方向重新算下一个点即可

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m=matrix.length,n=matrix[0].length;
        int [][]vis=new int [m][n];
        int []dx = {0,1,0,-1};
        int []dy={1,0,-1,0};
        int turn=0;
        int i=0,j=0,tot=0;
        List<Integer>ans =new ArrayList<>();
        while(tot<m*n){//0-m*n-1个点
            vis[i][j]=1;
            ans.add(matrix[i][j]);
            int x=i+dx[turn];
            int y=j+dy[turn];
            if(x==m|| y==n  || x<0 || y<0 || vis[x][y]==1){
                turn=(turn+1)%4;
                x=i+dx[turn];
                y=j+dy[turn];
            }
            //下一个点坐标
            i=x;
            j=y;
            tot++;
        }
               
        return ans;
    }
}
```

#### 48. 旋转图像

[48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704092400129.png" alt="image-20240704092400129" style="zoom:80%;" />

**思路：**

主要得找规律，对于一个点$(i,j)$，顺时针旋转90度之后就是$(j,n-i-1)$

> 点2：(0,1)->(1,2)，点9，(2,2)->(2,0)

由于翻转后的点会覆盖原本数据**，所以还是需要一个数组把原本矩阵记录下来**。

**具体做法：**

先备份一个数组，然后利用这个数组算出翻转后数组，注意：

- 由于之前的公式是原数组->翻转数组，现在是翻转数组->原数组，要倒着推一下
  - 假设翻转后数组点是(x,y)，那么翻转前的点就是(n-y-1)(x)
    - 我们设(x=j,y=n-i-1)，那么可以算出(i=n-y-1,j=x)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int m=matrix.length;
        int n=matrix[0].length;
        int [][]pre = new int [m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                pre[i][j]=matrix[i][j];
            }
        }

        for(int x=0;x<m;x++){
             for(int y=0;y<n;y++){
                matrix[x][y]=pre[n-y-1][x];
            }
        }
        
    }
}
```

#### 240. 搜索二维矩阵 II

[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

![image-20240704095645411](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704095645411.png)

思路：

第一次做，我的想法是做n次二分，但是这样不好实现，并且麻烦。

更好的思路参考：https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/2783938/tu-jie-pai-chu-fa-yi-tu-miao-dong-python-kytg

简单来说就是，我们可以利用每行每列都是升序的性质，判断每行最后一个元素与寻找元素的大小，这样可以快速确定行号。同时也可以通过比较判断是否在当前列上，如果比当前元素小，那么肯定在这个列的左边。

具体做法：

从最右上角的点(0,n-1)出发，根据当前元素和target的比较，可以不断改变(i,j)，直到找到/越界。

- 循环条件就是$i<matrix.length\quad and \quad j>=0$

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length;
        int n=matrix[0].length;
        int i=0,j=n-1;
        while(i<matrix.length&&j>=0){
            if(matrix[i][j]==target) return true;
            if(matrix[i][j]<target){
                i++;//这一行剩余元素全部大于target，排除
            }else{
                j--;//这一列元素全部大于target，排除
            }
        }
        return false;
    }
}
```

### 链表

注意：

- 链表节点经常会用一个dummy哑结点来辅助操作
  - 特别涉及删除，合并等操作时，有些样例可能是空，如果不使用哑变量，很容易被卡
  - 比如删除节点，这种代码` cur.next=cur.next.next;`很容易被卡。只不过使用哑变量，可能循环区间等也需要对应改变一下
- 注意$xxx.next$​访问有没有可能产生空指针异常

总结：

- **基本都需要哑变量/哨兵变量**
- 如果是反转链表，需要$pre,cur,next$
- 如果是删除，需要操作删除节点的前一个节点

#### 160. 相交链表

[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 

![image-20240704110430835](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704110430835.png)

思路：

先遍历一个链表，然后用map记录节点。在遍历另一个找第一个出现的就是相交节点。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> se= new HashSet<>();
        while(headA!=null){
            se.add(headA);
            headA=headA.next;
        }
        while(headB!=null){
            if(se.contains(headB)){
                return headB;
            }
            headB=headB.next;
        }
        return null;
    }
}
```

#### 206. 反转链表

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704111238488.png" alt="image-20240704111238488" style="zoom:80%;" />

思路：

记录前一个节点，然后再当前节点求出下一个节点后，更改当前节点的连接到上一个节点即可。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
  
        ListNode pre =null;
        while(head!=null){
            ListNode next = head.next;
            head.next=pre;
            pre=head;
            head=next;//继续处理下一个节点。
        }
        //最后pre会更新为当前节点，因此结束时pre就是最后一个节点
        return pre;
            
    }
}
```

#### 234. 回文链表

[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

![image-20240705100419218](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705100419218.png)

思路：

先转成数字记录，然后再使用双指针进行回文数组判断。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer>ans=new ArrayList<>();
        while(head!=null){
            ans.add(head.val);
            head=head.next;
        }
        int n=ans.size();
        int l=0,r=n-1;
        while(l<r){
            if(ans.get(l)!=ans.get(r)){
                return false;
            }
            l++;
            r--;
        }
        return true;
    }
}
```

#### 141. 环形链表（快慢指针）

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705100545560.png" alt="image-20240705100545560" style="zoom:80%;" />

思路：

快慢指针，我们让快指针一次走两步，慢指针一次走一步。

由于快慢指针都会走到环里，那么他们一定会相遇。

- 可以引入**相对速度**，可以看成慢指针不动，快指针每次走一步，那么他们一定会在环里相遇。

**细节：**

- 写循环条件时，对于快指针，由于每次走两步，所以判断条件是$fast!=null \quad and\quad fast.next!=null$

```java

public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow =head,fast=head;
        while(fast!=null&&fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
            if(fast==slow)
                return true;
        }
        return false;
        
    }
}
```

#### 142. 环形链表 II（列方程，快慢指针）

[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705105544957.png" alt="image-20240705105544957" style="zoom:80%;" />

思路：

首先提一个结论

当快慢指针相遇时，慢指针还没有走完一圈。



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705112156224.png" alt="image-20240705112156224" style="zoom:67%;" />

然后可以推导得出

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705112247396.png" alt="image-20240705112247396" style="zoom: 67%;" />

根据等式$a-c=(k-1)(b+c)$

**在快慢指针相遇之后，再来一个slow2从head出发，这段距离是a，而slow1离入口是c。那么：**

- slow1走到入口后，slow2离入口还有(a-c)的距离，刚好是环长倍数。所以继续走下去，slow1和slow2一定在入口相遇。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705113454073.png" alt="image-20240705113454073" style="zoom:67%;" />

思考：为什么说快慢指针相遇时，慢指针移动距离小于环长（也就是慢指针一圈都没走完）？

考虑最差的情况，进入环时fast只比slow多走一步，那么fast要追上slow就需要走n-1个单位时间。

那么同时slow也不可能走超过$n-1$个单位时间，证明完毕。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705142934592.png" alt="image-20240705142934592" style="zoom:67%;" />

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null&&fast.next!=null){//避免fast.next.next的空指针异常
            fast=fast.next.next;
            slow=slow.next;
            if(slow==fast){
                while(slow!=head){
                    slow=slow.next;
                    head=head.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```

#### 21. 合并两个有序链表

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705150659600.png"/>

思路：

同时操作两个链表节点，比较值大小。

使用一个dummy节点记录起始位置，然后不断把有序的节点接上去即可。

注意：

- 在循环时，我们判断条件是两个链表当前节点都不为空，所以有可能导致更长链表没有接上去。
- 所以循环外面需要补上

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode();
        ListNode head = dummy;
        while(list1!=null&&list2!=null){
            if(list1.val<=list2.val){
                dummy.next=list1;
                list1=list1.next;
            }else{
                dummy.next=list2;
                list2=list2.next;
            }
            dummy=dummy.next;
        }
        //把没有遍历完的部分接上
        dummy.next = list1!=null?list1:list2;
        return head.next;
    }
}
```

#### 2. 两数相加

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

![image-20240705152915598](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705152915598.png)

思路：

直接模拟，每次如果当前节点对应和大于等于10就需要进1.

- 由于是逆序存储的，所以一开始就是最低位，那么两两从最低位开始加即可
- 如果一个链表更长，那么需要在后面接上，并且最后的那一位也要考虑进位
- 注意，如果最后add还为1，说明还需一个新节点

直观实现一下。下面还有更简洁的写法

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        
        int add=0;
        ListNode dummy=new ListNode();
        ListNode head =dummy;
        while(l1!=null&&l2!=null){
            int sum=l1.val+l2.val;
            ListNode cur = new ListNode((sum+add)%10);
            add = (sum+add)>=10?1:0;//下一位的进位
            dummy.next=cur;
            dummy=dummy.next;
            l1=l1.next;
            l2=l2.next;
        }
        //下面这两个while最多只会执行其中一个
        while(l1!=null){
            ListNode cur = new ListNode((l1.val+add)%10);
            add = (l1.val+add)>=10?1:0;//下一位的进位
            dummy.next=cur;
            dummy=dummy.next;
            l1=l1.next;
        }
        while(l2!=null){
            ListNode cur = new ListNode((l2.val+add)%10);
            add = (l2.val+add)>=10?1:0;//下一位的进位
            dummy.next=cur;
            dummy=dummy.next;
            l2=l2.next;
        }
        
        if(add!=0){
            dummy.next=new ListNode(1);
        }
        return head.next;
    }
}
```

**更简洁的写法，我们发现三段其实内容都差不多，因此可以把判断条件写一起来循环。**

然后根据判断条件决定是否执行一些步骤

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode();//哨兵节点
        ListNode cur = dummy;//迭代节点
        int add=0;
        while(l1!=null || l2!=null ||add!=0){
            if(l1!=null) add+=l1.val;
            if(l2!=null) add+=l2.val;
            cur.next = new ListNode(add%10);

            add/=10;
            cur=cur.next;
            if(l1!=null) l1=l1.next;
            if(l2!=null)l2=l2.next;
    
        }
        return dummy.next;
    }
}
```

#### 19. 删除链表的倒数第 N 个结点（哨兵节点）

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705155344899.png" alt="image-20240705155344899" style="zoom: 80%;" />

思路：

要删除倒数第n个节点，那么可以让两个指针s1,s2间距n出发，那么当s1到达末尾时，s2指向倒数n+1的节点。

此时操作s2即可达到删除节点目的。

> 这种做法细节多，不好写。最好还需要用哑变量，让第二个指针从哑变量出发，不然删除的如果是最后一个节点，需要特判。

简单的做法是先一遍遍历求长度，然后再第倒数n+1个节点处进行操作。（操作删除节点之前的那个节点）

- 顺序遍历，我们在第$k-n$​​处进行操作，这是删除节点的前一个节点
  - 循环区间应该是$[1,k-n)$

注意：

这道题有一个很坑的点，就是可以只有一个节点，那么删除之后，就应该返回空

那么`    cur.next=cur.next.next;`就会报错，解决办法两种：

- 从哑变量出发，这样的话就走。这样的话循环区间应该是$[1,k-n+1]$
- 特判

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new  ListNode(0,head);

        //计算长度
        ListNode cur =head;
        int k=0;
        while(cur!=null){
            cur=cur.next;
            k++;
        }

        //删除时从哑变量出发
        cur=dummy;
        for(int i=1;i<k-n+1;i++){
            cur=cur.next;
        }
        //
        cur.next=cur.next.next;

        return dummy.next;
    }
}
```

#### 24. 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705164902784.png" alt="image-20240705164902784" style="zoom:80%;" />

思路：

- 从dummy节点出发，更好处理，少特判输入为空等情况

每两个节点进行交换，所以需要每次处理两个节点，**注意我们从哑变量出发**

- 循环条件`head!=null&&head.next!=null`
- 更新条件: `head=head.next.next;`跳到当前节点的下下个节点

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode();
        dummy.next=head;
        while(head!=null&&head.next!=null){
            int tmp=head.val;
            head.val=head.next.val;
            head.next.val = tmp;

            head=head.next.next;
        }
        return dummy.next;
    }
}
```

#### 92. 反转链表 II

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)



#### 25. K 个一组翻转链表

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

![image-20240705171047552](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705171047552.png)

思路：

- 同样的，需要利用哑变量来操作更方便

- 首先求出长度，然后将每k个节点分为一组，每一组里面边反向。
- 还需要每个组连起来，所以上一组最后一个节点应该用于下一组的首节点的哑变量
