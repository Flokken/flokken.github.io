---
title: Hot100题单-01
date: 2024-06-27
tags: 
  - null
categories:  
  - 算法
  - 题单分类

---

## 常见术语

1.异位词，也称为重排，意思就是两个`tea`和`eat`这样的单词，他们根据同一方法排序后的字符串是一样的。

- 异位词的字符出现次数是一样的。   如果要分组可以**使用哈希表对排序后数组分组**

**2.子串，子序列。**

无论**子序列，子串，都是顺序有关的**，也就是不能对$s$重新排序

- 子串：下标连续
  - 举例：p="abc"
- 子序列，下标可以不连续
  - 定义：子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
  - 举例：p="abd"
  

**3.子数组**

子数组也是顺序有关的

这里顺便引入一下子数组的概念，也经常见到。

子数组是数组中元素的连续非空序列。

比如数组[1,2,3,4,5]，那么[1,2]是子数组，[1,3]不是

## 常用API

### Arrays

| 名字                                    | 作用                                |
| --------------------------------------- | ----------------------------------- |
| Arrays.sort(int []nums)                 | 返回一个                            |
| Arrays.asList(nums1,nums2,.../一个数组) | 返回一个[nums1,nums2,...]这样的列表 |

### List

| 名字                     | 作用                                |
| ------------------------ | ----------------------------------- |
| List.of(nums1,nums2,...) | 返回一个[nums1,nums2,...]这样的列表 |



## 练习

### 哈希

#### 1. 两数之和

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240727220420000.png" alt="image-20240727220420000" style="zoom:80%;" />

思路：

维护一个hash表的同时，遍历一遍数组，如果出现$target-x$，说明找到了这一对。

- key是数组元素，val是元素下标

题目说了只有一对。

```java
class Solution {
    public int[] twoSum(int[] nums, int tar) {
        Map<Integer,Integer>mp =new  HashMap<>();
        int n=nums.length;
        for(int i=0;i<n;i++){
            if(mp.containsKey(tar-nums[i])){
                return new int[]{i,mp.get(tar-nums[i])};
            }
            mp.put(nums[i],i);
        }
        return new int[]{};
    }
}
```

#### 49. 字母异位词分组

[[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)](https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240627163615516.png" alt="image-20240627163615516" style="zoom:80%;" />

思路：

对于字母异位置词，他的字母都是一样的，所以可以直接比较排序后的字符串， 相等的分到一个组。

使用`<String,List<String>>`的哈希表会更好写

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        //异位词就是重排
        //哈希表,key是排序后字符串，val是列表
        Map<String,List<String>>mp =new HashMap<>();
        int n=strs.length;
        for(int i=0;i<n;i++){
            char s[]=strs[i].toCharArray();
            Arrays.sort(s);
            mp.computeIfAbsent(new String(s),k->new ArrayList<>()).add(strs[i]);
        }
        return new  ArrayList<>(mp.values());

        

    }
}
```

#### 128. 最长连续序列(并查集)

[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240727221101969.png" alt="image-20240727221101969" style="zoom: 80%;" />

思路：

如果把每个连续序列看成一个集合，那么答案就是最长的序列长度。

算法：

注意nums[i]有正有负，并且上限是1e9，因此

1.根据nums数组构建parent

2.遍历数组，对每个nums判断是否有nums+1，如果有就合并到一个结合中

3.再遍历数组，把每个元素x当成左边界，`find(x)`就是右边界，去最长的序列长度即可

```java
class Solution {
    int count=0;//多少个集合/树
    Map<Integer,Integer>mp =new HashMap<>();
    public int longestConsecutive(int[] nums) {
        for(int num:nums){//初始化
            mp.put(num,num);
        }
        for(int num:nums){
            if(mp.containsKey(num+1)){
                union(num,num+1);
            }
        }
        int size=0;
        for(int num:nums){
            size=Math.max(size,find(num)-num+1);
        }
        return size;

    }
    public int find(int x){
        if(mp.get(x)!=x){
            mp.put(x,find(mp.get(x)));
        }
        return mp.get(x); 
    }
    public void union(int p,int q){//这里需要x<y，也就是让y当合并后的根节点
        int x=find(p);
        int y=find(q);
        if(x==y) return;
        mp.put(x,y);
    }
}
```

###  双指针

#### 283. 移动零

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240728102542439.png" alt="image-20240728102542439" style="zoom:80%;" />

思路：

由于最终我们要让这个数组后面全是0，并且数组中其他元素顺序不变，那么只能不断交换。

这里可以让两个指针$l,r$一起移动，他们性质如下：

- $l$指向**已经处理好的序列的尾部**(的后一位)	
  - 这个数可以是0，也可以不是
- $r$指向**待处理的序列的头部**（待处理的序列的第一位）

每次$r$遇到非零元素时，与左指针交换元素

所以有

- $[,l)$都是非零数
- $[l,r)$全是0

**模拟来感受一下：**

假设数组是[1,1,0,3,12]

- r指向1，那么l也会指向1
- r指向2，那么l也会指向2
- r指向0，l指向0，但是此时l停留在0，但是r继续增长
- r指向3，l指向0，两者交换，然后l++，r++。

所以可以发现，

- 每次r指向0时，l就会停留在这个零，然后r继续迭代，指向非零数时来交换

**拓展思考：**

Q1：如果希望是把0都移动到头部，并且其他元素都保持相对顺序呢？

A:做法不变，只需要让$l,r$都从$n-1$出发即可

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //l是非零元素末尾
        //r是0开头位置
        //保持顺序，那么就一直顺序交换
        //只要nums[r]不为零，就应该不断和l指向元素交换
        int l=0,r=0;
        int n=nums.length;
        while(r<n){
            if(nums[r]!=0){
                int tmp=nums[l];
                nums[l]=nums[r];
                nums[r]=tmp;
                l++;
            }
            r++;

        }
    }
}
```

#### 11. 盛最多水的容器

[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240728105654931.png" alt="image-20240728105654931" style="zoom:80%;" />

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240728105708500.png" alt="image-20240728105708500" style="zoom:67%;" />

思路：

 计算面积，是二维的。所以我们应该固定一维来确定面积。

对于最大面积$S$对应的最大的$H$一定是某个$height[i],0<=i<n$

- 反证法证明，如果H取到的是$h$不是$heigth[i]$而是其一部分，那么一定可以取对应的$Height[i]$,面积会更大

暴力做法：

每次都对于某个$H$，计算其他所有的边，来计算面积，这样是O(n2)

**更好的做法：**

如果从两端开始计算面积，由于宽度一定是变小，所以一次遍历也是可以的？

分类讨论如下：

我们随便选两条线，比如题目中红色的两条线L>R，我们固定线R，去蓝色区域中选一个红线，然容器更大

- 如果线比L/R长，那么容器高度不变，宽度变小，水更少
- 如果线比R短，那么容器高度变小，宽度变小，水更少

所以此时R不管和谁组合，都不会更优，**可以去掉**

- 对于另一边也是同样的道理。

所以我们可以想到

- 应该从两边向中间逼近，那么就是双指针
- 当L>R或者R>L时，对应指针需要移动，寻找可能的最大值

**具体算法：**

- 初始化两个指针$L=0,R=n-1$
- 每次先算出来当前容器来更新答案
  - 如果L指向数<R，L++
  - 如果L指向数>R，R--
  - 如果相等，L--或者R--都可以

这样做一定包含了最优的情况，我们同时维护最大值即可。

> 这道题没有排序，但是仍然通过讨论的方法，分析出根据题意，可以通过$O(1)$的操作得到$O(n)$的信息

```java
class Solution {
    public int maxArea(int[] height) {
        int n=height.length;
        int l=0,r=n-1;
        int max=0;
        while(l<r){
            max=Math.max((r-l)*Math.min(height[l],height[r]),max);
            if(height[l]<height[r]){
                l++;
            }else{
                r--;
            }
        }
        return max;
    }
}
```

#### 15. 三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240728112621618.png" alt="image-20240728112621618" style="zoom:80%;" />

思路:

最暴力的想法就是直接三重循环来枚举，但是会超时。

**转化一下：**

题目说顺序不重要，并且$i!=j,j!=k$

- 那么设定一个顺序即$i<j<k$

固定$nums[i]$的情况下，使用相向双指针枚举$nums[j],nums[k]$，这样是二重循环。

- $0<=i<=n-1$
- $i<j<k<=n-1$

这里还存在两个问题，答案要求三元组不重复，如何保证；**左右指针如何移动，条件是什么**？

- 如果是直接像上面一样枚举，然后用set记录，不好实现

- 问题1：感官上，如果先给数组排序，那么每次枚举时，遇到的数应该是不一样的

  - 但是可能数组中存在很多重复数字，仍然可能导致重复。我们给数组排序后，**当前元素如果和上一个元素相等**，直接跳过

    - 每次比较$nums[i]$和$nums[i-1]$是否相等

      - 相等则continue

    - 在内部枚举$nums[j],nums[k]$时，

      - 也要比较是否和对应上一个元素相等，相等则跳过

      - ```java
         while(j<k&&nums[j]==nums[j-1]) j++;
        while(k>j&&nums[k]==nums[k+1]) k--
        ```

  - 因为我们是$i,j,k$这样来枚举的，又给数组排序了，所以相等的元素为零的集合上一次一定枚举过了，可以跳过

- 问题2：如果我们给数组升序排列后，假设和为$S$

  - S==0,  j+=1,k-=1
  - S>0,  k-=1
  - S>0,k+=1

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        List<List<Integer>>ans=new ArrayList<>();
        for(int i=0;i<n-2;i++){
            System.out.println(nums[i]);
            if(i!=0&&nums[i]==nums[i-1]) continue;//防从重复
            int j=i+1;
            int k=n-1;
            while(j<k){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum==0){
                    List<Integer>tmp = new ArrayList<>();
                    tmp.add(nums[i]);
                    tmp.add(nums[j]);
                    tmp.add(nums[k]);
                    ans.add(tmp);
                    j++;
                    k--;
                    while(j<k&&nums[j]==nums[j-1]){
                        j++;
                    }
                    while(j<k&&nums[k]==nums[k+1]) {
                        k--;
                 
                    }
                }else if(sum<0){
                    j++;
                }else{
                    k--;
                }
            }
        }
        return ans;
    }
}
```

#### 42. 接雨水

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240728154741253.png" alt="image-20240728154741253" style="zoom:80%;" />

思路：

如果把每根柱子看成水桶，我们可以发现，假设当前柱子高度是$h$，那么这里能接的水的量就是其左边的最大值$pre[i]$和右边的最大值$suf[i]$

两者中取小的，然后减去h即可。

即:$min(pre[i],suf[i])-h$

- 这里$pre$和$suf$找最大值时也包括$i$

具体做法：

前后缀分解。

- 用前后缀数组分别记录$i$两边的最大值。

- 然后遍历一遍数组求和即可

```java
class Solution {
    public int trap(int[] height) {
        int n=height.length;
        int []pre=new int[n];
        int []suf= new int[n];
        pre[0]=height[0];
        for(int i=1;i<n;i++){
            pre[i]=Math.max(pre[i-1],height[i]);
        }
        suf[n-1]=height[n-1];
        for(int i=n-2;i>=0;i--){
            suf[i]=Math.max(suf[i+1],height[i]);
        }
        int ans=0;
        for(int i=0;i<n;i++){
            ans+=Math.min(suf[i],pre[i])-height[i];
        }
        return ans;
    }
}
```



### 滑动窗口

#### 3. 无重复字符的最长子串

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

![image-20240630114514359](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240630114514359.png)

思路：不定长滑动窗口

维护一个map，记录不重复的子串。

然后同向双指针，这是不定长滑动窗口，所以l，r都会用到

- r不断右移，如果mp中包含r指向的字符，那么说明这段序列有重复了
  - 那么需要不断让左侧的l左移，直到没有重复字符
- 更新答案。$r-l+1$即为序列长度

```java
class Solution {
 
    public int lengthOfLongestSubstring(String S) {
        char []s= S.toCharArray();
        Set<Character>set= new HashSet<>();
        int l=0,r=0;
        int len=0;
        int n=s.length;
        //r不断右探，然后更新窗口
        while(r<n){
            while(l<r&&set.contains(s[r])){
                set.remove(s[l]);
                l++;
            }
            set.add(s[r]);
            len=Math.max(len,r-l+1);
            r++;
        }
        return len;
        
    }
}
```

#### 438. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

![image-20240630162754978](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240630162754978.png)

思路：  定长滑动窗口

p的长度是固定的，所以对应的s中子串长度也应该固定。可以用一个哈希表维护p的中的字符个数**，然后对应子串如果字符统计完全一样，就说明是字母异位词**

具体算法：

- 使用长度为k的定长滑动窗口，利用指针r遍历子串，
  - **窗口内容是k长的子串内字符出现次数**
  - 然后如果字符统计一样，就记录起始索引。
  - 然后r指向的字符加入统计，r-k指向的字符移除。对应就是次数+1/-1
  
- 还有一种思路，就是比较排序后的p和对应s中的子串，但是由于里面涉及排序和字符串操作，效率会低很多

```java
class Solution {
    int []cnt1=new int [26];
    int []cnt2=new int [26];
    public List<Integer> findAnagrams(String S, String P) {
        char []s =S.toCharArray();
        char []p =P.toCharArray();
        for(char x:p) cnt2[x-'a']++;
        List<Integer>ans= new ArrayList<>();
        int r=0;
        int n=s.length;
        int k=p.length;
        while(r<n){
            cnt1[s[r]-'a']++;
            if(r>=k-1){
                //0-k-1，刚好k个字符
                if(equals()) ans.add(r-k+1);
                cnt1[s[r-k+1]-'a']--;
            }

            r++;
        }
        return ans;
        
    }
    public Boolean  equals(){
        for(int i=0;i<26;i++){
            if(cnt1[i]!=cnt2[i]) return false;
        }
        return true;
    }
}
```

第二种思路

- 注意此时r表示的字符串长度，主要是配合substring，左闭右开

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n=s.length();
        List<Integer>ans =new ArrayList<>();
        char []re=p.toCharArray();
        Arrays.sort(re);
        int k=p.length();
        String res =new String(re);
        int r=0;
        while(r<n){
            r++;
            if(r>=k){
                char []tmp =s.substring(r-k,r).toCharArray();
                Arrays.sort(tmp);
                String cur=new String(tmp);
                if(cur.equals(res)){
                    ans.add(r-k);
                }
            }
        }
        return ans;
    }
}
```





### 子串

#### 560. 和为 K 的子数组（前缀和+哈希+细节）

[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

![image-20240630171915219](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240630171915219.png)

思路：

转换问题，既然子数组是连续的，那么就是求这个数组中，哪些区间的连续和是刚好为$k$。

那么就可以转换为前缀和的问题了，因为前缀和可以O(1)时间求区间连续和。

- 定义：$s[0]=0,s[1]=s[0]+nums[0],...s[i+1]=s[i]+nums[i]$

下标$i,j-1$的非空连续子数组和为$k$，那么

$s[j]-s[i]=k$可以转化成$s[i]=s[j]-k$

- **这里还要注意考虑 s[j]=k的情况，此时s[i]=0**

这样问题就再次转化为,统计有多少个$i$且$s[i]=s[j]-k$。**此时我们枚举$s[j]-k$的值即可，这样只需要一重循环**

- 这里还有一个隐性条件，枚举$j$时，要保证$j>i$,  所以是一边计算一边维护$mp$

> 我们之所以要这样转换，是因为暴力去枚举i，j是O(n2)的

**注意**：这里面存在一个问题，就是$s[0]=k=0$的情况，**因为前缀和数组第一项是0，那么如果k也为0，肯定就会多统计了答案。**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240702094359185.png" alt="image-20240702094359185" style="zoom:67%;" />

我们遍历$s$​数组时，可以先更新ans，再更新mp。

**这样刚开始枚举$s[0]=0$时，就不会多统计一次**

算法：

使用哈希表记录$s[]$即每个前缀和出现次数

- 注意需要加入$s[0]=0$也加入map中，因为这道题存在一个数=k的情况。
- 要想把任意子数组都表示成两个前缀和的差，必须添加 *s*[0]=0，**否则当子数组是前缀时，没法减去一个数**
- 注意需要先更新$ans$再更新$mp$

细节：

- 1.为什么不能是先把所有的$s[i]$加到$mp$中，再进行计算？

  - 比如先加进去， <font color="red" size="3">因为此时就无法保证下面计算时， j>i这个条件了</font>，这样会导致多计数

  - 所以是一边计算，一边把s[i]加进去，这保证枚举$s[j]$时，mp里存的都是$i<j$

    - ```java
      for(int i=0;i<=n;i++)             mp.put(s[i],mp.getOrDefault(s[i],0)+1);
      ```

- 2.为什么先更新答案，再更新$mp$?
  - 因为$k$可以是0，$k$时0，枚举第$j=0$的时候,就错误的多计数了

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n=nums.length;
        int []s = new int [n+1];
        Map<Integer,Integer>mp =new HashMap<>();
        for(int i=0;i<n;i++){
            s[i+1]=s[i]+nums[i];
        }
        int ans=0;
        for(int j=0;j<=n;j++){//枚举前缀和
            ans+=mp.getOrDefault(s[j]-k,0);
            mp.put(s[j],mp.getOrDefault(s[j],0)+1);
        }
        return ans;
    }
}
```

#### 239. 滑动窗口最大值(注意list转int)

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

![image-20240702102954499](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240702102954499.png)

思路：

暴力做法：

每次新加入一个数时，就去找当前这个窗口里的最大值。这样的显然是O(n2)复杂度

**稍微好一点的想法：**

维护一个优先队列，每次移除第$i-k$元素，然后加入第$i$个元素。

这样做删除元素和加入元素都是O(logn)

**更好的做法，单调队列：**

维护一个单调队列（单减），然后用长度为k的窗口遍历数组。

遍历数组时：

- 加入元素，那么维护队尾，O(1)。
  - 把加入的元素与队尾比较，更小的元素不断出队
- 移除队首（保证在k的范围内），也是O(1)
  - 判断队首元素下标在不在$[i-k+1,i]$​这个范围内，不在则出队
    - 代入特殊值，[i,i+1]是两个数，那么如果k=2，对应就是[i-2+1,i]，所以是$[i-k+1,i]$

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer>qu= new ArrayDeque<>();
        List<Integer>ans =new ArrayList<>();
        //维护一个单调队列（单减）
        for(int i=0;i<nums.length;i++){
            //维护队尾
            while(!qu.isEmpty()&&nums[i]>=nums[qu.peekLast()]){
                qu.pollLast();
            }
            qu.addLast(i);
            //维护队首，保证队首在窗口内
            while(!qu.isEmpty()&&i-qu.peekFirst()>=k){
                qu.pollFirst();
            }
            //更新答案
            if(i>=k-1){//[0,k-1]是k个数
                ans.add(nums[qu.peekFirst()]);
            }

        }
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

#### 76. 最小覆盖子串（注意同时有大小写字母如何处理）

[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

![image-20240702192406070](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240702192406070.png)

思路：

子串是顺序相关的，所以我们可以滑动窗口能不能做。

如果维护一个窗口，内部统计字符数，然后与$t$的比较，那么遍历一边更新最小值即可。

具体做法：由于不确定最小的窗口大小，所以这是不定长滑动窗口

- 每次$r$指向元素进入窗口，更新统计
- 尝试移除左端点字符，如果依然覆盖了$t$字符，就移除，否则不移除。
- 更新答案。
- 这样遍历一遍，答案集合中包含了所有可能的窗口，所以是正确的。

注意：

- 这道题还有一个难点，输入是既有大写也有小写字母的，因此用字符数组处理时得判断是大写还是小写的
- 这种情况

**代码优化：**

对于其中的左端点更新和答案更新，其实可以放到一起。

因为只有$contains()$为真时才可以更新答案，并且试探操作也只有为真时才需要试探。

```java
class Solution {
      char []cnt1 =new char [128];
        char []cnt2 =new  char[128];
    public String minWindow(String S, String t) {
  
        char []s = S.toCharArray();
        for(int i=0;i<t.length();i++){
            cnt2[trans(t.charAt(i))]++;
        }
        int l=0,r=0,n=s.length;
        int x=-1,y=-1,ans=1000000;
        while(r<n){
            cnt1[trans(s[r])]++;
            while(contains()){
                if(r-l+1<ans){
                    x=l;
                    y=r;
                    ans=r-l+1;
                }
                cnt1[trans(s[l])]--;
                l++;
            }
            r++;
        }
        return x==-1?"":S.substring(x,y+1);
    }
    public Boolean contains(){
        for(int i=0;i<128;i++){
            if(cnt1[i]<cnt2[i]){
                return false;
            }
        }
        return true;
    }
    public int trans(char c){
        if(c>='A'&&c<='Z'){
            return c-'A';
        }else{
            return c-'a'+32;//在ascii码表中，'A'在前，'a'在后，并且差就是32
        }
    }
}
```

### 普通数组

#### 53. 最大子数组和

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

![image-20240703090008125](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703090008125.png)

思路：

最大子数组有个常用的DP递推式。

$dp[i]=max(dp[i-1]+nums[i],nums[i])$

思想也很简单，我们从数组最后一个数字开始考虑，如果前面的数组和与当前nums[i]更大，那么需要更新答案。如果不是。那么就说明前面的是负数，我们记录当前值就是子数组的最大值（只有一个数）

算法：

状态定义：

定义$dp[i]$表示以$nums[i]$结尾的最大子数组和

分类讨论：

- $nums[i]$单独为一个子数组，那么$dp[i]=nums[i]$
- $nums[i]$和前面的子数组拼起来，也就是和以$nums[i-1]$结尾的最大子数组拼接

转移方程

- $dp[i]=nums[i]$
- $dp[i]=max(dp[i],0)+nums[i]$​

空间优化

由于只使用了上一个状态，因此可以用一个变量代替dp数组

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int []dp =new int[n+1];
        int max=Integer.MIN_VALUE;
        for(int i=0;i<n;i++){
            dp[i+1]=Math.max(dp[i]+nums[i],nums[i]);
            max=Math.max(max,dp[i+1]);
        }
        return max;
    }
}
```

空间优化代码

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int pre=0;
        int dp=0;
        int max=nums[0];
        for(int i=0;i<n;i++){
            dp=Math.max(pre+nums[i],nums[i]);
            pre=dp;
            max=Math.max(dp,max);
        }
        return max;
    }
}
```

#### 56. 合并区间（注意怎么给点数组排序以及list转数组）

[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

思路：

没有什么很好的做法，这道题是模拟。

既然需要按照重叠来合并区间，那么我们可以先排序，这样可以减少变量。比如先对左端点升序排列，那么对于相邻的两个区间$[a_1,b_1]$和$[a_2,b_2]$，肯定有$a2>=a1$，那么有

- 如果$a2>b1$​，说明没有重叠
- 如果$a2<=b1$，说明有重叠，此时比较$b1,b2$
  - 如果$b1>b2$，那么合并后右端点是$b1$
  - 否则是$b2$​

**具体做法：**

维护一个答案集合，每次取最末尾的数组出去和当前数组的数组进行合并，然后在加入集合之中即可，一遍遍历可以实现，

- 注意要答案中有区间才从里面取，所以需要一个判断

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(x,y)->x[0]-y[0]);//左端点从小到大排序
        List<int []>ans =new ArrayList<>();
        for(int []p:intervals){
            int m=ans.size();
            if(m>0&&p[0]<=ans.get(m-1)[1]){//m>0表示答案集合中有数据才去取,后面那个是合并条件
                ans.get(m-1)[1]=Math.max(ans.get(m-1)[1],p[1]);//更新右端点最大值
            }else{//不相交，那么把现在这个区间加入答案集合
                ans.add(p);
            }
        }
        return ans.toArray(new int [ans.size()][]);//List转数组
    }
}
```

#### 189. 轮转数组

[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

![image-20240703114257729](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703114257729.png)

轮转相当于循环右移，那么对于$i$的数，移位后位置就在$(i+k)\%n$,n=nums.length

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n=nums.length;
        int []ans =new int[n];
        for(int i=0;i<n;i++){
            ans[i]=nums[i];
        }
        for(int i=0;i<n;i++){
            nums[(i+k)%n]=ans[i];
        }
    }
}
```

#### 238. 除自身以外数组的乘积(前后缀分解)

[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

![image-20240703114735065](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703114735065.png)

思路：

前后缀分解。分别用两个数组记录前缀的乘积和后缀的乘积。

那么$ans[i]=pre[i-1]*suf[i-1]$​

注意：

- 考虑边界0,n-1。为了避免出现负数，我们最好把$pre,suf$都弄成0-n。然后$pre[0]=1,suf[n]=1$。这样可以避免求ans的时候需要特判

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int []pre = new int[n];
        pre[0]=nums[0];
        for(int i=1;i<n;i++){
            pre[i]=pre[i-1]*nums[i];
        }
        int []suf = new int[n];
        suf[n-1]=nums[n-1];
        for(int i=n-2;i>=0;i--){
            suf[i]=suf[i+1]*nums[i];
        }
        List<Integer>ans=new ArrayList<>();
        ans.add(suf[1]);
        for(int i=1;i<n-1;i++){
            ans.add(pre[i-1]*suf[i+1]);
        }
        ans.add(pre[n-2]);
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

#### 41. 缺失的第一个正数

[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

![image-20240703195313195](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703195313195.png)

思路：

1.如果使用O(n)的额外空间，可以有一个好想的思路。因为数组长度是10^5,那么可以一遍遍历统计1-1e5的数出现过没有。

在一遍遍历找第一个没出现的数即可。

- 根据题意，负数和零不需要统计

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int []cnt=new int[100002];
        int max=0;
        for(int num:nums){
            if(num>=1&&num<=100000){
                cnt[num]=1;
                max=Math.max(max,num);
            }
        }
        int ans=0;
        for(int i=1;i<=max+1;i++){
            if(cnt[i]!=1){
                ans=i;
                break;
            }
        }
        return ans;

    }
}
```

2.不使用额外空间，那么肯定就是要原地操作$nums$数组，根据上面的做法可以发现，长度为n的数组，最小的正整数一定在$[1,n+1]$之间。我们可以在遍历数组时，将$num>=1\quad and\quad nums<=n$都换到正确的num的位置中，然后再从1开始找最小即可。

### 矩阵

#### 73. 矩阵置零

[73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

![image-20240703213606392](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240703213606392.png)

思路：

如果0在首行/首列，那么这一行一列置零即可。如果不是就比较麻烦。

所以可以想到，先遍历一次矩阵，如果某个点为0，就把其在首行/首列对应的点标记为零

- 注意，不能直接处理首行首列，必须用标记数组来记录，。
- 因为直接处理首行首列会导致后面也跟着变，没法迭代处理，**只能先用标记数组存起来。**

然后再遍历一遍矩阵，如果其对应首行/首列有零，就应该标记为零。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m=matrix.length,n=matrix[0].length;
        int []L =new int[m];
        int []H=new  int [n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]==0){
                    L[i]=1;
                    H[j]=1;
                }
            }
        }
        for(int i=0;i<m;i++){
           for(int j=0;j<n;j++){
                if(L[i]==1||H[j]==1){
                    matrix[i][j]=0;
                }
           }
        }
    
    }
}
```

#### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704082407357.png" alt="image-20240704082407357" style="zoom:80%;" />

思路：

其实就是蛇形数组。对于下标的变化，就是四个方向，可以用一个位置变量来表示当前的方向，每次遇到边界就换方向。

还有一点就是边界是会变的，所以可以用标记数字记录已经访问的数字，这个也可以比较方便的判断边界。

具体做法：

- 移动一般用数组表示,这里是蛇形数组，对应是$dx=[0,1,0,-1],dy=[1,0,-1,0]$​
- 每次输出一个点后就标记这个点，标记后的点也算边界
  - 由于是从(0,0)出发，边界判断就是$x==m|| y==n  || x<0 || y<0 || vis[x][y]==1$​
  - 为了方便边界处理，可以先每次算出下一个点之后，再去判断边界，如果是边界，再变换方向重新算下一个点即可

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m=matrix.length,n=matrix[0].length;
        int [][]vis=new int [m][n];
        int []dx = {0,1,0,-1};
        int []dy={1,0,-1,0};
        int turn=0;
        int i=0,j=0,tot=0;
        List<Integer>ans =new ArrayList<>();
        while(tot<m*n){//0-m*n-1个点
            vis[i][j]=1;
            ans.add(matrix[i][j]);
            int x=i+dx[turn];
            int y=j+dy[turn];
            if(x==m|| y==n  || x<0 || y<0 || vis[x][y]==1){
                turn=(turn+1)%4;
                x=i+dx[turn];
                y=j+dy[turn];
            }
            //下一个点坐标
            i=x;
            j=y;
            tot++;
        }
               
        return ans;
    }
}
```

#### 48. 旋转图像

[48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704092400129.png" alt="image-20240704092400129" style="zoom:80%;" />

**思路：**

主要得找规律，对于一个点$(i,j)$，顺时针旋转90度之后就是$(j,n-i-1)$

> 点2：(0,1)->(1,2)，点9，(2,2)->(2,0)

由于翻转后的点会覆盖原本数据**，所以还是需要一个数组把原本矩阵记录下来**。

**具体做法：**

先备份一个数组，然后利用这个数组算出翻转后数组，注意：

- 由于之前的公式是原数组->翻转数组，现在是翻转数组->原数组，要倒着推一下
  - 假设翻转后数组点是(x,y)，那么翻转前的点就是(n-y-1)(x)
    - 我们设(x=j,y=n-i-1)，那么可以算出(i=n-y-1,j=x)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int m=matrix.length;
        int n=matrix[0].length;
        int [][]pre = new int [m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                pre[i][j]=matrix[i][j];
            }
        }

        for(int x=0;x<m;x++){
             for(int y=0;y<n;y++){
                matrix[x][y]=pre[n-y-1][x];
            }
        }
        
    }
}
```

#### 240. 搜索二维矩阵 II

[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

![image-20240704095645411](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704095645411.png)

思路：

第一次做，我的想法是做n次二分，但是这样不好实现，并且麻烦。

更好的思路参考：https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/2783938/tu-jie-pai-chu-fa-yi-tu-miao-dong-python-kytg

简单来说就是，我们可以利用每行每列都是升序的性质，判断每行最后一个元素与寻找元素的大小，这样可以快速确定行号。同时也可以通过比较判断是否在当前列上，如果比当前元素小，那么肯定在这个列的左边。

具体做法：

从最右上角的点(0,n-1)出发，根据当前元素和target的比较，可以不断改变(i,j)，直到找到/越界。

- 循环条件就是$i<matrix.length\quad and \quad j>=0$

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length;
        int n=matrix[0].length;
        int i=0,j=n-1;
        while(i<matrix.length&&j>=0){
            if(matrix[i][j]==target) return true;
            if(matrix[i][j]<target){
                i++;//这一行剩余元素全部小于target，排除
            }else{
                j--;//这一列元素全部大于target，排除
            }
        }
        return false;
    }
}
```

使用n次二分的写法

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        //对每行进行二分查找
        int n=matrix.length;
        int m=matrix[0].length;
        for(int i=0;i<n;i++){
            int j=bins(matrix[i],target);
            if(j!=m&&matrix[i][j]==target) return true;
        }
        return false;
    }
    public int bins(int []nums,int target){
        //左闭右开写法
        int l=0,r=nums.length;
        //[0,r)
        while(l<r){
            int mid=l+(r-l)/2;
            if(nums[mid]<target){
                l=mid+1;
            }else{
                r=mid;
            }
        }
        return l;
    }
}
```





### 链表

注意：

- 链表节点经常会用一个dummy哑结点来辅助操作
  - 特别涉及删除，合并等操作时，有些样例可能是空，如果不使用哑变量，很容易被卡
  - 比如删除节点，这种代码` cur.next=cur.next.next;`很容易被卡。只不过使用哑变量，可能循环区间等也需要对应改变一下
- 注意$xxx.next$​访问有没有可能产生空指针异常

总结：

- **基本都需要哑变量/哨兵变量**
- 如果是反转链表，至少需要$pre,cur$，这样每次只反转一个节点的连接
  - 也可以每次改三个next，但是那种写法容易出错
- 如果是删除，需要操作删除节点的前一个节点

#### 160. 相交链表

[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 

![image-20240704110430835](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704110430835.png)

思路：

先遍历一个链表，然后用map记录节点。在遍历另一个找第一个出现的就是相交节点。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> se= new HashSet<>();
        while(headA!=null){
            se.add(headA);
            headA=headA.next;
        }
        while(headB!=null){
            if(se.contains(headB)){
                return headB;
            }
            headB=headB.next;
        }
        return null;
    }
}
```

#### 206. 反转链表

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240704111238488.png" alt="image-20240704111238488" style="zoom:80%;" />

思路：

记录前一个节点，然后再当前节点求出下一个节点后，更改当前节点的连接到上一个节点即可。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
  
        ListNode pre =null;
        while(head!=null){
            ListNode next = head.next;
            head.next=pre;
            pre=head;
            head=next;//继续处理下一个节点。
        }
        //最后pre会更新为当前节点，因此结束时pre就是最后一个节点
        return pre;
            
    }
}
```

#### 234. 回文链表

[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

![image-20240705100419218](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705100419218.png)

思路：

先转成数字记录，然后再使用双指针进行回文数组判断。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer>ans=new ArrayList<>();
        while(head!=null){
            ans.add(head.val);
            head=head.next;
        }
        int n=ans.size();
        int l=0,r=n-1;
        while(l<r){
            if(ans.get(l)!=ans.get(r)){
                return false;
            }
            l++;
            r--;
        }
        return true;
    }
}
```

#### 141. 环形链表（快慢指针）

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705100545560.png" alt="image-20240705100545560" style="zoom:80%;" />

思路：

快慢指针，我们让快指针一次走两步，慢指针一次走一步。

由于快慢指针都会走到环里，那么他们一定会相遇。

- 可以引入**相对速度**，可以看成慢指针不动，快指针每次走一步，那么他们一定会在环里相遇。

**细节：**

- 写循环条件时，对于快指针，由于每次走两步，所以判断条件是$fast!=null \quad and\quad fast.next!=null$

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow =head,fast=head;
        while(fast!=null&&fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
            if(fast==slow)
                return true;
        }
        return false;
        
    }
}
```

#### 142. 环形链表 II（列方程，快慢指针）

[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705105544957.png" alt="image-20240705105544957" style="zoom:80%;" />

思路：

首先提一个结论

当快慢指针相遇时，慢指针还没有走完一圈。



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705112156224.png" alt="image-20240705112156224" style="zoom:67%;" />

然后可以推导得出

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705112247396.png" alt="image-20240705112247396" style="zoom: 67%;" />

根据等式$a-c=(k-1)(b+c)$

**在快慢指针相遇之后，再来一个slow2从head出发，这段距离是a，而slow1离入口是c。那么：**

- slow1走到入口后，slow2离入口还有(a-c)的距离，刚好是环长倍数。所以继续走下去，slow1和slow2一定在入口相遇。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705113454073.png" alt="image-20240705113454073" style="zoom:67%;" />

思考：为什么说快慢指针相遇时，慢指针移动距离小于环长（也就是慢指针一圈都没走完）？

考虑最差的情况，进入环时fast只比slow多走一步，那么fast要追上slow就需要走n-1个单位时间。

那么同时slow也不可能走超过$n-1$个单位时间，证明完毕。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705142934592.png" alt="image-20240705142934592" style="zoom:67%;" />

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null&&fast.next!=null){//避免fast.next.next的空指针异常
            fast=fast.next.next;
            slow=slow.next;
            if(slow==fast){
                while(slow!=head){
                    slow=slow.next;
                    head=head.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```

#### 21. 合并两个有序链表

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705150659600.png"/>

思路：

同时操作两个链表节点，比较值大小。

使用一个dummy节点记录起始位置，然后不断把有序的节点接上去即可。

注意：

- 在循环时，我们判断条件是两个链表当前节点都不为空，所以有可能导致更长链表没有接上去。
- 所以循环外面需要补上

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode();
        ListNode head = dummy;
        while(list1!=null&&list2!=null){
            if(list1.val<=list2.val){
                dummy.next=list1;
                list1=list1.next;
            }else{
                dummy.next=list2;
                list2=list2.next;
            }
            dummy=dummy.next;
        }
        //把没有遍历完的部分接上
        dummy.next = list1!=null?list1:list2;
        return head.next;
    }
}
```

#### 2. 两数相加

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

![image-20240705152915598](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705152915598.png)

思路：

直接模拟，每次如果当前节点对应和大于等于10就需要进1.

- 由于是逆序存储的，所以一开始就是最低位，那么两两从最低位开始加即可
-   如果一个链表更长，那么需要在后面接上，并且最后的那一位也要考虑进位
- 注意，如果最后add还为1，说明还需一个新节点

直观实现一下。下面还有更简洁的写法

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        
        int add=0;
        ListNode dummy=new ListNode();
        ListNode head =dummy;
        while(l1!=null&&l2!=null){
            int sum=l1.val+l2.val;
            ListNode cur = new ListNode((sum+add)%10);
            add = (sum+add)>=10?1:0;//下一位的进位
            dummy.next=cur;
            dummy=dummy.next;
            l1=l1.next;
            l2=l2.next;
        }
        //下面这两个while最多只会执行其中一个
        while(l1!=null){
            ListNode cur = new ListNode((l1.val+add)%10);
            add = (l1.val+add)>=10?1:0;//下一位的进位
            dummy.next=cur;
            dummy=dummy.next;
            l1=l1.next;
        }
        while(l2!=null){
            ListNode cur = new ListNode((l2.val+add)%10);
            add = (l2.val+add)>=10?1:0;//下一位的进位
            dummy.next=cur;
            dummy=dummy.next;
            l2=l2.next;
        }
        
        if(add!=0){
            dummy.next=new ListNode(1);
        }
        return head.next;
    }
}
```

**更简洁的写法，我们发现三段其实内容都差不多，因此可以把判断条件写一起来循环。**

然后根据判断条件决定是否执行一些步骤

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode();//哨兵节点
        ListNode cur = dummy;//迭代节点
        int add=0;
        while(l1!=null || l2!=null ||add!=0){
            if(l1!=null) add+=l1.val;
            if(l2!=null) add+=l2.val;
            cur.next = new ListNode(add%10);

            add/=10;
            cur=cur.next;
            if(l1!=null) l1=l1.next;
            if(l2!=null)l2=l2.next;
    
        }
        return dummy.next;
    }
}
```

#### 19. 删除链表的倒数第 N 个结点（哨兵节点）

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705155344899.png" alt="image-20240705155344899" style="zoom: 80%;" />

思路：

要删除倒数第n个节点，那么可以让两个指针s1,s2间距n出发，那么当s1到达末尾时，s2指向倒数n+1的节点。

此时操作s2即可达到删除节点目的。

> 这种做法细节多，不好写。最好还需要用哑变量，让第二个指针从哑变量出发，不然删除的如果是最后一个节点，需要特判。

简单的做法是先一遍遍历求长度，然后再第倒数n+1个节点处进行操作。（操作删除节点之前的那个节点）

- 顺序遍历，我们在第$k-n$​​处进行操作，这是删除节点的前一个节点
  - 循环区间应该是$[1,k-n)$

注意：

这道题有一个很坑的点，就是可以只有一个节点，那么删除之后，就应该返回空

那么`    cur.next=cur.next.next;`就会报错，解决办法两种：

- 从哑变量出发，这样的话就走。这样的话循环区间应该是$[1,k-n+1]$
- 特判

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new  ListNode(0,head);

        //计算长度
        ListNode cur =head;
        int k=0;
        while(cur!=null){
            cur=cur.next;
            k++;
        }

        //删除时从哑变量出发
        cur=dummy;
        for(int i=1;i<k-n+1;i++){
            cur=cur.next;
        }
        //
        cur.next=cur.next.next;

        return dummy.next;
    }
}
```

#### 24. 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705164902784.png" alt="image-20240705164902784" style="zoom:80%;" />

思路：

- 从dummy节点出发，更好处理，少特判输入为空等情况

每两个节点进行交换，所以需要每次处理两个节点，**注意我们从哑变量出发**

- 循环条件`head!=null&&head.next!=null`
- 更新条件: `head=head.next.next;`跳到当前节点的下下个节点

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode();
        dummy.next=head;
        while(head!=null&&head.next!=null){
            int tmp=head.val;
            head.val=head.next.val;
            head.next.val = tmp;

            head=head.next.next;
        }
        return dummy.next;
    }
}
```

#### 92. 反转链表 II

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240706085734643.png" alt="image-20240706085734643" style="zoom: 80%;" />

思路：

> [灵神视频](https://www.bilibili.com/video/BV1sd4y1x7KN/?spm_id_from=333.999.0.0&vd_source=d005def162a369d30cf8c241225a9395)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240706090634977.png" alt="image-20240706090634977" style="zoom:67%;" />

链表反转涉及两个问题：

- 反转区间内部的节点需要反转
- 反转区间外部节点与反转后区间节点的连接
- 特殊情况，如果反转区间$left=1$怎么办？  引入哨兵节点$dummy$

1.链表反转每个节点时，对于**反转的区间，每次可以只操作一个**

我们可以把反转链表的过程归纳到操作一个节点，每次只改一个节点的next。

- 把当前节点的$next$接到$pre$​上去
- 然后$pre$更新到cur的位置，$cur$更新到之前的$next$的位置
  - 注意由于$cur$的next会被覆盖，所以需要先用一个$nxt$把他存下来

反转结束后，从原来链表上看**,cur和pre始终保持以下性质：**

- $pre$指向反转这一段区间的末尾（**反转后序列起点**）
- $cur$​​指向后续反转区间的第一个节点

2.还需要把反转区间外的节点连到反转后区间的位置

引入正常区间最后一个节点$p0$

- **p0始终指向当前要反转的区间的前一个节点**

连接有两步：

- $p0.next.next$连到5，也就是2和5连起来
- $p0.next=2$，也就是把1和2连起来

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240706094102176.png" alt="image-20240706094102176" style="zoom:67%;" />

当**一段区间反转完成后**，$p0$和$p0.next$也需要更新才能保证区间的正确性

[1,2,3,4,5]，反转[2,3,4]后应该得到[1,4,3,2,5]

- $p0$需要跟着更新到$pre$的位置，因为可能后面还有反转的区间
- $p0.next$应该更新为$cur$的位置，**这样就算连起来了**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240706094220577.png" alt="image-20240706094220577" style="zoom:80%;" />

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240706094535726.png" alt="image-20240706094535726" style="zoom:67%;" />

3.如果$left=1$，那么我们可以让$p0$从$dummy$开始，就可以避免出错

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0,head);
        ListNode p0= dummy;
        int k=0;
        while(k<left-1){
            p0=p0.next;//p0停在left左边第一个节点
            k++;
        }
        ListNode cur = p0.next;
        ListNode pre=null;//注意这里初始化为null，因为在还没开始反转，所以上一段反转后的最后一个节点就是null
        for(int i=left;i<=right;i++){//区间内反转
            ListNode nxt = cur.next;
            cur.next= pre;
            pre=cur;
            cur=nxt;
        }
        //区间外连接
        p0.next.next=cur;//p0.next和下一段区间连接
        p0.next=pre;//p0和新起点连接
        return dummy.next;
    }
}
```

#### 25. K 个一组翻转链表

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240705171047552.png" alt="image-20240705171047552" style="zoom: 80%;" />

思路：

在92的基础上，每次还需要更新$p0$和$p0.next$

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode();
        dummy.next=head;

        ListNode cur =head;
        int n=0;
        while(cur!=null){
            n++;
            cur=cur.next;
        }
        ListNode pre = null;//注意这里初始化为null，因为在还没开始反转，所以上一段反转后的最后一个节点就是null
        cur=head;
        ListNode p0=dummy;
        for(;n>=k;n-=k){//把每个k组都进行反转
            for(int i=0;i<k;++i){
                ListNode nxt = cur.next;
                cur.next = pre;
                pre=cur;
                cur=nxt;
            }
            //上面循环出来时
            //cur是下一轮的第一个节点
            //pre是上一轮反转后的最后一个节点(区间起点)
            //p0.next是当前轮反转后区间末尾，需要连到下一段头部即cur
            //p0需要更新为下一轮要反转区间左边（left）的第一个节点，就是p0.next          
            //p0.next更新为cur

            ListNode nxt = p0.next;
            p0.next.next=cur;
            p0.next=pre;
            p0=nxt;//因为这一段已经更新完了，所以p0也需要更新为上一段反转后的尾结点

        }
        return dummy.next;
    }
}
```

#### 138. 随机链表的复制

[138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

<img src="C:/Users/28788/AppData/Roaming/Typora/typora-user-images/image-20240709093248495.png" alt="image-20240709093248495" style="zoom:80%;" />

思路：

题目看起来有点绕，总结一下就是，有一个链表，其节点都有一个random指针指向任意节点。现在需要新建一个链表，与原链表完全相同，包括值和random的指向。（除了地址）。

由于random指向的是node，但是一开始我们还没有新建链表，所以应该先构建好链表后再给random赋值。

random的指向如何搞呢？

- 可以使用一个map，记录当前节点和新建节点之间的关系。
- 注意由于要返回新建后的头节点，所以也需要一个哨兵节点
- 为了方便原链表遍历，原链表也需要哨兵节点

```java
class Solution {
    public Node copyRandomList(Node head) {
        Map<Node,Node>mp =new HashMap<>();
        Node dummy1 = new Node(-1);
        dummy1.next=head;
        Node dummy2= new  Node(-1);
        Node head2= dummy2;
        while(head!=null){
            Node cur = new Node(head.val);
            mp.put(head,cur);
            head=head.next;

            head2.next=cur;
            head2=cur;
        }
        head2=dummy2.next;
        head = dummy1.next;
        while(head2!=null){
            head2.random = mp.get(head.random);
            head=head.next;
            head2=head2.next;
        }
        return dummy2.next;
    }
    
}
```

#### 148.排序链表

[148. 排序链表](https://leetcode.cn/problems/sort-list/)

![image-20240709103716343](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240709103716343.png)

思路：

直接对链表排序

- 注意需要更新最后一个节点的next为null

```java
class Solution {
    public ListNode sortList(ListNode head) {
        List<ListNode>list = new  ArrayList<>();
        while(head!=null){
            list.add(head);
            head=head.next;
        }
        Collections.sort(list,(x,y)->(x.val-y.val));
        ListNode dummy = new  ListNode(-1);
        ListNode cur = dummy;
        for(var node:list){
            cur.next=node;
            cur=node;
        }
        cur.next=null;//最后一个节点后面需要置为null
        return dummy.next;
    }
}
```

#### 23. 合并 K 个升序链表（常考）

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240710093003367.png" alt="image-20240710093003367" style="zoom:80%;" />

思路：

由于所有组都已经是升序排列，那么第一个最小的元素肯定就在所有的头结点里，假设是这个点$h$，而第二个最小的节点，就在$h.next$和剩余头结点里。

所以可以用一个最小堆维护节点集合，每次找到最小点后，就把这个点的next加到集合中。最小堆性质

- 找到当前最小点，并可以移除
- 插入节点

具体算法：

- 首先把所有头结点入队，不断弹出最小节点$x$，如果$x.next$​不为空则入堆，直到堆为空
- 还需要依次拼接节点，使用哨兵节点更好操作

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode>pq= new PriorityQueue<>((a,b)->a.val-b.val);
        for(ListNode head:lists){
            if(head!=null){
                pq.offer(head);
            }
        }
        ListNode dummy = new ListNode();
        ListNode head = dummy;
        while(!pq.isEmpty()){
            ListNode node =pq.poll();//最小节点
            if(node.next!=null){
                pq.offer(node.next);
            }
            head.next=node;
            head=node;
        }
        return dummy.next;
    }
}
```

#### 146. LRU 缓存

[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

![image-20240710112915378](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240710112915378.png)

思路：

哈希表加双向链表可以实现。

- 哈希表可以实现O(1)根据key获取val。
- 双向链表可以实现O(1)的插入。
  - 定义队首是最近访问，队尾是最久未访问

具体实现：

初始化：

- 首先维护一个哨兵节点，然后$dummy.next=dummy,dummy.pre=dummy$​
  - $dummy.next$始终指向链表头结点
  - $dummy.prev$始终指向链表尾结点
- 初始化哈希表：容量是capacity

插入操作：

- 先判断mp中是否存在这个key，存在则更新值。需要移除这个节点，然后将该节点移动到头部

- 判断mp的容量是否大于capacity，如果是，那么移除队尾节点，在根据key移除哈希表中的节点。
- 然后再进行插入，新建一个节点，然后移动到头部；然后再将(k,v)存入mp

get操作：

- 如果命中，应该将节点移到头部。然后返回val
- 没命中返回-1

公用操作：

- $addToHead(node)$
- $remove(node)$

细节：

- **pu操作中删除节点时， 先操作mp，再操作链表，因为链表变化可能引起dummy.prev指向的变化**

```java
class LRUCache {

    class Node{
        int k,v;
        Node next,prev;
        public Node(){};
        public Node(int _k,int _v){k=_k;v=_v;}
    }
    Map<Integer,Node>mp=new HashMap<>();
    int cap;
    Node dummy;

    public LRUCache(int capacity) {
        dummy=new Node();
        dummy.prev=dummy;
        dummy.next=dummy;
        cap=capacity;
    }
    
    public void remove(Node node){
        node.next.prev=node.prev;
        node.prev.next=node.next;
    }
    public void addToHead(Node  node){
        Node head = dummy.next;

        dummy.next=node;
        head.prev = node;

        node.prev=dummy;
        node.next=head;
    }
    public int get(int key) {
        if(mp.containsKey(key)){
            
            remove(mp.get(key));
            addToHead(mp.get(key));
            return mp.get(key).v;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        System.out.println("put"+key);
        if(mp.containsKey(key)){
            mp.get(key).v=value;
            remove(mp.get(key));
            addToHead(mp.get(key));
           return;
        }
        if(mp.size()==cap){//到这里说明要新加入节点，因此新加入节点就需要移除原有最老的
            //注意，这里必须先一处mp，再移除节点，因为remove操作会导致remove变化
            mp.remove(dummy.prev.k);
            remove(dummy.prev);
            System.out.println(dummy.prev.k);
        }

        Node cur = new Node(key,value);
        addToHead(cur);
        mp.put(key,cur);
    }
}


```

