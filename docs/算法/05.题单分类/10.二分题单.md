---

title: 二分题单
date: 2024-4-19
tags: 
  - null
categories:  
  - 算法
  - 题单分类
---

## 二分查找

## 二分答案（最小值）

### 1283. 使结果不超过阈值的最小除数

[1283. 使结果不超过阈值的最小除数](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240420145129175.png" alt="image-20240420145129175" style="zoom:80%;" />

思路：

首先我们转化int为上取整，有一个简单的公式$ceil(x/n)=int((x-1)/n+1)$

二分答案，我们下界肯定是1，此时结果和就是数组元素和。最大

上界是数组中的最大值，那么结果和就是数组长度。

这样的话就是**左闭右闭区间**

怎么做呢？

- 红色：小于等于threshold
  - 因为我们的答案是第一个小于等于，所以这样规定红色
- 蓝色大于threshold

所以答案满足一种性质>,>,>,>,<=,<=,<=

那么二分的答案序列就是蓝色蓝色...红...红，具有这种单调性

- 我们返回第一个**红色即小于等于**

```java
class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
    //下取整转上取整   x/n上取整=  (x-1)/n+1  下取整
    //除数范围[1,sum(nums)/threshold]。这里也要上取整
    //选择不同除数，那么结果与threshold，一定满足，>=,>=,>=  <,<
    int n=nums.length;
    int right=0;
    for(int i=0;i<n;i++){
        right=Math.max(right,nums[i]);//题目保证有解，那么我们让每个数都是1，次数最大除数就是数组中最大的数。
    }
    int left = 1;//此时除数最大
    //左闭右闭
    while(left<=right){
        int mid = left+(right-left)/2;
        int tot=0;//最后结果和
        for(int x:nums){
            tot+= (x-1)/mid+1;
        }
        //定义蓝色为大于
        //红色为小于等于，那么就是返回第一个红色
        if(tot>threshold){
            left=mid+1;//左边蓝色
        }else{
            right = mid-1;
        }
    }
    //left-1蓝色,left红色，right+1红色
    //返回第一个红色，left/right+1
        return left;

    }
}
```

### 2187. 完成旅途的最少时间

[2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240420160649649.png" alt="image-20240420160649649" style="zoom:80%;" />

思路：

时间越多，所有公交车完成次数越多，具有单调性

所以答案序列就是时间$t$下能跑完的$tot$次数

下界，我们设置为mn-1，因为这样不能

上界，如果我们只让最快的车跑，次数除以最快车的速度，就是最多的时间（也取不到，因为不止一辆车）

- 蓝色：大于等于
- 红色：小于

那么答案序列就是红，红，红...蓝，蓝..，我们要返回第一个蓝色

> 红蓝表示单调性，其实就是循环不变量的体现了

思考：

上界和下界的问题，以及怎么写三种区间？

- 如果我们**精准的找到了上下界，那么可以互相转化**，比如这道题细节$mn-1$，上界$mn*tot$
- 但是如果找不到，转换就会出错。比如这里一开始我误以为下界是1，这是不对的。
  - 不能是1，考虑特殊样例[1,1,1,1,1]   tot=5.
- 所以一般**开区间好写，因为不用精确知道边界**。比如这里的$left$设置成任意一个负数也可以。这里的$right$设置成任意一个比$mn*tot$大的数也可以。

```java
class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        long t = 0;
        int mn=Integer.MAX_VALUE;
        for(var x:time){
            mn=Math.min(mn,x);
        }
        long  left=mn-1;//任何车都不能完成一次旅途
        //不能是1，考虑特殊样例[1,1,1,1,1]   tot=5.
        //此时我们的left就不是开区间了
        long right = (long)totalTrips*mn;
        //上界和下界都是取不到的，也可以使用三种区间，还是只能左开右开？
        while(left+1<right){
            long mid =left+(right-left)/2;
            long tot=0;
            for(var x:time){
                tot+=mid/x;
            }
            if(tot<totalTrips){
                left=mid;//left为红色，注意是开区间
            }else{
                right=mid;//right为蓝色，注意是开区间
            }
        }
        return right;//left+1


    }
}
```

### 1870. 准时到达的列车最小时速(学习，浮点数坑很多)

[1870. 准时到达的列车最小时速](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240420163852777.png" alt="image-20240420163852777" style="zoom:80%;" />

思路：

> 涉及浮点数，不会做，灵神题解https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/solutions/791209/bi-mian-fu-dian-yun-suan-de-xie-fa-by-en-9fc6

**怎么判断当前$v$下满足条件?**

由于列车只在整点发车，那么假设时速是$v$，那么除了最后一列车，其他车都至少需要花费一个小时。所以除开最后一列车，花费时间应该是上取整，$ceil(dist[i]/v)$。

所以$hour>n-1$，这个可以预判断一下。

- 注意：**由于最后一段是小数，所以要(double)dist[i]**

时速越大，肯定总花费时间越小，所以可以二分时速。

下界：时速可以为0，这样不可能达到，

上界：我们取$1e7$，因为题目说了这个是可能的上界。

注意，这里还有一个套路，就会浮点数不好处理，所以统一转换为整数。由于这里的$hour$只有两位，所以都乘以100即可。但是java这样做会出错。

> 那么肯定是写开区间了

java直接算就行，转成整数反而会出问题。

```java
class Solution {
    public int minSpeedOnTime(int[] dist, double Hour) {
        int n=dist.length;
        double hour  =Hour;
        if(Math.ceil(hour)<=(n-1)){//浮点数与整数比较，所以需要
            return -1;
        }
        long left=0L;
        long right =(long) 1e7;
        while(left+1<right){
            long mid = left+(right-left)/2;
            double tot=0;
            for(int i=0;i<n-1;i++){
                tot+=(dist[i]-1)/mid+1;//tot肯定是整数
            }
            tot+=(double)dist[n-1]/mid;//注意最后一段是小数
            if(tot>hour){
                left=mid;
            }else{
                right=mid;
            }
        }
        return (int)right;
    }
}
```

java，Double精度处理有很大问题

2.01实际上存的是2.009999。这样的话java就没办法乘以100转换成整数，因为还是错的

//[1,1,100000]
//hour =2.01

输出
100001
预期结果
10000000

再比如这个样例

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240420171118371.png" alt="image-20240420171118371" style="zoom:80%;" />

java乘以100，会被卡

```java
class Solution {
    public int minSpeedOnTime(int[] dist, double Hour) {
        int n=dist.length;
        Hour*=100;
        double hour  =Hour;
        System.out.println(hour);
        if(hour<=(n-1)*100){
            return -1;
        }
        long left=0L;
        long right =(long) 1e7;
        while(left+1<right){
            long mid = left+(right-left)/2;
            double tot=0;
            for(int i=0;i<n-1;i++){
                tot+=(dist[i]-1)/mid+1;//tot肯定是整数
            }
            //dist[n-1]/mid
            tot*=mid;
            tot+=dist[n-1];
            if(tot*100>hour*mid){
                left=mid;
            }else{
                right=mid;
            }
        }
        return (int)right;
    }
}
```

### 1011在 D 天内送达包裹的能力

[在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240420173718220.png" alt="image-20240420173718220" style="zoom:80%;" />

思路：



假设载货能力是$k$，那么$k$越大，花费时间越少，具有单调性。

所以我们可以**二分载货能力**

上界:我们求$sum(nums)$，那么一天就可以运完。

下界：应该是$max(nums)$。

单调性

- 红色为不满足，need>day
- 蓝色为满足，need<=day
- 答案序列:红红红...蓝蓝...

难点是**如果知道在当前k下，能不能days之内送完**？我们贪心的让每一天送尽可能多的货物，那么就能算出需要的天数。

  使用一次遍历，维护变量cur表示当前已经送的，每次试探一下是否超出即可。同时维护需要的天数

> Question:下界可以随便写0吗，0肯定也是开区间？
>
> Ans：**可以**，只是这样还会影响后面的贪心选项，要加额外判断

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
    
        int left = Arrays.stream(weights).max().getAsInt()-1;
        //int left=0;
        int right = Arrays.stream(weights).sum()+1;
        while(left+1<right){
            int mid =left+(right-left)/2;
            int need=1;
            int cur=0;
            for(int weight:weights){//贪心选择
                if(cur+weight>mid){//试探一下
                    ++need;
                    cur=0;
                }
               // if(mid<weight) need+=days;//如果left是0，就需要这里判断
                cur+=weight;
            }
            //need>day不满足，为红色
            //need<=day满足，为蓝色
            //那么找第一个蓝色
            //序列是红红...蓝
            if(need>days){
                left=mid;
            }else{
                right=mid;
            }
        }
        return right;
    }
}
```

### 875. 爱吃香蕉的珂珂(学习，很多细节)

[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240420182944091.png" alt="image-20240420182944091" style="zoom:80%;" />

思路：

如果$k$越大，那么需要的时间$t$就越小。所以可以二分$k$。

简化$plies[]$为$p$，每个小时只能选择一堆，所以至少也需要$p.length$小时。

**如何判断给定$k$下能在$h$吃完？**直接使用除法就可以算出来

我们每次选择一堆$p[i]$，那么吃完一堆的时间就是数量/速度。即$t+=(p[i]-1)/mid+1$。

- **注意需要上取整**

上界:$max\{p\}$，每次都可以吃完一堆

- 闭区间,所以应该加1

下界：0，这样最方便，因为肯定是不行的，可以在这是把$t$设置为$h+1$表示肯定不行

- 开区间。但是好像不会到0，所以不特判也可以。

单调性：

- 红色：不满足，对应$t>h$
- 蓝色，满足,对应$t<=h$

注意：

- 中间结果$t$会爆int，最好都用long.

```java
class Solution {
    public int minEatingSpeed(int[] p, int h) {
        long left=0;
        long right=0;
        for(int x:p){
            right=Math.max(x,right);
        }
        while(left+1<right){
            long mid =left+(right-left)/2;
            long t=0;//h不会爆int，但是t可能会
            for(int x:p){
                 if(mid==0){
                    t=h+1;
                    break;
                }   
                t+=(x-1)/mid+1;
            }
            if(t>h){
                left=mid;
            }else{
                right=mid;
            }
        }
        return (int)right;
    }
}
```

### 1482. 制作 m 束花所需的最少天数

[1482. 制作 m 束花所需的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240420201540194.png" alt="image-20240420201540194" style="zoom:80%;" />

思路：

如果天数$d$越大，那么开的花就越多。所以可以二分天数$d$

**怎么判定$d$下是否满足条件**？

这道题，当$d$确定时，开花的位置就确定了，我们只需要贪心的选择当前是否满足m组$k$个相邻开花位置即可

上界:  $max\{b\}$因为这个时候已经全部开花了

下界: 0，这样一朵花也没开

单调性：我们假设当前有x组k相邻花

- 红色，$x<m$，不满足
- 蓝色，$x>=m$，满足
- 红红...蓝蓝...

```java
class Solution {
    public int minDays(int[] b, int m, int k) {
        int left=0;
        int right=0;
        for(var x:b){
            right=Math.max(x,right);
        }
        right+=1;//开区间
        int mx=right;
        while(left+1<right){
            int mid =left+(right-left)/2;
            int x=0;
            int cur=0;//表示连续开放的花数量
            for(int i=0;i<b.length;i++){
                if(b[i]<=mid){
                    cur++;
                }
                else{
                    cur=0;
                }
                if(cur==k){
                    x++;
                    cur=0;//计数一次后，cur也要从0开始
                }
            }
            if(x<m) left=mid;
            else right=mid;
        }
        return right==mx?-1:right;
    }
}
```

