---
title: 分组循环
date: 2024-01-25
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

> [灵神题单](https://leetcode.cn/problems/longest-alternating-subarray/solutions/2615916/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-r57bz/)

## 定义

#### 适用场景

如果一个数组，需要分成若干组，并且每一组的判断/处理逻辑是相同的

一般分为外层循环和内层循环，两个循环用于处理不同的事情

1.外层循环用于做准备工作（比如记录开始位置）和内层循环后的统计工作（例如求最大值）

2.内层循环用于遍历组，找出这个组的结束位置

分组循环这种写法逻辑清晰，不容易出错

## 例题

[2765. 最长交替子数组](https://leetcode.cn/problems/longest-alternating-subarray/)

思路：

- 外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。
- 内层循环负责遍历组，找出这一组最远在哪结束。

注意：

1.对于交替两个字，可以转化成nums[i]=nums[i+2]

2.交替数组的起点是1

3.不存在解返回-1，所以ans初始化为-1；

```java
class Solution {
    public int alternatingSubarray(int[] nums) {
        int ans =-1;
        int i=0,n=nums.length;
        while(i<n-1){
            if(nums[i+1]-nums[i]!=1){//交替数组第一组必须是1
                i++;
                continue;
            }
            int j=i;//记录这一组开始位置
            i+=2;//i和i+1已经满足
            while(i<n&&nums[i]==nums[i-2]){//交替可以转换为这个条件
                i++;
            }
            //到这里，i指向的数是第一个不是交替数组的数
            //从j到i-1是满足要求的
            ans=Math.max(ans,i-j);
            i--;//这里很细节，注意，因为i所处的点是第一个不是交替数组的数，所以要更新为交替数组的最后一个数
            //可以看灵神题解
        }
        return ans;
    }
}
```



## 题单

>https://leetcode.cn/problems/longest-alternating-subarray/solutions/2615916/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-r57bz/

[1446. 连续字符](https://leetcode.cn/problems/consecutive-characters/)

这道题中，按照种类给字符串分组，求出最长的组。
**思路：**
外层循环：
记录开始位置，组长度
内层循环
遍历该组，找结束位置跳出
**注意：**
1.如果要比较i和i+1个元素，那么i应该小于n-1;

```java
class Solution {
    public int maxPower(String s) {
       int ans =1;
       int i=0,n=s.length();
       while(i<n){
           int j=i;
           while(j<n-1&&s.charAt(j)==s.charAt(j+1)){
               j++;
           }
        ans = Math.max(ans,j-i+1);
           i=j+1;
       }
        return ans;
    }
}
```

[1869. 哪种连续子字符串更长](https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/)

# 分组循环
**思路：**
外层循环：
分别记录1开始位置，和0开始长度，并且更新其最长长度
内层循环
遍历该组，找结束位置跳出（也就是和上一个不相等）
```java
class Solution {
    public boolean checkZeroOnes(String s) {
        int n=s.length();
        if(n==1){
            return s.charAt(0)=='1';
        }
        int one_len =getLen(s,'1',n);
        int zero_len = getLen(s,'0',n);
        return one_len>zero_len;
    }
    public int getLen(String s,char ch,int n){
        int i=0;
        int len=0;
        while(i<n){
            int j=i;
            //这里比较的是连续，所以样例长度为1会有bug
            while(j<n-1&&s.charAt(j)==ch&&s.charAt(j+1)==ch){
                j++;
            }
            //假设ch=0，j停留在连续0的最后一位。
            len = Math.max(len,j-i+1);
            i=j+1;
        }
        return len;
    }
}