---
title: 单调栈
date: 2024-02-16
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 单调栈

> [单调栈](https://blog.csdn.net/m0_73096566/article/details/129232233)
>
> [灵神单调栈讲解](https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.999.0.0&vd_source=d005def162a369d30cf8c241225a9395)

单调栈，也就是栈内元素具有单调性（**一般是栈底到栈顶**）。如果是栈底元素到栈顶元素单调递增，则是递增栈；如果是栈底元素到栈顶元素单调递减，就是递减栈。

> tips:相等元素不是单调哦，一般相等元素时要出栈\入栈

这样不太直观，我们直接看图

![image-20231115222229869](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231115222229869.png)

**直接根据题目来学习是最快的，**

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240216223942024.png" alt="image-20240216223942024" style="zoom:80%;" />

**暴力做法**

假设从左往右遍历数组，对于每一个数，我们从这个点往右找第一个比他大的数，那么最坏情况下，所有元素相等，那么需要$O(n^2)$的时间。

**更好的做法**

假设我们从右往左遍历这个数组，同时维护一个栈，保证栈内元素递减（递减栈）。所以一旦当前元素比栈顶大，栈顶元素就要出栈，直到栈顶元素比当前元素大。

**这样当元素出栈的时的右边的第一个遇到的最大元素就是栈顶元素**。模拟如下:

![绘图](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/%E7%BB%98%E5%9B%BE.png)

**单调栈核心如下：**

- 先进后出
  - 记录的数据加在最上面(栈顶)
  - 丢掉数据也从最上面开始(栈顶)
- 单减栈单调性
  - 记录$t[i]$之前会把所有$<=t[i]$的数据丢掉
  - 所以不可能出现下面小上面大的情况

**总结**

- **及时去掉无用数据，保证栈中数据有序**















注意：**单调栈常常用来找该元素左边/右边的第一个大/小的元素的位置，那么应该压入下标而不是元素本身，这样才能求解。当然也有例外**

单调栈常见问题有四种情况：

**向左找第一个比当前元素大的数。**

从左到右遍历元素，构造单调递减栈：

- 因为是递减栈，**所以遇到当前元素< 栈顶元素时弹栈，直到栈顶元素>当前元素**，一个元素左侧第一个比它大的元素就是将其插入栈时的栈顶元素。
- 如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。

**向左找第一个比当前元素小的数。**

从左到右遍历元素，构造单调递增栈：

- 因为是递增栈，**所以遇到当前元素>栈顶元素时弹栈，直到栈顶元素<当前元素**，所以一个元素左侧第一个比它小的元素就是将其插入栈时的栈顶元素。
- 如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。

**向右找第一个比当前元素大的数。**

从右到左遍历元素，构造单调递减栈：

- 因为是递减栈，**所以遇到当前元素< 栈顶元素时弹栈，直到栈顶元素>当前元素**，一个元素左侧第一个比它大的元素就是将其插入栈时的栈顶元素。
- 如果该元素没有被弹出栈，则说明右侧不存在比当前元素大的元素。

**向右找第一个比自身当前元素小的数。**

从右到左遍历元素，构造单调递增栈：

- 因为是递增栈，**所以遇到当前元素> 栈顶元素时弹栈，直到栈顶元素<当前元素**，所以一个元素左侧第一个比它小的元素就是将其插入栈时的栈顶元素。

- 如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。


总结一下：

- **从右开始找数是从右往左，从左开始找数是从左往右**
- 查找 **「比当前元素大的元素」** 就用 **单调递减栈**，查找 **「比当前元素小的元素」** 就用 **单调递增栈**。

细节：

数组中有相等的元素，如何处理？

要根据情况而定，读题提炼出，需要的是严格递增的栈还是可以容易相等元素的栈。

## 例题



**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

向右找第一个大于当前元素，递减栈

细节：本体要求是找到第一个大于，所以是`>`时弹栈，才能保证弹出来的都符合要求

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //递减栈
            int n=temperatures.length;
            int []ans = new int[n];
            Deque<Integer>stack = new ArrayDeque<>();
            for(int i=0;i<n;i++){
                while(!stack.isEmpty()&&temperatures[i]>temperatures[stack.peekLast()]){
                    int t = stack.pollLast();
                    ans[t]=i-t;
                }
                stack.addLast(i);
            }
            return ans;
    }
}
```

**单调栈的经典例题**

[1944. 队列中可以看到的人数