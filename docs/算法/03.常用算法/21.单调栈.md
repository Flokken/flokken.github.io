---
title: 单调栈
date: 2024-02-16
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 单调栈

> [单调栈](https://blog.csdn.net/m0_73096566/article/details/129232233)
>
> [灵神单调栈讲解](https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.999.0.0&vd_source=d005def162a369d30cf8c241225a9395)

单调栈，也就是栈内元素具有单调性（**一般是栈底到栈顶**）。如果是栈底元素到栈顶元素单调递增，则是递增栈；如果是栈底元素到栈顶元素单调递减，就是递减栈。

> tips:相等元素不是单调哦，一般相等元素时要出栈\入栈

这样不太直观，我们直接看图

![image-20231115222229869](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231115222229869.png)

## 例题学习

**直接根据题目来学习是最快的，**

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240216223942024.png" alt="image-20240216223942024" style="zoom:80%;" />

### **暴力做法**

假设从左往右遍历数组，对于每一个数，我们从这个点往右找第一个比他大的数，那么最坏情况下，所有元素相等，那么需要$O(n^2)$的时间。

### **更好的做法**

假设我们从右往左遍历这个数组，同时维护一个栈，保证栈内元素递减（递减栈）。所以一旦当前元素比栈顶大，栈顶元素就要出栈，直到栈顶元素比当前元素大。

**这样当元素出栈的时的右边的第一个遇到的最大元素就是栈顶元素，栈中记录元素是还没有找到答案的数**。模拟如下:

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/%E7%BB%98%E5%9B%BE.png" alt="绘图" style="zoom:80%;" />

最核心的是**及时去除无用元素，保持栈中数据有序**

> 我的理解: 这里是找更大元素，我们维护一个单减栈，一旦有更大的元素出现，那么之前的小的元素都被挡住了(比如上面5后面的2,3)，**所以这些都成了无用元素**，就要及时丢掉。

### 补充

对于上面的问题，我们可以做一些拓展补充，这样对单调栈理解的更深刻。

回顾一下问题：

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

#### **1.如果是从左到右遍历呢?依然是单减栈吗?**

上面同样的，我们维护一个递减栈，然后从左到右遍历数组。

同样的，依然是元素出栈时，更新答案，区别在于现在右边第一个更大元素就是当前要入栈的元素。模拟如下：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/%E7%BB%98%E5%9B%BE1.png" alt="绘图1" style="zoom:80%;" />

#### **2.维护单增栈可以吗?**

假设我们是从左到右遍历数组，并且维护一个单增栈。

那么我们会发现，每次出栈时，**我们可以确定的是这个数右边的第一小的元素**。模拟如下:

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240217152358672.png" alt="image-20240217152358672" style="zoom:80%;" />

同理，如果我们是从右到左遍历数组，维护一个单增栈。

这样同样也是找这个数右边第一个小于自身的数。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240217151035970.png" alt="image-20240217151035970" style="zoom:80%;" />

**所以，单增栈应该用来找更小的元素。**

#### 3.如果是找左边第一个比当前元素大的元素呢?

我们依然可以利用单减栈，因为单减栈中，才是高的把矮的遮住了。

同样的，依然是元素出栈时，更新答案，区别在于现在右边第一个更大元素就是当前要入栈的元素。模拟如下：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240217164359004.png" alt="image-20240217164359004" style="zoom:80%;" />

**我们可以发现，相较于找右边第一个更大元素，仅仅只是更新答案时的方法变了**

### **总结**

**单调栈核心如下：**

- 先进后出
  - 记录的数据加在最上面(栈顶)
  - 丢掉数据也从最上面开始(栈顶)
- 单减栈单调性
  - 记录$t[i]$之前会把所有$<=t[i]$的数据丢掉
  - 所以不可能出现下面小上面大的情况
  - 单调性是我们需要利用的，所以有这种性质的问题就可以用单调栈试试，不要死记硬背
- 考虑使用单调栈的情况
  - 上一个更大元素
  - 下一个更大元素

- **单调栈16字总结:及时去掉无用数据，保证栈中数据有序**
-  我总结的(还不一定对):  找更小元素使用单增栈，更大元素使用单减栈

## 其他例题

### 接雨水

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

> [单调栈解接雨水](https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.999.0.0&vd_source=d005def162a369d30cf8c241225a9395)

**核心:找上一个更大元素，找到过程种填坑。**

首先的转化问题，发现5，4之间的面积为$1*1+1*2+3*2$这种方式来计算。

其实这里的思考过程也是有子问题的影子，对于两根柱子,其下标分别是L,R，高度是h1，h2. 

其接水的量应该是  (R-L-1)*min(h1,h2)。

但是两个柱子中可能存在其他柱子，占了空间，这一点要考虑到。**所以这里利用单减栈来记录上一个更大的元素**

假设单调栈中上一根柱子高度是h3(如果有的话)，对于每根柱子其出栈时，需要计算的面积实际上为

$ (R-L-1)*(min(h1,h2)-h3)$

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240217165344313.png" alt="image-20240217165344313" style="zoom:50%;" />

模拟如下:

序列是 5 2 1 0 4，从左到右遍历，单减栈。

那么一开始一直入栈到  5 2 1 0，直到遇到4，开始出栈，并且更新总面积ans

- 对于0， 结果肯定是0，ans+=0; 0出栈
- 对于1 ，$(4-2-1)*(min(4,1) -0)=1*1$，ans+=1，1出栈
- 对于2，$(4-1-1)*(min(4,2)-1)= 2*1$，ans+=2,2出栈
- 对于5，$(4-0-1)*(min(4,5)-1)=3*2$,ans+=6,5出栈
- 然后4入栈...........

细节：遇到与栈顶相等的元素，我们也会将栈顶出栈处理

**最终代码实现**

**牢牢记住:及时去掉无用数据，保证栈中数据有序**

```java
class Solution {
    public int trap(int[] height) {
        Deque<Integer>st = new ArrayDeque<>();
        int ans=0;
        for(int i=0;i<height.length;i++){
            while(!st.isEmpty()&&height[i]>=height[st.peek()]){//相等元素也需要处理，否则破坏了单调性
                int j=st.pop();//上一根柱子
                if(st.isEmpty()){break;}//如果是相邻的柱子，接不了雨水
                int k= st.peek();//当前柱子
                ans+=(i-k-1)*(Math.min(height[i],height[k])-height[j]);
            }
            st.push(i);//存下标方便计算
        }
        return ans;
    }
}
```
