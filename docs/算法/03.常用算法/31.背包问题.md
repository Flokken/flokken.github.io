---
title: 01背包和完全背包
date: 2024-02-24
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 01背包

$Question:$有$n$个物品，第$i$个物品的体积为$w[i]$，价值为$v[i]$，每个物品最多选一个，求体积和不超过$capacity$?

### 回溯三问

- 当前操作?枚举**第**$i$个物品时选或者不选
  - 不选，剩余容量不变
  - 选，容量减少，价值增加
- 子问题?在容量为$c$的背包中，从**前**$i$个物品中获得最大价值和
- 下一个子问题?分类讨论
  - 不选：在容量为$c$的背包中，从**前**$i-1$个物品中获取最大价值和
  - 选:在容量为$c-w[i]$的背包中，从**前**$i-1$个物品中获取最大价值和
    - 这里选的前提是$c>=w[i]$

我们定义$dfs(i,c)$表示选择第$i$个物品时，剩余容量为$c$时的最大价值和

**状态转移**

$dfs(i,c)=max(dfs(i-1,c),dfs(i-1,c-w[i])+v[i])$

**边界条件**

- $i==0$，那么返回最大价值是0

通过一道例题来学习

**代码**

```java
class Solution{
    int vis[i][c];
    int []w;
    int []v;
    public void zero_one_knapsack(int c,int []w,int []v){
        this.w=w;
        this.v=v;
        int n=w.length;
        dfs(n-1,c);
    }
    public void dfs(int i,int c){
        if(i<0){
            return 0;
        }
        if(vis[i][c]){
            return vis[i][c];
        }
        if(c<w[i]){
            return dfs(i-1,c);
        }
        return Math.max(dfs(i-1,c),dfs(i-1,c-w[i]));
    }
}
```

### 01背包-常见变形

**常见变形**

- 至多装$capacity$，求方案数/最大价值和
- 恰好装$capacity$，求方案数/最大/最小价值和
- 至少装$capacity$，求方案数/最小价值和

### 例题

#### 494.目标和

[494. 目标和](https://leetcode.cn/problems/target-sum/)

<img src="C:/Users/86180/AppData/Roaming/Typora/typora-user-images/image-20240224193327220.png" alt="image-20240224193327220" style="zoom:67%;" />

这里需要恰好得到$target$，求方案数，**算是第二种变形**

**思路:**

我们假设$nums$所有数的和是$s$（注意都是），假设要让最终的和为$target$，其中负数的和是$p$，正数的和是$q$

也就是$p+q=target$。我们把负数取反，那么正数加上负数取反的值应该就是$s$，所以

$q-p=s$，联立这两个式子，得到

$q=(target+s)/2$。观察这个式子：

- $target+s$的和肯定是个偶数(因为除以2得到的和是一个整数)
- $target+s$的和肯定$>=0$

**所以我们可以把问题转化为，从前$i$个数中选取一些数，和恰好为$q$**

##### 回溯三问

- 当前操作?枚举**第**$i$个数是选还是不选？
- 子问题?从**前**$i$个数中选取数字，和恰好为$target$
- 下一个子问题，分类讨论
  - 不选：在容量为$target$的背包中，从**前**$i-1$个物品中获取方案数
  - 选:在容量为$target$的背包中，从**前**$i-1$个物品中获取方案数
    - 这里选的前提是$c>=nums[i]$

所以这道题其实和上一道题非常像，仔细看区别

**状态定义**

我们定义$dfs(i,c)$表示选择第$i$个物品时，剩余容量为$c$时**方案数**

**状态转移**

$dfs(i,c)=dfs(i-1,c)+dfs(i-1,c-nums[i])$











