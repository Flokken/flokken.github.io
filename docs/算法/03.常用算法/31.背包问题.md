---
title: 01背包和完全背包
date: 2024-02-24
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 01背包

$Question:$有$n$个物品，第$i$个物品的体积为$w[i]$，价值为$v[i]$，每个物品最多选一个，求体积和不超过$capacity$?

### 回溯三问

- 当前操作?枚举**第**$i$个物品时选或者不选
  - 不选，剩余容量不变
  - 选，容量减少，价值增加
- 子问题?在容量为$c$的背包中，从**前**$i$个物品中获得最大价值和
- 下一个子问题?分类讨论
  - 不选：在容量为$c$的背包中，从**前**$i-1$个物品中获取最大价值和
  - 选:在容量为$c-w[i]$的背包中，从**前**$i-1$个物品中获取最大价值和
    - 这里选的前提是$c>=w[i]$

我们定义$dfs(i,c)$表示选择第$i$个物品时，剩余容量为$c$时的最大价值和

**状态转移**

$dfs(i,c)=max(dfs(i-1,c),dfs(i-1,c-w[i])+v[i])$

**边界条件**

- $i==0$，那么返回最大价值是0

通过一道例题来学习

**代码**

```java
class Solution{
    int vis[i][c];
    int []w;
    int []v;
    public void zero_one_knapsack(int c,int []w,int []v){
        this.w=w;
        this.v=v;
        int n=w.length;
        dfs(n-1,c);
    }
    public void dfs(int i,int c){
        if(i<0){
            return 0;
        }
        if(vis[i][c]){
            return vis[i][c];
        }
        if(c<w[i]){
            return dfs(i-1,c);
        }
        return Math.max(dfs(i-1,c),dfs(i-1,c-w[i]));
    }
}
```

### 01背包-常见变形

**常见变形**

- 至多装$capacity$，求方案数/最大价值和
- 恰好装$capacity$，求方案数/最大/最小价值和
- 至少装$capacity$，求方案数/最小价值和

### 例题

#### 494.目标和

[494. 目标和](https://leetcode.cn/problems/target-sum/)

<img src="C:/Users/86180/AppData/Roaming/Typora/typora-user-images/image-20240224193327220.png" alt="image-20240224193327220" style="zoom:67%;" />

这里需要恰好得到$target$，求方案数，**算是第二种变形**

**思路:**

我们假设$nums$所有数的和是$s$（注意都是），假设要让最终的和为$target$，其中负数的和是$p$，正数的和是$q$

也就是$p+q=target$。我们把负数取反，那么正数加上负数取反的值应该就是$s$，所以

$q-p=s$，联立这两个式子，得到

$q=(target+s)/2$。观察这个式子：

- $target+s$的和肯定是个偶数(因为除以2得到的和是一个整数)
- $target+s$的和肯定$>=0$

**所以我们可以把问题转化为，从前$i$个数中选取一些数，和恰好为$q$**

##### 回溯三问

- 当前操作?枚举**第**$i$个数是选还是不选？
- 子问题?从**前**$i$个数中选取数字，和恰好为$target$
- 下一个子问题，分类讨论
  - 不选：在容量为$target$的背包中，从**前**$i-1$个物品中获取方案数
  - 选:在容量为$target$的背包中，从**前**$i-1$个物品中获取方案数
    - 这里选的前提是$c>=nums[i]$

所以这道题其实和最原始的背包问题差不多，仔细看区别

**状态定义**

我们定义$dfs(i,c)$表示选择第$i$个物品时，剩余容量为$c$时**方案数**

**状态转移**

$dfs(i,c)=dfs(i-1,c)+dfs(i-1,c-nums[i])$

**递归边界**

当i<0时，说明没有物品了

- 如果此时c==0，说明刚好有一种方案，返回1
- 否则返回0

**代码**

```java
class Solution {
    int [][]vis;
    int []nums;
    public int findTargetSumWays(int[] nums, int target) {
        int n=nums.length;
        this.nums = nums;
        int sum =0;
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
        }
        target=target+sum;
        if(target<0||target%2==1){
            return 0;
        }
        target=target/2;
        vis = new int[n][target+1];
        return dfs(n-1,target);

    }
    public int dfs(int i,int c){
        if(i<0){
            return c==0?1:0;
        }
        if(vis[i][c]!=0){
            return vis[i][c];
        }
        int ans=0;
        if(c<nums[i]){//不选
            ans= dfs(i-1,c);
            vis[i][c]=ans;
            return ans;
        }
         ans = dfs(i-1,c)+dfs(i-1,c-nums[i]);
        vis[i][c]=ans;
        return ans;
    }
}
```

##### 1:1改成递推

这是我们找到的回溯时状态转移的式子

$dfs(i,c)=dfs(i-1,c)+dfs(i-1,c-nums[i])$

我们首先需要把dfs换成f，并且，**为了避免出现负数下标**，我们可以用$i+1$去替换状态中的$i$，得到

$f[i+1][c]=f[i][c]+f[i][c-nums[i]]$

- 如果$c<nums[i]$，则$f[i+1][c]=f[i][c]$

**状态定义：**$f[i][c]$表示**前**$i$件物品在target为c时，具有的方案数

> 之前分析过，nums[i]的i不是状态里的，也就不是递推关系里的，所以不能替换，所以仍然是$nums[i]$

**方向**

- f(i+1)由f(i)而来，所以i是从前往后
- f(i+1,c)由f(i,c-nums[i])而来，所以c也是从前往后

**初始化**

- $f[0][0]=1,0<=i<n$，表示没有物品并且c==0时，算一种方案

**边界**

- $0<=i<n$，表示从没有物品到n-1
- $0<=c<=target$，表示从0到目标值

**返回值**

$f[n][target]$

**代码**

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum =0;
        int n=nums.length;
        for(int i=0;i<n;i++){
            sum+=nums[i];
        }
        target=target+sum;
        if(target<0||target%2==1){
            return 0;
        }
        target=target/2;
        int [][]f = new int [n+5][target+5];
        f[0][0]=1;
        for(int i=0;i<n;i++){
            for(int c=0;c<=target;c++){
                if(c<nums[i]){
                    f[i+1][c]=f[i][c];
                }else{
                    f[i+1][c]=f[i][c]+f[i][c-nums[i]];
                }
            }
        }
        return f[n][target];
    }
  
}
```













