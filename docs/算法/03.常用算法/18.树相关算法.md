---
title: 树相关算法
date: 2024-01-27
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---



## 节点的祖先

节点祖先的定义。

在树结构中，树的祖先是指某个节点的所有直接或间接的前辈节点。换句话说，一个节点的祖先是指从根节点到该节点所经过的路径上的所有节点。(所以节点自身也是自己的祖先)

> 但leetcode里好像并不是？

举例：

具体来说，给定一棵树和其中的一个节点，我们可以通过沿着该节点的父节点向上追溯，直到到达根节点，从而找到该节点的祖先。

例如，在下图所示的树中，节点 D 的祖先为 B 和 A，节点 F 的祖先为 C、B 和 A。

```
	  A
     / \
    B   C
   / \
  D   E
       \
        F
```



### 树的第k个祖先

> 参考灵神题解https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solutions/2305895/mo-ban-jiang-jie-shu-shang-bei-zeng-suan-v3rw

[1483. 树节点的第 K 个祖先](https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/)

这里要求能够直接得到节点的第k个祖先，所以需要预处理出节点的所有祖先。

![image-20240127220909237](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240127220909237.png)

```java
class TreeAncestor {
   private int[][] pa;//每个节点x的第2^i个祖先节点
    //任何k都可以转换为2进制数，然后转换为几个2^x次幂的和
    public TreeAncestor(int n, int[] parent) {  
        int m= 32-Integer.numberOfLeadingZeros(n);//n的二进制长度
        pa= new int [n][m];
        for(int i=0;i<n;i++){
            pa[i][0]=parent[i];
        }
        for(int i=0;i<m-1;i++){
            for(int j = 0;j<n;j++){
                int p=pa[j][i];
                pa[j][i+1] = p<0?-1:pa[p][i];//不存在的祖先节点赋为-1；
                //爸爸的第二个祖先节点就等于爷爷节点
            }
        }
    }
    
    public int getKthAncestor(int node, int k) {
        int m=32-Integer.numberOfLeadingZeros(k);//k的二进制长度
        for(int i=0;i<m;i++){
            if(((k>>i) & 1) > 0){//k的二进制从低到高第i位是1
            //只有当第i位为1时，&1肯定大于等于1，否则就是0
                node = pa[node][i];
                if(node<0) break;
            }
        }
        return node;

    }
}
```



### 最近公共祖先

[2846. 边权重均等查询](https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/)