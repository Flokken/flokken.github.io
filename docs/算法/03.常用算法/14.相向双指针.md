---
title: 相向双指针
date: 2024-03-18
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 理论学习

前提：

- 有序数组

场景

- 求几个数的和

### 167. 两数之和 II - 输入有序数组

[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318200134120.png" alt="image-20240318200134120" style="zoom:80%;" />

#### 暴力做法

我们枚举其中一个数，然后就还需要枚举剩下的n-1个数，也就是双重循环。这样是$O(n2)$

#### 更好的做法

暴力做法，**没有利用到已经排好序的信息**

怎么利用?

我们选数组首尾的两个数，即2和8，同时也是当前最小的数和最大的数

> 一般首尾都有一些性质

我们发现$2+8>9$，那么如果我们选择了8，另外一个数选谁和也比9大，所以**应该去掉8（不选8）**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318201627416.png" alt="image-20240318201627416" style="zoom:80%;" />

接着看，我们发现$2+6<9$，此时如果我们一定选择2，那么另外一个剩余的数选谁也和比9小，所以**去掉2（不选2）**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318201957501.png" alt="image-20240318201957501" style="zoom:80%;" />

对于一个有序数组，我们求唯一的两个数，和为t。

我们分别用两个指针指向首尾

- 如果两个指针指向数加起来$>t$，那么去掉右指针指向数
- 如果两个指针指向数加起来$<t$，那么去掉左指针指向数
- 直到刚好为t

##### 复杂度分析

两个指针遍历有序数组，最多花费O(n)的时间

##### 为什么？

我们用信息量衡量我们的操作的效率

- 暴力做法，我们把两个数加起来跟9比大小，我们用O(1)的时间只得到了O(1)的信息
- 但是相向双指针，我们**把当前最小和最大的数加起来**比，比完之后，我们知道这两个数中间的数相加都是小于9或者大于9；所以是O(1)的时间获得了O(n)的信息。

当然可以这么做的前提是这是排序好的数组，**我们利用了排好序的性质**

代码

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int n=numbers.length;
        int left=0,right=n-1;
        while(left<right){
            if(numbers[left]+numbers[right]==target){
                return new int[]{left+1,right+1};
            }
            if(numbers[left]+numbers[right]>target){
                right--;
            }else{
                left++;
            } 
        }
        return new int[2];
    }
}
```

### 15三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318205014600.png" alt="image-20240318205014600" style="zoom:80%;" />

转换问题

- 题目说顺序不重要，并且$i!=j,j!=k$

  - 那么设定一个顺序即$i<j<k$

- 如果三个数加起来为0

  - j+=1,k-=1两个指针同时位移

- 还有就是三元组可能重复，比如下面这种情况，有两个[-1,1,0]

  - 我们发现，可以先给**数组排个序**，然后**当前元素如果和上一个元素相等**，直接跳过
    - 这样可以只把相同的集合只算第一个，后面的都会跳过
    - 不止是枚举i时可能遇到重复，枚举j和k时也可能遇到重复，都要跳过
      - 这里很需要想一想

- 之所三个元素都需要判断重复跳过，是因为其中任意一个变化都是一个新的三元组，比如[-1,-1,0]和[-1,0,0]

  所以同样的，其中任意一个重复，我们都需要跳过，否则会加入重复元素

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318204846465.png" alt="image-20240318204846465" style="zoom:80%;" />

> $Question:重复问题没理解，举例下？$
>
> Answer：假设有一组样例[0,0,0,0,0,0]，我们i，j，k枚举，为了区分，我们这里用下标表示答案
>
> 一开始  i=0, j =1  ,k=5
>
> - i=0
>   - j=1,k=5,符合
>     - 正常来说，下一个是j=2,k=4，但是由于都是[0,0,0]，所以重复了！，所以应该判重
>     - 我们上面讨论过，对于一个有序的数组中三元组，如果当前元素如果和上一个元素相同，就应该跳过！
>     - 所以下一步应该是i判断跳过，  k也判断跳过
>   - 所以出来时j=k=3,直接跳出
> - i=1，i也需要判断重复跳过，直到i=5，结束循环
> - 这样才只有一个[0,0,0]

之所三个元素都需要判断重复跳过，是因为其中任意一个变化都是一个新的三元组，比如[-1,-1,0]和[-1,0,0]

所以同样的，其中任意一个重复，我们都需要跳过，否则会加入重复元素

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        List<List<Integer>>ans = new ArrayList<>();
        for(int i=0;i<n-2;i++){//至少留两个数
            int prev=nums[i];
            if(i>0&&nums[i-1]==prev){continue;}//相等数跳过
            int j=i+1;
            int k=n-1;
            while(j<k){
                if(nums[i]+nums[j]+nums[k]==0){
                    ans.add(new ArrayList<Integer>(List.of(nums[i],nums[j],nums[k])));
                    j+=1;
                    while(j<k&&nums[j]==nums[j-1]){
                        j++;
                    }
                    k-=1;
                    while(k>j&&nums[k]==nums[k+1]){
                        k--;
                    }
                }else if(nums[i]+nums[j]+nums[k]<0){
                    j++;
                }else{
                    k--;
                }
            }
        }
        return ans;
    }
}
```

#### 两个优化

其实就是更加充分的利用**排序的性质**

1 如果把当前最小的三个数，即$i,i+1,i+2$指向数都>0，那么不要继续枚举，因为不会再有等于0的情况

2 如果把当前最小的数和数组中最大的两个数加起来，即$i,n-1,n-2$指向数<0，那么这个$i$可以跳过



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318214716231.png" alt="image-20240318214716231" style="zoom:80%;" />

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318214828317.png" alt="image-20240318214828317" style="zoom:80%;" />

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n=nums.length;
        Arrays.sort(nums);
        List<List<Integer>>ans = new ArrayList<>();
        for(int i=0;i<n-2;i++){//至少留两个数
            int cur=nums[i];
            if(i>0&&nums[i-1]==cur){continue;}//相等数跳过
            //两个优化
            if(cur+nums[i+1]+nums[i+2]>0) break;
            if(cur+nums[n-1]+nums[n-2]<0) continue;
            int j=i+1;
            int k=n-1;
            while(j<k){
                if(nums[i]+nums[j]+nums[k]==0){
                    ans.add(new ArrayList<Integer>(List.of(nums[i],nums[j],nums[k])));
                    j+=1;
                    while(j<k&&nums[j]==nums[j-1]){
                        j++;
                    }
                    k-=1;
                    while(k>j&&nums[k]==nums[k+1]){
                        k--;
                    }
                }else if(nums[i]+nums[j]+nums[k]<0){
                    j++;
                }else{
                    k--;
                }
            }
        }
        return ans;
    }
}
```





## 例题

### 2824. 统计和小于目标的下标对数目

[2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318220430646.png" alt="image-20240318220430646" style="zoom:80%;" />

思路：

- 求的是和小于$target$
- 枚举当前的最大最小值i和j
  - 如果最小值和最大值都小于target,  更新$ans=j-i$（举特殊值，i=0，j=1，有一对，所以是$j-i$）
    - 然后  $i++$，尝试下一个最小值
  - 其他情况，由于当前左边已经是最小值，所以应该舍弃右边的值，才能缩小答案离$target$更近

```java
class Solution {
    public int countPairs(List<Integer> nums, int target) {
        int n = nums.size();
        int i=0,j=n-1;
        Collections.sort(nums);
        int ans=0;
        while(i<j){
          if(nums.get(i)+nums.get(j)<target){
                ans=ans+j-i;
                i++;
            }else{
                j--;
            }
        }
        return ans;
    }
}
```

### 16最接近的三数之和]

[最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240318221213155.png" alt="image-20240318221213155" style="zoom: 80%;" />

思路：

任选三个数，所以我们想到应该是遍历所有组合情况来找是否存在，暴力显然是O(n3)，

但是我们有做三数之和的经验，可以先排序，然后枚举一重，剩下的两重循环用相向双指针，这样优化到O(n2)

- 规定 $i<j<k$
- 维护一个$ans$,如果当前和与target更接近就更新



```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int n=nums.length;
        int ans=Integer.MAX_VALUE;
        Arrays.sort(nums);
        for(int i=0;i<n-2;i++){
            int j=i+1;
            int k=n-1;
            int sum=nums[i]+nums[n-1]+nums[n-2];
            if(target>sum && Math.abs(target-sum)>Math.abs(target-ans)){
                continue;
            }
            sum=nums[i]+nums[i+1]+nums[i+2];
            if(target<sum && Math.abs(target-sum)>Math.abs(target-ans)){
                continue;
            }
            while(j<k){
                int s=nums[i]+nums[j]+nums[k];
                ans=Math.abs(target-ans)<Math.abs(target-s)?ans:s;
                if(s>target){
                    k--;
                }else if(s==target){
                    ans=target;
                    break;
                }
                else{
                    j++;
                }
            }
        }
        return ans;
    }
}
```



## 总结

### 技巧

- 不要死记硬背，重要的是理解，答案要求的是什么，怎么利用排好序这个性质？
- 由于是有序数组，我们每次都枚举当前的最大值和最小值，那么**这两个值对我们求答案有什么启发**？
- **顺序不重要，就设定一个顺序**，比如三数之和



