---
title: 递归算法(通过二叉树学习)
date: 2023-11-01
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

> [灵神递归讲解](https://www.bilibili.com/video/BV1UD4y1Y769/?spm_id_from=333.999.0.0&vd_source=d005def162a369d30cf8c241225a9395)
>
> [递归执行演示网站](https://pythontutor.com/)
>
> [数学归纳法](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95)

## 理论学习

我们通过二叉树来学习递归，因为二叉树就是递归定义的。

$Question:$求二叉树的最大深度?

[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240211151203186.png" alt="image-20240211151203186" style="zoom:67%;" />

**经验：二叉树不要一上来就去关注二叉树细节，而是思考整棵树和左右子树的关系**

### **思考过程**



**我们把左右子树看成三角形，整棵树的最大深度 = max(左子树最大深度，右子树最大深度)+1(递推式)**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240211123820418.png" alt="image-20240211123820418" style="zoom: 67%;" />

而对于左右子树，其最大深度可以用一样的方法求得

**原问题**: 计算整棵树最大深度

**子问题**: 计算左右子树的最大深度

**原问题和子问题可以用相似的方法求出**

类比循环，既然过程相似，那么代码也应该基本相同，**但是子问题需要把计算结果返回给上一级问题，所以更适合用递归实现**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240211130323758.png" alt="image-20240211130323758" style="zoom:67%;" />





由于子问题规模比原问题小，不断**递**下去，总会到达尽头，即递归的**边界条件**(base case)，直接返回他的答案(**归)**

> 递在程序执行时，就是不断调用这个函数的过程，归就是达到边界返回结果到上一层栈帧的过程

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240211131507624.png" style="zoom:67%;" />

**边界条件**

对于这道题，边界显然就是左子树或者右子树为空，那么此时返回0(该子树深度)

### 递归的正确性

主要思想是数学归纳法。[数学归纳法](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95)

### 递归如何执行

总的来说就是系统执行递归时，只要递归没有返回，那么这一次执行的栈帧是会保留的，知道最终的调用结束，把结果一级级的返回。

> 我们需要这种先进后出的数据结构，显然就是栈

[递归执行演示网站](https://pythontutor.com/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240211151551052.png" alt="image-20240211151551052" style="zoom: 80%;" />

`code`

```java
public class MainClass {
  public static class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){this.val = val;}
    TreeNode(int val,TreeNode left, TreeNode right){
      this.val = val;
      this.left = left;
      this.right = right;
    }
  }
  public static void main(String[] args) {
    TreeNode root = new TreeNode(1,new TreeNode(2,new TreeNode(4),new TreeNode(5)),new TreeNode(3,new TreeNode(5),new TreeNode()));
    maxDepth(root);
    
  }
  public static int maxDepth(TreeNode root){
      if(root == null){
        return 0;
      }
      return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
  }
}
```

> 这里和leetcode的代码稍微有点区别，因为用的是内部类`TreeNode`，以及方法`maxDepth`，都声明为静态方法(否则是成员方法)，否则需要先创建对应实例，才能使用成员方法。
>
> 不写成内部类可以更方便
>
> ```java
> public class Solution {
>     public static void main(String args[]){
>         TreeNode root = new TreeNode(1,new TreeNode(2,new TreeNode(4),new TreeNode(5)),new TreeNode(3,new TreeNode(6),new TreeNode()));
>     }
>     public static int maxDepth(TreeNode root){
>         if(root == null){
>             return 0;
>         }
>         return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
>     }
> }
> 
> class TreeNode {//别加public，一个类文件只能有一个public 类，并且类名必须和文件名一样，但可以有多个类
>   int val;
>   TreeNode left;
>   TreeNode right;
>   TreeNode() {}
>   TreeNode(int val) {
>     this.val = val;
>   }
>   TreeNode(int val, TreeNode left, TreeNode right) {
>       this.val = val;
>       this.left = left;
>       this.right = right;
>     }
> }
> 
> ```

### 另一种递归思路

上面的递归思路是不断返回上一层计算结果，最后返回最大深度

还有一种思路就是我们可以把当前的节点深度传入下一层，维护一个全局变量`ans`，然后在`node==null`的时候，更新这个ans。

```java
class Solution {
    int ans=0;
    public void dfs(TreeNode root,int cur) {
        if(root == null){
            ans = Math.max(ans,cur);
            return;
        }
        dfs(root.left,cur+1);
        dfs(root.right,cur+1);
    }
    public int maxDepth(TreeNode root) {
        dfs(root,0);
        return ans;
    } 
}
```

### 总结

- 递归不要去想具体子问题如何执行，我们需要想的是**递推式**以及**边界条件**。
  - 要找递推式，首先要能把原问题缩小为规模更小的子问题
  - 根据子问题，再去找边界条件
- 递归两种写法
  - 一种是传递参数，使用全局变量维护答案
  - 一种是直接递归函数返回答案

## 注意

- 递归不要过于关注每一层怎么调用的，因为很复杂，只需要想好如何递归以及边界，那么根据数学归纳法，这个递归就是正确的

- 递归调用时的栈帧
  - 递归的栈帧保存了这个调用时的状态（主要就是此次的各个参数）
  - 注意引用类型，虽然各自保存了栈帧，但是实际上还是指向同一空间

## 其他例题

### 100. 相同的树

[100. 相同的树](https://leetcode.cn/problems/same-tree/)

原问题：二叉树当前节点相同，左子树相同，右子树也要相同

子问题：p左子树和q左子树相同，p右子树和q右子树相同

边界条件: 如果有一个值不相同，那么就不相同，可以返回了

**第一种写法:**

维护一个全局变量ans，递归时传递当前状态给下一层

```java
class Solution {
    boolean flag;
    public boolean isSameTree(TreeNode p, TreeNode q) {
        flag=true;
        is(p,q);
        return flag;
    }
    public void is(TreeNode p, TreeNode q){
        if(p==null&&q==null){
            return ;
        }
        if((p==null&&q!=null)||(p!=null&&q==null)||p.val!=q.val){
            flag=false;
            return;
        }
        is(p.left,q.left);
        is(p.right,q.right);
    }
}
```

**第二种写法:**

递归函数传递当前状态到下一层，达到边界后，再逐层返回。

因为只要有一个不相等就应该返回false，所以这里应该是`&&`

`isSameTree(p.left,q.left)&&isSameTree(p.right,q.right)`

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null){//如果都是空，返回true
                //涉及到val的访问，所以把null单独拎出来
            return true;
        }
        if((p==null&&q!=null)||(p!=null&&q==null)||p.val!=q.val){
            return false;
        }
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}
```

### 101. 对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

这道题就在100题的基础上稍微改动一下。判断树是否轴对称

对于根节点，已经轴对称不用管。

所以我们传入根节点左右子树。

原问题:根节点的左右子树根据轴对称

子问题:左子树根节点的val等于右子树节点的val，并且左儿子的子树和右儿子对称

> 轴对称就是左子树的左儿子等于右子树左儿子，左子树右儿子等于右子树左儿子。



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240211201406246.png" alt="image-20240211201406246" style="zoom:67%;" />

**注意：时刻牢记，我们这里的递归子问题，我们只比当前节点的val，没有涉及子树的val，那是下一层递归去比的**

**第一种写法**

维护全局变量

```java
class Solution {
    boolean flag;
    public boolean isSymmetric(TreeNode root) {
        flag=true;
        is(root.left,root.right);
        return flag;

    }
    public void is(TreeNode p, TreeNode q){
        if(p==null||q==null){
            if(p!=q){
                flag=false;
            }
            return;
        }
        if(p.val!=q.val){
            flag=false;
            return;
        }
        is(p.left,q.right);
        is(p.right,q.left);
    }
}
```

**第二种写法**

递归直接返回值

注意p，q可能为null的情况，**因为不能对null访问val**

- 其中p,q一个为null，而另一个不为null，应该直接返回
- 所以可以直接在访问val前，当p或q为null时判断一次是否`p==q`

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
       return is(root.left,root.right);
    }
    public boolean is(TreeNode p, TreeNode q){
        if(p==null||q==null){
            return p==q;
        }
        return p.val==q.val&&is(p.left,q.right)&&is(p.right,q.left);
    }
}
```

### 110. 平衡二叉树

[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

**二叉树高度 = Max(左子树高度，右子树高度)+1**

原问题:二叉树所有节点的高度差不超过1

子问题:当前节点左右子树高度差不超过1，并且左右子树的内部的高度差也不会超过1

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240211211202207.png" alt="image-20240211211202207" style="zoom:67%;" />



**第一种解法**

定义一个递归函数求高，如果左右子树高度差超过1，就返回-1。

最后判断最终返回时否为-1.

> 这样的好处是一旦遇到为-1的情况，就会一直返回，停止递归。

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
       return dfs(root)!=-1;
    }
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int L = dfs(root.left);
        if(L==-1){
            return -1;
        }
        int R = dfs(root.right);
        if(R==-1){
            return -1;
        }
        if(R-L>1 || L-R>1) return -1;
        return Math.max(L,R)+1;
    }
}
```

**第二种解法**

维护一个全局变量flag，

定义一个递归函数求高，如果左右子树高度差超过1，更新flag

> 这样就会遍历所有情况，而不是遇到高度差超过1就结束递归

```java
class Solution {
    boolean flag;
    public boolean isBalanced(TreeNode root) {
        flag=true;
        dfs(root);
        return flag;
    }
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int L = dfs(root.left);
        int R = dfs(root.right);
        if(R-L>1 || L-R>1) flag=false;
        return Math.max(L,R)+1;
    }
}
```

> 思考：
>
> Question：我们求高度时，需要传入当前高度加一吗，比如改成dfs(root,cur)
>
> ```java
>   public int dfs(TreeNode root,int cur){
>         if(root==null){
>             return 0;
>         }
>         int L = dfs(root.left,cur+1);
>         int R = dfs(root.right,cur+1);
>         if(R-L>1 || L-R>1) flag=false;
>         return Math.max(L,R)+1;
>     }
> ```
>
> Answer:  (这是我自己犯过的思维混乱)
>
> 当然不用，因为我们计算高度，**是在归的过程中**，把高度一层层向原来返回。
>
> 而传入高度，**是在递的过程中**，对于当前调用的下一次递归调用，并不需要这个cur参数。

### 199.二叉树的右视图

[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

原问题:二叉树每一层的最右边的节点

子问题：在每一层取最右边节点

这道题我们可以先遍历右子树，这样就能保证先遇到右子树右边的节点。

问题

- 怎么判断节点入队?
  - 我们发现，维护一个序列ans，当ans长度为树的深度时，这个节点就可以加入（因为我们是从右开始遍历）。
  - 更细致的想，其实这就是在**递的过程中**，把节点都加入了，而归的过程中什么也不用干。

因为我们是在递的过程中判断当前节点是否加入ans，**所以需要传入深度到下一次递归(区别于求高度，求高度是在归的过程中求)**

```java
class Solution {
    private List<Integer> ans;
    public List<Integer> rightSideView(TreeNode root) {
        ans = new ArrayList<>();
        rightView(root,0);//传入当前深度，因为我们是在递的过程中判断节点是否加入ans
        return ans;
    }
    public void rightView(TreeNode root,int cur){
        if(root==null){
            return;
        }
        if(cur==ans.size()){
            ans.add(root.val);
        }
        rightView(root.right,cur+1);
        rightView(root.left,cur+1);
    }
}
```

## 最近公共祖先

### 236 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

> LCA :最近公共主线

![image-20240226172333193](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240226172333193.png)

#### **分类讨论**

**当前节点是空节点，p，q 返回当前节点**

**其他节点**

- 左右子树都找到: 返回当前节点
- 只有左子树找到: 返回递归左子树的结点
- 只有右子树找到：返回递归右子树的结点
- 左右子树都没有找到: 返回空节点

```java
```



### 235 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

**二叉搜索树性质，对于任何节点，左子树的节点值都比当前节点小，右子树节点值都比当前节点大**

> 这是递归定义的，所以根节点的值比左子树所有节点值都大，根节点值比右子树节点值都要小

我们可以利用这个性质来做题

#### 分类讨论

当前节点是空节点(需要判断吗?)，**答案是不用判断**

因为根节点肯定不能为空，而p,q也不能为空，根据下面的讨论，当前节点肯定也不为空，所以绝对不会返回空，所以不用判空

> $Question:$为什么上一题需要判断呢?
>
> $Answer:$因为在root时，我们无法确定p，q的情况（同在一遍或者两边），只能都去找，**如果一边没有，就只能返回空**

- p,q都在左子树，返回左子树递归节点
- p,q都在右子树，返回右子树递归节点

- 其他情况，返回当前节点
  - p和q分别在左右子树
  - 当前节点是p
  - 当前节点是q

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return dfs(root,p,q);
    }
    public TreeNode dfs(TreeNode root, TreeNode p, TreeNode q){
        if(root==p||root==q){
            return root;
        }
        if(p.val<root.val&&q.val<root.val){
            return dfs(root.left,p,q);
        }
        if(p.val>root.val&&q.val>root.val){
            return dfs(root.right,p,q);
        }
        //p，q在左右子树
        return root;
    }
}
```

