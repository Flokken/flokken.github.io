---
title: 同向双指针
date: 2024-03-04
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---



## 209. 长度最小的子数组

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240304215451132.png" alt="image-20240304215451132" style="zoom:67%;" />

- 注意都是正数,所以和有单调性，只会变大

### 暴力做法

枚举左端点，不断向右拓展(或者枚举右端点，然后不断向左枚举)，直到大于$target$，记录并更新一次答案。

这样做显然是$O(n^2)$。

### 双指针做法

如何优化呢?我们上面大的做法，**没有利用到都是正整数这个性质**

我们在下面这个状态时，已经$>=7$了，所以不会继续向右拓展。按照暴力做法，我们应该枚举2作为左端点，然后再向右拓展。

但是这里我们发现，我们可以缩写左端点而不是从左端点旁边从新枚举。

![image-20240304220714543](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240304220714543.png)

不断缩写左端点。直到$<=7$，那么可以更新一次答案，因为题目求的是满足targte的最小长度子数组

更新完后，继续枚举右端点，直接$>=7$，然后缩写左端点，直到右端点到达边界。

**时间复杂度分析**:  我们枚举从左到右子数组右端点，是$O(n)$的，然后不断收缩左端点，也是$O(n)$的

**第一种写法代码**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n=nums.length;
        int ans = n+1;
        int left=0,r=0;
        int sum=0;
        for( r=0;r<n;r++){
            sum+=nums[r];//枚举右端点，求和
            while(sum-nums[left]>=target){//如果超过target，我们就有可能需要更新答案
                sum-=nums[left];
                left+=1;
            }
            if(sum>=target){//sum>=target才能更新答案
                ans = Math.min(ans,r-left+1);
            }
        }
        return ans==n+1?0:ans;
    }
}
```

$Question：$为什么这里是`  while(sum-nums[left]>=target)`然后更新sum，而不是`sum>=target`然后更新sum?

Answer：因为我们找到是大于等于target的子数组，所以我们首先应该保证和是$>=target$的，所以这里的$sum-nums[left]$是试探，保证sum能大于等于target。 我们可以举特例，比如sum - nums[left]<target，那么就不应该进入循环。`sum>=target`则会，所以不行

$Question:$为什么后面还要判断$sum>=tagret$

A:因为sum可能一直都小于target，那么就不应该更新答案

$Question:$为什么 计算长度是$r-left+1$

A: 我们代**入特殊值假设**$r=1,left=1$，那么长度应该是1，所以我们得到公式应该是$r-left+1$

$Question:$为什么`while(sum-nums[left]>=target)`中不用再加一个$left<=r$防止越界?

$Answer：$我们**代入特殊值**$r=1,left=1$，此时$target=0$,而target是正整数，不应该是0。所以**这个判断条件其实多余的**，这也是从右端点枚举的好处，可以少些一些判断条件

**第二种写法代码**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n=nums.length;
        int ans = n+1;
        int left=0,r=0;
        int sum=0;
        for( r=0;r<n;r++){
            sum+=nums[r];
            while(sum>=target){
                ans = Math.min(ans,r-left+1);
                sum-=nums[left];
                left+=1;
            }
        }
        return ans==n+1?0:ans;
    }
}
```

这里的区别就是把$ans$的更新放到while循环中，并且while循环条件改成了$sum>=target$

这里的思路是，一旦$sum>=target$，就去更新一次$ans$，然后不断缩小$left$，更新最小的$ans$

## 713. 乘积小于 K 的子数组

[713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240304224804937.png" alt="image-20240304224804937" style="zoom:67%;" />

上面是**从满足要求到不满足要求**，也可以是**从满足要求到不满足要求**

- 注意都是正数,所以乘积有单调性，只会变大

**思路**

同样枚举右端点，不断缩短左端点即可。

维护一个乘积，乘上当前元素。如果不满足要求$<k$了，就不断缩短左端点，直到$<k$

- 如何计算子数组数目?**需要推一个公式**
-  我们当前枚举的是右端点，r是固定的，如果[l,r]是乘积是严格小于k的，那么[l+1,r],.[l+2,r]...[r,r]都是乘积小于k的子数组
- 这样的数组个数$r-l+1$，同样**代入特殊值**想$l=1,r=1$应该算1个，所以这里应该是要加1的

**注意**

特殊情况处理

- k<=1
  - 这里的mul初始化为1，而$0<=k<n$，所以当$k<=1$时，根据定义我们应该直接返回0，不然会导致下面的循环一直右移出错

**代码如下**

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int n=nums.length;
        int mul=1;
        if(k<=1){
            return 0;
        }
        int ans=0;
        int left=0,r=0;
        for( r=0;r<n;r++){
            mul*=nums[r];
            while(mul>=k){
                mul/=nums[left];
                left+=1;
            }
            ans+=r-left+1;
        }
        return ans;
    }
}
```

