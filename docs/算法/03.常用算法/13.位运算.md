---
title: 位运算与集合论
date: 2024-01-04
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

位运算很巧妙，但感觉更多是套路，这里做一个记录，看看能不能归纳出什么

> 主要先参考灵神的总结 ,[位运算与集合论](https://leetcode.cn/circle/discuss/CaOJ45/)，后面根据自己的情况进行补充

## 前言

对于一个集合$S=(1,2,4)$，我们在编程中，一般使用哈希表实现，比如Java中的HashSet。

在集合论中，有交集 ∩、并集 ∪、包含于⊆ 等等概念。如果编程实现「求两个哈希表的交集」，需要一个个地遍历哈希表中的元素（暴力的想）。那么，有没有效率更高的做法呢？

**此时就可以用到二进制。**

**非负整数集合可以用二进制表示**，二进制**从低到高**第  $i$位为 1 表示 $i$ 在集合中，为 0 表示 $i$ 不在集合中

>- 注意是非负整数集合
>- 对于二进制1101，最右边是最低位 

比如集合$\lbrace{0,2,3}\rbrace$其二进制表示是1101，1111表示集合$\lbrace0,1,2,3\rbrace$

> 这里可以联想一下，int型一般是32位，所以这个集合一般不超过32？

正式地说，包含非负整数的集合 $S$ 可以用如下方式「压缩」成一个数字（**就是二进制表示非负整数集合，同时这个二进制数也可以转换为10进制的整数**）

> 这里就是所有的基础！

$f(S)=\sum_{i∈S}{2^i}$

比如集合$\lbrace{0,2,3}\rbrace$对于二进制是1101 = $2^0+2^2+2^3$=13.

**位运算具有[并行运算]的特点**，可以让我们高效的进行与集合有关操作。

> Q:什么是位运算的并行计算?
>
> A:二进制每一位是互相独立的。比如 AND 运算，在某个比特位上，两个数必须都是 1，结果才能是 1，把这个运算规则应用到每个比特位就能得到结果。例如 int 有 32 个比特，如果一个个地去算就要算 32 次，但是位运算只需要一次就能全部算完。
>
> [来自灵茶山艾府的回答](https://leetcode.cn/circle/discuss/CaOJ45/view/3CBMzH/)

根据应用场景，一般可以分为：

1. 集合与集合
2. 集合与元素
3. 遍历集合
4. 枚举集合

## 集合与集合

其中 &表示按位与，∣ 表示按位或，⊕ 表示按位异或，∼ 表示按位取反。

| 术语     | 集合     | 位运算             | 集合举例                  | 二进制举例                           | 十进制举例               |
| -------- | -------- | ------------------ | ------------------------- | ------------------------------------ | ------------------------ |
| 交集     | A∩B      | a&b                | {0,2,3}∩{0,1,2}={0,2}     | 1101&0111=0101                       | 13&7=5                   |
| 并集     | A∪B      | a∪b                | {0,2,3}∪{0,1,2}={0,1,2,3} | 1101\|0111 = 1111                    | 13\|7 = 15               |
| 对称差   | A△B      | a⊕b                | {0,2,3}△{0,1,2}={1,3}     | 1101⊕0111  = 1010                    | 13⊕7 = 12                |
| 差       | A\B      | a&~b               | {0,2,3} \ {0,1,2}={3}     | 1101& ~(0111) =1101&1000=1000        | 13&(~7)=8                |
| 差(子集) | A\B(B⊆A) | a⊕b                | {0,2,3} \ {0,2} = {3}     | 1101⊕0101 = 1000                     | 13⊕5 = 8                 |
| 包含于   | A ⊆B     | a&b =a<br/>a\|b =b | {0,2} ⊆{0,2,3}            | 0101&1101 = 0101<br/>0101\|1101=1101 | 5&13  = 5<br/>5\|13 = 13 |

- 注 1：按位取反的例子中，仅列出最低 4 个比特位取反后的结果,即 ~(0111)=1111

  - 在实际环境中，**是先把所有位都取反然后加1（因为计算机中都是补码表示有符号整数数）**。以java为例，0111表示7，那我们假设有代码

    - ```java
       public static void main(String args[]){
              int x= ~7;//int是有符号32位整数
              System.out.println(x);
      //输出-8
       //int型表示的7应该是00000000000000000000000000000111
       //将7的二进制表示取反，得到11111111111111111111111111111000
       //然后，加上1，得到11111111111111111111111111111001。这个二进制数是以补码形式表示的。 表示-8   
          }
      
      ```

- 注 2：包含于的两种位运算写法是等价的，在编程时只需判断其中任意一种。

- 注 3：编程时，请注意运算符的优先级。例如 == 在某些语言中优先级更高。

## 集合与元素

通常会用到移位运算。

其中 << 表示左移，>> 表示右移。

> 注意：左移$i$位相当于乘以$2^i$,右移$i$位相当于除以$2^i$

| 术语                            | 集合             | 位运算        | 举例          | 举例            |
| ------------------------------- | ---------------- | ------------- | ------------- | --------------- |
| 空集                            | ∅                | 0             |               |                 |
| 单元素集合                      | {i}              | 1<<i          | {2}           | 1<<2            |
| 全集                            | U={0,1,2,...n-1} | (1<<n)-1      | {0,1,2,3}     | (1<<4) -1       |
| 属于                            | i∈S              | (s>>i)&1 = 1  | 2∈{0,2,3}     | (1101>>2) &1 =1 |
| 不属于                          | i ∉S             | (s>>i) &1 = 0 | 1∉{0,2,3}     | (1101>>1)&1 = 0 |
| 添加元素                        | S∪{i}            | s\|(1<<i)     | {0,3}∪{2}     | 1001\|(1<<2)    |
| 删除元素                        | S\ {i}           | s&~(1<<i)     | {0,2,3}\ {2}  | 1101&~(1<<2)    |
| 删除元素<br/>(元素一定在集合中) | S\ {i}(i∈S)      | s ⊕(1<<i)     | {0,2,3} \ {2} | 1101  ⊕(1<<2)   |
| 删除最小元素                    |                  | s&(s-1)       |               |                 |

- 这里特别说一下删除最小元素/也就是删除最低位的1

  - ```java
    s = 101100
    s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1
    s&(s-1) = 101000
    ```

**上面的一些结果，可以用Java中提供的标准库函数求得**

| 术语                                       | java                                 |
| ------------------------------------------ | ------------------------------------ |
| 集合大小（元素个数）,也是其二进制中1的个数 | `Integer.bitcount(s)`                |
| 二进制长度（减一得到集合中的最大元素）     | `32-Integer.numberOfLeadingZeros(s)` |
| 集合中的最小元素                           | `Integer.numberOfTrailingZeros(s)`   |

特别地，**只包含最小元素的子集，即二进制最低 1 及其后面的 0，也叫 lowbit**，可以用`s&-s`算出，举例如下:

```java
s = 101100
~s = 010011
(~s)+1 = 010100 // 根据补码的定义，这就是 -s   最低 1 左侧取反，右侧不变
s & -s = 000100 // lowbit
```

## 遍历集合/这个数的每个二进制位

假设$s$位一个int型整数，那么其就有$n=32$位，也即是$[0,32)$

挨个判断每个元素是否在集合s中,其实就是$s$的哪些位是1

```java
int s=5;
for(int i=0;i<n;i++){//n=32
    if(((s>>i)&1) == 1){//i在s中,也就是这一位为1
        //相关i的逻辑
      
    }
}
```

## 枚举集合

设元素范围从0到n-1，从空集 ∅ 枚举到全集 U：

```java
for(int s=0;s<(1<<n);s++){
    //处理s的逻辑
}
```

设集合为s，**从大到小枚举s的所有非空子集sub**

```java
for(int sub = s;sub>0;sub=(sub-1)&s){
        // 处理 sub 的逻辑
}
```

Q:为什么要写成 `sub = (sub - 1) & s` 呢？

A: 暴力做法,从s出发每次减1直到0，即`for(int sub = s;sub>0;sub--)`；但这样做，中途会遇到很多并不是 s 的子集的情况，例如s=10101（21）时，减1得到10100（20）,是s的子集；但再减一是10011(19)，并不是s的子集，其下一个子集应该是10001(17)。

为什么上面那种写法可以找到所有子集？以10101和其所有合法子集来找规律，**会发现我们做的相当于「压缩版」的二进制减法**，例如：

10101->10100->10001->00101->....

**如果忽略掉 10101中的两个 0，数字的变化和二进制减法是一样的，即：**

111->110->101->100->011

**那么具体如何快速找到下一个子集?**

假设s=10101,   这里取其中一步，10100->10001为例，普通的二进制减法是吧最低位1变成0，同时右边的0变成1，即10100 -1=10011。

[压缩版」的二进制减法也是类似的，**把最低位的 1 变成 0，但同时对于 1 右边的 0（见下）**，只保留s=10100中的1，所以是10100->10001。

怎么保留？`& 10101（即s）` 就行。

> 解释：
>
> 把10100 的最低位1变0，它的后面有两位 00， 都是0。这时候按照普通二进制，会把这两个 00 都变成 11(10011)，如果按照压缩版，就只把原来集合里有的 1 变成 1 （因为求的是子集），其余的还是 0，原有的集合是 10101，最后两位是 01，所以只保留 01。综合起来就是 10100 先变 10000，然后保留 01，变成 10001

> 还可以枚举全集U*的所有大小恰好为 k 的子集，这一技巧叫做 Gosper's Hack，这里建议回去看原帖贴出的视频https://leetcode.cn/circle/discuss/CaOJ45/

## java位运算相关运算符

### 基础常识

C/C++位运算符也一样

- &表示按位与
- |表示按位或
- ^按位异或

**Int型整数相关**

`int`类型是32位有符号整数。其中，31位用于表示整数的数值，而最高位（第32位）用于表示符号位，即正数为0，负数为1。这种表示方法称为补码表示法，它允许`int`类型表示从-2,147,483,648到2,147,483,647之间的整数。

- 上限是 (2^31)-1
- 下限是 -2^31

**数学相关**

- 奇数二进制最后一位一定是1,偶数二进制位最后一位一定是0

**注意事项**：

- 位运算一般需要**括起来，**因为其优先级很低，不括起来很可能导致错误
  - 例如： ans[i] = ans[i>>1]+(i&1);

### 移位运算符

- 5<< 1，左移x一位，相当于101变成1010（二进制位后面补个0）；也相当于5*2=10；
- 5>>1,右移一位，
  - 十进制来说就是除2取整
  - 二进制来说就是 被移位的二进制最高位是0，则右移后空缺位补0；被移位的二进制最高位是1，则右移后空缺位补1
- 无符号右移运算符（>>>）：将操作数的所有位向右移动指定的位数，无论正负数，左侧都用0填充。例如，`x >>> n`将x的所有位向右移动n位。

注意运算符格式，操作数1  运算符  操作数2

```java
int x=5;//101
//左移：
x<<1;//x左移一位，补0
x>>1;//x右移一位，相当除以2
```

### 异或运算

> 看完后，直接去看题单的总结，因为实际中还需要多思考变式

本质上是集合的**对称差**

> Question：如何感性理解异或？
>
> Ans：可以理解为**加法/减法**。比如ans=x⊕y⊕z;
>
> - 我现在想减去x，那么就是ans⊕x
>
> - 我现在想加上k, 那么就是ans⊕k

$x⊕0=x$,一个数异或0等于他本身

$x⊕x=0$，相等的数异或为0

$x⊕y=y⊕x$，交换律

$(x⊕y)⊕z=x⊕(y⊕z)$，结合律

$x⊕y⊕y=x$​

推导：

- $x⊕y⊕y=x$

- 如果$x⊕y=z$，那么$x⊕z=y$，$y⊕z=x$。

#### 常用例子

- 让$i$在0,1之间跳动

```java
int i=0;
i^=1;//0^1=1
i^=1;//1^0=0
```

### 与运算

$1\&1=1,x\&x=x$

$1\&0=0$

$0\&0=0$​

> Question:如何感性理解与运算？
>
> Ans：与运算就是求交集，所以结果才只会相等或更小

#### 常用例子

> 注意为了方便，这些示例都没有写前导0，

- **与运算的性质**。AND操作只会让这个数$x<=x$。这个性质经常用于脑筋急转弯
  - $x\&x=x$
  - $x\&y<=x,y!=x$​
  - 例题，[2871. 将数组分割成最多数目的子数组](https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/)。
    - 这道题就利用了这个性质，找子数组尽可能小的最小与和，其实就是找整个数组的最小与和（因为有最小值）。
    - 同时也可以推导出，最小值与其他元素的最小与和，也就时整个数组元素与和。（因为有最小值与其他所有元素相与）

```java
//2=010,4=101
2&5=000//小于自身
//2=010,3=011
2&3=010//等于自身
```

- 遍历num的每一个二进制位，并判断是0还是1
  - 假设这个数$x$是int型，

```java
int x=5;
for(int i=0;i<32;i++){
    if(((x>>i)&1)==1)){//判断每个位是不是1
        //...
    }
}
```



- 移除该二进制最低位的1，$i\&(i-1)$

```java
int i=3;//11
i&(i-1);//11&10=10,移除了最低位的1
```

- lowbit()操作，获取只有该二进制数最低位1的二进制数，$i\&(-i)$​
  - 因为负数是以补码存的，具体就是把这个数每个位取反后再加1.

```java
int i=3;//11
//-i= 00+1=01
i&(-i);//11&01=01  //获得了只有最低位1的数，其他位都是0
```

- 提取奇/偶数位的。[2595. 奇偶位数](https://leetcode.cn/problems/number-of-even-and-odd-bits/)

```java
class Solution {
    public int[] evenOddBit(int n) {
        final int mask = 0x5555;
        return new int[]{Integer.bitCount(n&mask),Integer.bitCount(n&(mask>>1))};
        //n&mask,由于奇数位都是0，进行与运算就是把他们都剔除了，所以这里是提取出偶数位的1，然后计数
        //同理，n&(mask>>1)，就是提取奇数位
    }
}
```

### 或运算

$1|0=1$

$0|0=0$

$1|1=1$​

>Question:如何感性理解或运算？
>
>Ans：与运算就是求并集，所以结果才只会相等或更大

#### 常用例子

- 或运算的性质。对于一个数$x$，与上一个数只会让他更大或者跟原来相等。即$x|y>=x$​。
  - 如果$x|y=x$，说明$y$是$x$的子集（x自身也是自己的子集）

- 设置一个数的每一位为0的数为1
  - 同样假设$x$是int型的数

```java
int n=32;//也可以更小，这表示数据上限，2^n 
for(int i=0;i<n;i++){//注意s是1，所以是开
            if(((num>>i)&1) == 0) ans|=(1<<i);//将该位设置为1
 }
```

