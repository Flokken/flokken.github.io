---
title: 位运算与集合论
date: 2024-01-04
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

位运算很巧妙，但感觉更多是套路，这里做一个记录，看看能不能归纳出什么

> 主要先参考灵神的总结 ,[位运算与集合论](https://leetcode.cn/circle/discuss/CaOJ45/)，后面根据自己的情况进行补充

## 前言

对于一个集合$S=(1,2,4)$，我们在编程中，一般使用哈希表实现，比如Java中的HashSet。

在集合论中，有交集 ∩、并集 ∪、包含于⊆ 等等概念。如果编程实现「求两个哈希表的交集」，需要一个个地遍历哈希表中的元素（暴力的想）。那么，有没有效率更高的做法呢？

**此时就可以用到二进制。**

**非负整数集合可以用二进制表示**，二进制**从低到高**第  $i$位为 1 表示 $i$ 在集合中，为 0 表示 $i$ 不在集合中

>- 注意是非负整数集合
>- 对于二进制1101，最右边是最低位 

比如集合$\lbrace{0,2,3}\rbrace$其二进制表示是1101，1111表示集合$\lbrace0,1,2,3\rbrace$

> 这里可以联想一下，int型一般是32位，所以这个集合一般不超过32？

正式地说，包含非负整数的集合 $S$ 可以用如下方式「压缩」成一个数字（**就是二进制表示非负整数集合，同时这个二进制数也可以转换为10进制的整数**）

> 这里就是所有的基础！

$f(S)=\sum_{i∈S}{2^i}$

比如集合$\lbrace{0,2,3}\rbrace$对于二进制是1101 = $2^0+2^2+2^3$=13.

**位运算具有[并行运算]的特点**，可以让我们高效的进行与集合有关操作。

> Q:什么是位运算的并行计算?
>
> A:二进制每一位是互相独立的。比如 AND 运算，在某个比特位上，两个数必须都是 1，结果才能是 1，把这个运算规则应用到每个比特位就能得到结果。例如 int 有 32 个比特，如果一个个地去算就要算 32 次，但是位运算只需要一次就能全部算完。
>
> [来自灵茶山艾府的回答](https://leetcode.cn/circle/discuss/CaOJ45/view/3CBMzH/)

**常见操作：**

1. 集合与集合
2. 集合与元素
3. 遍历集合
4. 枚举集合

## 集合与集合

其中 &表示按位与，∣ 表示按位或，⊕ 表示按位异或，∼ 表示按位取反。

| 术语     | 集合     | 位运算             | 集合举例                  | 二进制举例                           | 十进制举例               |
| -------- | -------- | ------------------ | ------------------------- | ------------------------------------ | ------------------------ |
| 交集     | A∩B      | a&b                | {0,2,3}∩{0,1,2}={0,2}     | 1101&0111=0101                       | 13&7=5                   |
| 并集     | A∪B      | a∪b                | {0,2,3}∪{0,1,2}={0,1,2,3} | 1101\|0111 = 1111                    | 13\|7 = 15               |
| 对称差   | A△B      | a⊕b                | {0,2,3}△{0,1,2}={1,3}     | 1101⊕0111  = 1010                    | 13⊕7 = 12                |
| 差       | A\B      | a&~b               | {0,2,3} \ {0,1,2}={3}     | 1101& ~(0111) =1101&1000=1000        | 13&(~7)=8                |
| 差(子集) | A\B(B⊆A) | a⊕b                | {0,2,3} \ {0,2} = {3}     | 1101⊕0101 = 1000                     | 13⊕5 = 8                 |
| 包含于   | A ⊆B     | a&b =a<br/>a\|b =b | {0,2} ⊆{0,2,3}            | 0101&1101 = 0101<br/>0101\|1101=1101 | 5&13  = 5<br/>5\|13 = 13 |

- 注 1：按位取反的例子中，仅列出最低 4 个比特位取反后的结果,即 ~(0111)=1111

  - 在实际环境中，**是先把所有位都取反然后加1（因为计算机中都是补码表示有符号整数数）**。以java为例，0111表示7，那我们假设有代码

    - ```java
       public static void main(String args[]){
              int x= ~7;//int是有符号32位整数
              System.out.println(x);
      //输出-8
       //int型表示的7应该是00000000000000000000000000000111
       //将7的二进制表示取反，得到11111111111111111111111111111000
       //然后，加上1，得到11111111111111111111111111111001。这个二进制数是以补码形式表示的。 表示-8   
          }
      
      ```

- 注 2：包含于的两种位运算写法是等价的，在编程时只需判断其中任意一种。

- 注 3：编程时，请注意运算符的优先级。例如 == 在某些语言中优先级更高。

## 集合与元素

通常会用到移位运算。

其中 << 表示左移，>> 表示右移。

> 注意：左移$i$位相当于乘以$2^i$,右移$i$位相当于除以$2^i$

| 术语                            | 集合             | 位运算        | 举例          | 举例            |
| ------------------------------- | ---------------- | ------------- | ------------- | --------------- |
| 空集                            | ∅                | 0             |               |                 |
| 单元素集合                      | {i}              | 1<<i          | {2}           | 1<<2            |
| 全集                            | U={0,1,2,...n-1} | (1<<n)-1      | {0,1,2,3}     | (1<<4) -1       |
| 属于                            | i∈S              | (s>>i)&1 = 1  | 2∈{0,2,3}     | (1101>>2) &1 =1 |
| 不属于                          | i ∉S             | (s>>i) &1 = 0 | 1∉{0,2,3}     | (1101>>1)&1 = 0 |
| 添加元素                        | S∪{i}            | s\|(1<<i)     | {0,3}∪{2}     | 1001\|(1<<2)    |
| 删除元素                        | S\ {i}           | s&~(1<<i)     | {0,2,3}\ {2}  | 1101&~(1<<2)    |
| 删除元素<br/>(元素一定在集合中) | S\ {i}(i∈S)      | s ⊕(1<<i)     | {0,2,3} \ {2} | 1101  ⊕(1<<2)   |
| 删除最小元素                    |                  | s&(s-1)       |               |                 |

- 这里特别说一下删除最小元素

  - ```java
    s = 101100
    s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1
    s&(s-1) = 101000
    ```

**上面的一些结果，可以用Java中提供的标准库函数求得**

| 术语                                   | java                                 |
| -------------------------------------- | ------------------------------------ |
| 集合大小（元素个数）                   | `Integer.bitcount(s)`                |
| 二进制长度（减一得到集合中的最大元素） | `32-Integer.numberOfLeadingZeros(s)` |
| 集合中的最小元素                       | `Integer.numberOfTrailingZeros(s)`   |

特别地，**只包含最小元素的子集，即二进制最低 1 及其后面的 0，也叫 lowbit**，可以用`s&-s`算出，举例如下:

```java
s = 101100
~s = 010011
(~s)+1 = 010100 // 根据补码的定义，这就是 -s   最低 1 左侧取反，右侧不变
s & -s = 000100 // lowbit
```

## 遍历集合

设元素范围从0到n-1,挨个判断每个元素是否在集合s中

```java
for(int i=0;i<n;i++){
    if(((s>>i)&1) == 1){//i在s中
        //相关i的逻辑
    }
}
```

## 枚举集合

设元素范围从0到n-1，从空集 ∅ 枚举到全集 U：

```java
for(int s=0;s<(1<<n);s++){
    //处理s的逻辑
}
```

设集合为s，**从大到小枚举s的所有非空子集sub**

```java
for(int sub = s;sub>0;sub=(sub-1)&s){
        // 处理 sub 的逻辑
}
```

Q:为什么要写成 `sub = (sub - 1) & s` 呢？

A: 暴力做法,从s出发每次减1直到0，即`for(int sub = s;sub>0;sub--)`；但这样做，中途会遇到很多并不是 s 的子集的情况，例如s=10101（21）时，减1得到10100（20）,是s的子集；但再减一是10011(19)，并不是s的子集，其下一个子集应该是10001(17)。

为什么上面那种写法可以找到所有子集？以10101和其所有合法子集来找规律，**会发现我们做的相当于「压缩版」的二进制减法**，例如：

10101->10100->10001->00101->....

**如果忽略掉 10101中的两个 0，数字的变化和二进制减法是一样的，即：**

111->110->101->100->011

**那么具体如何快速找到下一个子集?**

假设s=10101,   这里取其中一步，10100->10001为例，普通的二进制减法是吧最低位1变成0，同时右边的0变成1，即10100 -1=10011。

[压缩版」的二进制减法也是类似的，**把最低位的 1 变成 0，但同时对于 1 右边的 0（见下）**，只保留s=10100中的1，所以是10100->10001。

怎么保留？`& 10101（即s）` 就行。

> 解释：
>
> 把10100 的最低位1变0，它的后面有两位 00， 都是0。这时候按照普通二进制，会把这两个 00 都变成 11(10011)，如果按照压缩版，就只把原来集合里有的 1 变成 1 （因为求的是子集），其余的还是 0，原有的集合是 10101，最后两位是 01，所以只保留 01。综合起来就是 10100 先变 10000，然后保留 01，变成 10001

> 还可以枚举全集U*的所有大小恰好为 k 的子集，这一技巧叫做 Gosper's Hack，这里建议回去看原帖贴出的视频https://leetcode.cn/circle/discuss/CaOJ45/

## java位运算相关运算符

C/C++位运算符也一样

- &表示按位与
- |表示按位或
- ^按位异或
- ~按位取反
  - 得到其补码

移位运算符

- 5<< 1，左移x一位，相当于101变成1010（二进制位后面补个0）；也相当于5*2=10；
- 5>>1,右移一位，
  - 十进制来说就是除2取整
  - 二进制来说就是 被移位的二进制最高位是0，则右移后空缺位补0；被移位的二进制最高位是1，则右移后空缺位补1
- 无符号右移运算符（>>>）：将操作数的所有位向右移动指定的位数，无论正负数，左侧都用0填充。例如，`x >>> n`将x的所有位向右移动n位。

## 例题

[2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/)

利用行当成二进制数，选择的列的集合也当成二进制数。

**并且如果覆盖，其实就是指的是二进制中，1的位置都一样，所以就是两者与的结果相同**