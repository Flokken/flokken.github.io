---
title: 动态规划入门：从记忆化搜索到递推
date: 2024-02-23
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

> 参考:[从记忆化搜索到递推](https://www.bilibili.com/video/BV1Xj411K7oF/?spm_id_from=333.788&vd_source=d005def162a369d30cf8c241225a9395)

## 理论学习

动态规划常常无从下手，因为写不出**状态定义**和**状态转移方程?，的确这两者也是DP的核心**

**启发思路**

- 选或不选
  - 选哪个

> 这个得多做题才能理解，选或不选就是我们如何把原问题分割位子问题的宏观思路

**DP萌新三步**

- 思考回溯怎么写
  - 入参和返回值
  - 递归到哪里
  - 递归边界和入口
- 改成记忆化搜索
- 1:1翻译为递推

下面通过题目来落实

## 196.打家劫舍

> https://leetcode.cn/problems/house-robber/solutions/2102725/ru-he-xiang-chu-zhuang-tai-ding-yi-he-zh-1wt1/

![image-20240223160733512](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240223160733512.png)

### **思考过程**

- **先想回溯：我们要先把原问题缩小为规模更小的子问题，一般来说，从第一个或者最后一个开始思考最容易，因为他们受到约束最小**
  - 假设我们从最后一个房子开始想，那么问题是：从前n个房子中得到最大金额和
    - 如果不选:那么问题转换为—>**从前n-1个房子中取得的最大金额和**
    - 如果选: 由于不能选两个连续的（**题目要求**），所以n-1不能选，只能从n-2开始选，问题转化为—>**从前n-2个房子中取得的最大金额和**

![image-20240223184739918](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240223184739918.png)

> 记忆化优化：把计算结果保存下来，避免重复计算
>
> 记忆化优化一般都会用到，所以默认都是记忆化回溯，
>
> **上面的搜索树记忆化优化后如下**：
>
> ![image-20240223190333562](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240223190333562.png)
>
> 

### 回溯三问

- **回溯三问**
  - 当前操作?   枚举**第**$i$个房子选/不选
  - 子问题? 从**前**$i$个房子中得到的最大金额和
  - 下一个子问题？分类讨论
    - 不选：从**前**$i-1$个房子中得到的最大金额和
    - 选： 从**前**$i-2$个房子中得到的最大金额和
  - Tip:这里注意**第**和**前**的区别。第表示一个数，前表示一些数。**我们的dfs或者DP的状态转移方程算的都是一些数，而不是一个数（这里要理解）**
    - 所以在dfs和dp的状态中，是**前**
    - 枚举当前操作时，是**第**

定义$dfs(i)$表示前$i$个房子的最大金额和

那么其回溯的状态转移如下：

$dfs(i) = max(dfs(i-1),dfs(i-2)+nums[i])$

**边界条件**

- 如果$i<0$，返回0，代表没有房子

```java
class Solution {
    int []ans;
    public int rob(int[] nums) {
        int n= nums.length;
        ans = new int[n];
        for(int i=0;i<n;i++){//记忆数组
            ans[i]=-1;//初始化
        }
        return dfs(n-1,nums);
    }
    public int dfs(int i,int []nums){
        if(i<0){//边界，没有房子
            return 0;
        }
        //记忆化
        if(ans[i]!=-1){
            return ans[i];
        }
        ans[i]=Math.max(dfs(i-1,nums),dfs(i-2,nums)+nums[i]);
        return ans[i];
    }
}
```

**时空复杂度计算**

对于回溯或者DP，都可以用一个公式计算

空间复杂度: 状态个数，所以是O(n)

时间复杂度: 状态个数*单个状态所需计算时间，即$O(n) * O(1)=O(n)$

**转化为递推**

我们仔细观察搜索树，**发现计算的过程都是在归的过程中，所以应该可以省略掉递的过程。**

> 所以dp其实就是利用了归的过程，所以我们是从回溯转为递推，因为回溯就是利用[归]这个过程

### **1:1翻译成递推（重）**

- dfs - > f数组
- 递归 -> 循环
- 递归边界 - > 数组初始值

dfs的状态转移

$dfs(i) = max(dfs(i-1),dfs(i-2)+nums[i])$​

翻译为递推

$f[i]=max(f[i-1],f[i-2]+nums[i])$

由于$0<=i<n$​​，当$i==1$时，会出现$f[-1]$，会去访问$nums[-1]$，也就是出现负数下标

解决办法有两种

- 我们可以让$i$​从2开始，保持原有的转移方程
  - 但是这里存在$nums[i]$并且$i$和$f$​数组的不一致，  所以不能这么干，会少计算这里
  - 746题那种状态转移方程式可以这么干的。

- 转移方程中，$f$数组都加上2。其本质相当于在$f$数组前插入两个空位，那么跟$f$​​数组相关的都要被影响
  - 返回值，转移方程，f数组初始化大小
  - $nums$​不受影响

只能第二种方法，得到

$f[i+2]= max(f[i+1],f[i]+nums[i])$

> $Question$:为什么$nums[i]$没有换成$nums[i]+2$?
>
> A: 注意无论是dfs还是f,表示的是**一些数据，是一个过程**，所以可以等效的替换$i$到$i+2$，**而不会影响他们之间的递推关系**
>
> 而$nums[i]$是一个值，所以不能也不用替换

注意数组应该初始化到$n+2$​的大小

**返回值**：

原来返回$f[n-1]$,统一加2，所以应该是$f[n+1]$​

**边界**：

回溯边界是$i<0$，返回0

那么这里都初始化为0即可

```java
class Solution {
    public int rob(int[] nums) {
        int n= nums.length;
        int []f = new int[n+2];
        for(int i=0;i<n;i++){
            f[i+2]=Math.max(f[i+1],f[i]+nums[i]);
        }
        return f[n+1];
    }
}
```

### 优化到O(1)的空间复杂度

观察这个$f[i+2]= max(f[i+1],f[i]+nums[i])$转移方程

**当前状态只和上一个状态和上上一个状态有关，所以可以把f数组省略，迭代更新这两个值即可**

这种方法叫**滚动数组**

```java
class Solution {
    public int rob(int[] nums) {
        int n= nums.length;
        int f1,f2;
        f1=f2=0;
        for(int i=0;i<n;i++){
            int cur=Math.max(f1,f2+nums[i]);
            //cur也可以省略
            f2=f1;
            f1=cur;
        }
        return f1;//因为f1最后等于cur，所以可以直接返回cur
    }
}
```

## 练习

### 70. 爬楼梯

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

![image-20240405110042383](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240405110042383.png)

> 灵神题解：https://leetcode.cn/problems/climbing-stairs/solutions/2560716/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-7zm1

思路：

回溯三连：

**原问题**：从0爬到n有多少种方法

- 当前操作：第i次操作选择爬到i+1，还是i+2
- 子问题：从0到第n阶有多少种方法
- 下一个子问题？分类讨论
  - 选i+1, 那么从0到n-1楼梯中获取方法数
  - 选i+2,那么从0到n-2楼梯中获取方法数

$dfs(n)=dfs(n-1)+dfs(n-2)$​

边界:

当n=0或者n=1时，返回1

> 从0爬到0，从0爬到1

```java
class Solution {
    int []f;//记忆化
    public int climbStairs(int n) {
       f=new int[n+2];
       Arrays.fill(f,-1);
       return dfs(n);
      
    }
    public int dfs(int n){
        if(n==0||n==1) return 1;
        if(f[n]!=-1) return f[n];
        return f[n]=dfs(n-1)+dfs(n-2);
    }
}
```

**转换为递推**

dfs转移方程

$f[i]=f[i-1]+f[i-2]$​

注意$0<=i<=n$，所以也存在负数下标问题。

但是这里和打家劫舍的区别是，没有$nums$数组

- 所以这里可以让$i$从2开始遍历即可，也就是$2<=i<=n$

边界

$f[0]=1,f[1]=1$

返回值

$f[n]$

```java
class Solution {
    public int climbStairs(int n) {
       int []f=new int[n+1];
       f[0]=1;
       f[1]=1;
       for(int i=2;i<=n;i++){
            f[i+]=f[i-1]+f[i-2];
       }
       return f[n];  
    }
}
```

### 746. 使用最小花费爬楼梯

[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240405161135785.png" alt="image-20240405161135785" style="zoom: 80%;" />

> 没有独立做出来,2024/04/05
>
> 灵神题解:https://leetcode.cn/problems/min-cost-climbing-stairs/solutions/2569116/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-j99e

**回溯**：

假设数组 长度是$n$

**原问题**：从0或1  爬到$n$​的台阶的最小花费（也就是有n个台阶）

> 注意这里包括了第n阶也就是$cost[n-1]$阶的花费

回溯三问：

- 当前操作，第i次可以跳一阶或者跳两阶
- 子问题：从前$n$个台阶中得到到顶部的最小花费
- 下一个子问题？分类讨论
  - 从$n-1->n$，还需要找**前**$i-1$​个台阶中得到的最小花费
    - $dfs(i)=dfs(i-1)+cost[i-1]$
  - 从$n-2->n$，还需要找**前**$i-2$​个房子台阶中得到的最小花费
    - $dfs(i)=dfs(i-2)+cost[i-2]$

$dfs(n)=Math.min(dfs(n-1)+cost[n-1],dfs(n-2)+cost[n-2])$

边界：

- n=0或者n=1时，返回0。 因为我们起步就在0或者1

```java
class Solution {
    int []f;
    public int minCostClimbingStairs(int[] cost) {
        int n=cost.length;
        f=new int[n+1];
        Arrays.fill(f,-1);
        return dfs(n,cost);
    }
    public int dfs(int n,int [] cost){
        if(n==0||n==1) return 0;
        if(f[n]!=-1) return f[n];
        return f[n]=Math.min(dfs(n-1,cost)+cost[n-1],dfs(n-2,cost)+cost[n-2]);
    }
}
```

**1:1转换为递推**

转移方程

$f[i]=Math.min(f[i-1]+cost[i-1],f[i-2]+cost[i-2])$​

注意到这里如果$i<=2$会导致负数下标，所以我们从$i=2$​开始

> Question：这里为什么不需要变换f数组，让他们都加2？
>
> Ans：

边界

$f[0]=0,f[1]=0$

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n=cost.length;
        int []f=new int[n+1];
        for(int i=2;i<=n;i++){
            f[i]=Math.min(f[i-1]+cost[i-1],f[i-2]+cost[i-2]);
        }
        return f[n];
    }
  
}
```

### 377. 组合总和 Ⅳ

[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240405165942507.png" alt="image-20240405165942507" style="zoom:67%;" />

> 灵神题解：https://leetcode.cn/problems/combination-sum-iv/solutions/2706336/ben-zhi-shi-pa-lou-ti-cong-ji-yi-hua-sou-y52j
>
> 本质还是爬楼梯

**回溯**：

原问题：假设nums长度为n，那么就是从n个数字中选取（可以重复）任意数量数字，和刚好为target的组合数量

回溯三问：

- 当前操作：从n个数字中选择任意一个$nums[i]<target$
- 子问题：从n个数字中选择和为$target$的数的组合数量
- 下一个子问题：
  - 从n个数字任意选择一个数$nums[i]$使得和为$target-nums[i]$的组合数量
    - 有前提，$nums[i]<=target$​

定义$dfs(t)$表示和为$t$的组合数量

$dfs(t)=\sum dfs(t-nums[i]),0<=i<n$​

**边界**:

如果t==0,说明找到一种方法，返回1

如果<0，说明不行，返回0. （这里没有这条语句也可以，因为当t<0之后，上面的前提条件就不会满足，也就不会再递归）

```java
class Solution {
    int []f ;
    public int combinationSum4(int[] nums, int target) {
        int n=nums.length;
        f=new int[target+1];
        Arrays.fill(f,-1);
        return dfs(nums,target);
        
    }
    public int dfs(int []nums, int t){
        if(t<0) return 0;
        if(t==0) return 1;
        if(f[t]!=-1) return f[t];
        int res=0;//统计数量
        for(var x:nums){
            if(x<=t) {
                res+=dfs(nums,t-x);
            }
        }
        return f[t]=res;
    }
}
```

**1:1转换为递推**

$f[t]=\sum f[t-nums[i]],0<=i<n$​

边界

$f[0]=1$

这里怎么转换成循环的写法呢（很难想）？

> 这里递归里有循环，一般就需要二重循环

我们知道$f[t]$依赖于$f[t-x]$，也就是t小于他的状态。

所以我们可以外层枚举$1-target$，内层枚举nums，这样可以才算出$f[1-target]$的每一个解

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n=nums.length;
        int [] f=new int[target+1];
        f[0]=1;
        for(int i=1;i<=target;i++){
            for(var x:nums){
                if(x<=i){
                    f[i]+=f[i-x];
                }
            }
        }
        return f[target];
    }
}
```



## 总结

1.Question:为什么回溯可以转换为递推呢？

Ans：  回溯着重于在递归的[**归**]的过程中计算问题，也就是先把问题分解为子问题，最后子问题得到答案后求出问题答案。这个过程和递推是一样的。只不过一个利用递归实现，一个利用循环实现。

2.如果是回溯，默认都要用记忆化，因为这样可以节约很多重复时间

- 原理就是DP的特性，减少了重复子问题的计算

3.DP问题模板

在不熟练时，我们都先写回溯再写DP

**回溯**

首先写出**原问题**，

> 这里很重要，原问题和子问题非常重要，没写对其实就是没想清楚
>
> Question：怎么写出原问题？
>
> Ans：关注起点，终点，目的

然后写出回溯三问

- 当前操作
- 子问题
- 下一个子问题

那么就可以得到dfs转移方程。

分析问题，得到边界。

**1:1转换为递推**

这里注意负数下标的转化问题

> 熟悉之后直接写递推，因为回溯写起来有时会很麻烦



