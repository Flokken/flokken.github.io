---
title: 子集型回溯
date: 2023-03-07
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 回溯理论

### 17. 电话号码的字母组合

[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308191820922.png" alt="image-20240308191820922" style="zoom: 80%;" />

### 从多重循环到回溯

首先我们思考，循环能否解决这个问题。

如果digits长度是2，那么显然是可以的，第一重循环枚举`adc`，第二重循环枚举`def`。

但是如果枚举长度为3，4那么就需要更多重数，并且如果长度不确定，怎么写呢?

**单纯的循环表达能力是有局限的**

### 递归和回溯

之前学习递归时，我们知道我们可以用递归解决**原问题和子问题相似的问题**

- 原问题：枚举长为$n$的字符串 
  - 每一步操作，枚举一个字母
- 子问题：构造长度为$n-1$的字符串

子问题和原问题是**相似**的，这种从原问题到子问题的过程，适合用**递归解决**

**回溯**有一个**增量**构造答案的过程，这个过程常常可以用递归实现

> $Question$:这里不是回溯吗，怎么用递归？
>
> $Answer$ : 回溯是一种思想/算法，而递归时一种编程技巧，回溯可以用递归实现

我们具体看一下搜索树

![image-20240308195024222](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308195024222.png)

注意，像之前学习递归时一样，递归关键的是**边界条件和非边界的执行逻辑**，而不是想每一层怎么实现的，只要边界和执行逻辑对了，根据数学归纳法，递归就是对的

![image-20240308195240793](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308195240793.png)

用一个$path$数组记录路径上的字母即可

### 回溯三问

- 当前操作?枚举$path[i]$要填入的字母
- 子问题?构造字符串$>=i$的部分
- 下一个子问题?构造字符串$>=i+1$的部分

$dfs(i)->dfs(i+1)$

> 强调一下，这里的$i$不是第$i$个，而是下标$>=i$的部分

#### 代码

$Question$:回溯不应该需要重置状态吗，这里怎么没有?

$Answer$：因为这里的path可以被覆盖，就相当于先还原再填充

> 后面我写了一个更明显的版本

```java
class Solution {
    String[] mp={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    char []path;
    int n;
    List<String>ans;
    char []digits;
    public List<String> letterCombinations(String digits) {
         this.n=digits.length();
         path=new char[n];
        ans=new ArrayList<>();
        this.digits = digits.toCharArray();
        if(digits.equals("")) return ans;
        dfs(0);
        return ans;
    }
    public void dfs(int i){
        if(i==n){
            ans.add(new String(path));
            return;
        }
        for(var c:mp[digits[i]-'0'].toCharArray()){
            path[i]=c;
            dfs(i+1);
        }
    }
}
```

这里我们使用一个$StringBuilder$记录答案，我们显式的还原答案，但实际上没有什么区别

```java
class Solution {
    String[] mp={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    int n;
    List<String>ans;
    char []digits;
    public List<String> letterCombinations(String digits) {
         this.n=digits.length();
        StringBuilder path=new  StringBuilder();
        ans=new ArrayList<>();
        this.digits = digits.toCharArray();
        if(digits.equals("")) return ans;
        dfs(0,path);
        return ans;
    }
    public void dfs(int i,StringBuilder path){
        if(i==n){
            ans.add(path.toString());
            return;
        }
        for(var c:mp[digits[i]-'0'].toCharArray()){
            path.append(c);
            dfs(i+1,path);
            path.deleteCharAt(i);//还原状态
        }
    }
}
```

### 时空复杂度

对于回溯问题，也可以从循环角度理解。枚举第一个字母就是最外层循环，第二个就是第二重循环........观察我们的代码，里面最多的次数需要循环4次也就是$pqrs或者wxyz$

所以最多的时候我们需要循环$O(4^n)$次

> 再详细一点，假设我们输入长度是n，每次都要枚举长度为4的字符串，那么就是4*4...,.n个4相乘就是4^n

## 子集型回溯

每个元素都可以**选/不选**

> 01背包也是一种子集型回溯

### 78. 子集

[78. 子集](https://leetcode.cn/problems/subsets/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308202744098.png" alt="image-20240308202744098" style="zoom:80%;" />

举例：枚举[1,2]的子集

### 模板1：站在输入角度想

站在输入的角度思考，每个数可以在子集中（**选**），也可以不在子集中（**不选**）

![image-20240308203059441](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308203059441.png)

#### 回溯三问

- 当前操作?枚举第$i$个数选不选
- 子问题?从下标$>=i$的数字中构造子集
- 下一个子问题?  从下标$>=i$的数字中构造子集

$dfs(i)->dfs(i+1)$

> 这里$i$的含义就是第$i$个数选不选

**边界条件**  $i==n$,虽然我们只有$0-n-1$个数，但是到了$n$才说明我们已经枚举了前$n$个数，所以才可以算作一个子集

```java
class Solution {
    List<List<Integer>> ans;
    List<Integer>path;
    int n;
    int []nums;
    public List<List<Integer>> subsets(int[] nums) {
        this.n= nums.length;
        this.nums= nums;
        this.path = new ArrayList<>();
        ans = new ArrayList<>();
        dfs(0);
        return ans;
    }
    public void dfs(int i){
        if(i==n){
            ans.add(new ArrayList(path));//这里注意很常见的问题，对象是引用，所以要加入其复制
            return;
        }
        path.add(nums[i]);
        dfs(i+1);//选了第i个数
        path.remove(path.size()-1);//丢弃刚刚加入的数，还原状态

        dfs(i+1);//不选第i个数
    }
}
```

**时间复杂度分析**

我们这里每次只有选/不选两种情况，所以一共有$O(2^n)$的复杂度

并且由于我们使用了$copy$，每次是$O(n)$，所以应该是$O(n*2^n)$的时间复杂度

### 模板2：站在答案角度想

站在答案角度想，

- 枚举第一个数选谁
- 枚举第二个数选谁
- ........

每个节点都是答案

![image-20240308210350355](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308210350355.png)

#### 回溯三问

- 当前操作?枚举一个下标$j>=i$的数字，加入$path$
- 子问题？从下标$>=i$的数字中构造子集
- 下一个子问题？**从下标**$>=j+1$的数字中构造子集

**注意：**

- [1,2]和[2,1]是重复的子集，为了避免重复，**所以可以规定下一个数的下标应该选大于当前选择的数下标**
  - 注意题目说了nums中的数不相同
- 由于子集长度没有限制，**所以现在每个节点都是答案**

$dfs(i)->dfs(i+1)||dfs(i+2)||dfs(i+3).....$

> 注意：这里的$i$指的是从下标大于$i$的数中中构造子集

Tips:仔细观察这两种方式的**边界，状态的含义**

```java
class Solution {
    List<List<Integer>> ans;
    List<Integer>path;
    int n;
    int []nums;
    public List<List<Integer>> subsets(int[] nums) {
        this.n= nums.length;
        this.nums= nums;
        this.path = new ArrayList<>();
        ans = new ArrayList<>();
        dfs(0);
        return ans;
    }
    public void dfs(int i){
        ans.add(new ArrayList(path));
        if(i==n) return;//由于下面的循环也加了<n，所以这里可以省略
        for(int j=i;j<n;j++){
            path.add(nums[j]);//当前操作，枚举下标>=i的数加入
            dfs(j+1);//选了第i个数   //下一个子问题，从下标>=j+1的数中构造子集
            path.remove(path.size()-1);//丢弃刚刚加入的数，还原状态
        }
    }
}
```

## 例题

### 131. 分割回文串

[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308212401493.png" alt="image-20240308212401493" style="zoom:80%;" />

举例：计算"aab"的所有回文分割

枚举"a,a,b"的这两个逗号，**选/不选**

["aab"]   X

["a","ab"]  X

["aa","b] V 是回文字符串

["a","a","b]  V 是回文字符串

![image-20240308213727069](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240308213727069.png)

### 回溯三问

- 当前操作？选择回文子串$s[i...j]$，加入$path$
  - 我们枚举逗号其实**相当于**枚举回文字符串结束的位置，也就是$j>=i$
- 子问题？从下标$>=i$的后缀中构造回文分割
- 下一个子问题？从下标$>=j+1$ 的后缀中构造回文分割

$dfs(i)->dfs(i+1)||dfs(i+2)||.....||dfs(n)$

> 注意这里的$i$，指的是从$i$后面的字符串$j>=i$中枚举回文字符串的结束位置/逗号

**注意：**

- 
