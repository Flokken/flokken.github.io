---
title: 回溯算法
date: 2023-11-01
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

> 参考：
>
> [Hello算法-回溯](https://www.hello-algo.com/chapter_backtracking/backtracking_algorithm)

## 什么是回溯算法

「回溯算法 backtracking algorithm」是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。

**回溯算法通常采用“深度优先搜索”来遍历解空间。**

> 二叉树的前中后序遍历就是深度优先遍历

### 回溯求全排列	

>[46. 全排列](https://leetcode.cn/problems/permutations/)
>
>[全排列题解](https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked)

问题：给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

我们用搜索的方法可以得到答案，我们以求[1,2,3]的全排列模拟一下过程。

![image.png](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)

那么怎么实现呢?我们知道利用dfs，可以求遍历，那么怎么实现撤销操作然后从上一个状态再去选呢，**就要用到回溯。**

说明：

- 每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「**不同的值」**体现，**这些变量的不同的值，称之为「状态」；对应到递归中，每个状态都是一次递归的调用（该函数的调用）**
- 使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为**「状态重置」；**
- 深度优先遍历，就是递归，每次递归调用，系统都会开一个栈帧，保存所需要的状态变量。在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的 时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，**因此 path 变量是一个栈；**
- 深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。

这里面有个不好理解的东西，就是状态变量，**注意状态变量不能等同于递归函数的参数。状态变量用来确定递归的状态的**

**状态变量设计**

- 首先考虑递归怎么终止，肯定需要计数长度，所以用`depth`确定当前状态的排列长度
- 我们还需要一个布尔数组 `used`，初始化的时候都为 `false` 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 `true` ，回溯时把其再置为false

> 所以这里depth和used数组就表示了状态，但是used数组也并没有作为dfs的参数，只是里面用到了而已。

```java
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        List<Integer> path = new ArrayList<>();
        dfs(nums, len, 0, path, used, res);
        return res;
    }
    private void dfs(int[] nums, int len, int depth,
                     List<Integer> path, boolean[] used,
                     List<List<Integer>> res) {
        if (depth == len) {
            //res.add(path);
            res.add(new ArrayList<Integer>(path))
            return;
        }

        // 在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。
        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;

                //dfs(nums, len, depth + 1, new ArrayList<Integer>(path), used, res);
                dfs(nums, len, depth + 1, path, used, res);
                // 注意：下面这两行代码发生 「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的
                used[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }

}

```

**细节**

我们在`res`添加path时需要重新new一个空间，或者dfs传参时new，为什么？

**因为递归虽然就是再调用一次方法/函数，会在栈帧里创建局部变量，但是path是引用类型**。java中的引用类型，如果只是传参，那么就是传地址值（**java传参只有值传递**），**所以这些栈帧里的path变量仍然指向的是同一个堆中的位置。**

> 如果不new一个新的，那么最后因为path的数组回到root全部出栈了，res中就是6个空列表。

所以要么res.add的时候进行拷贝，要么dfs时传参是进行拷贝。





当然，为了加深理解，可以从[1,2,3]中的[1,2,3]和[1,3,2]的回溯过程来仔细感受一下

![image-20231101221656226](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231101221656226.png)

[https://www.hello-algo.com/chapter_backtracking/backtracking_algorithm/]: 
[https://www.hello-algo.com/chapter_backtracking/backtracking_algorithm]: 
