---
title: 贪心
date: 2023-11-21
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 介绍

「贪心算法 greedy algorithm」是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择**，即贪心地做出局部最优的决策，以期望获得全局最优解**。

贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理是不同的。

- 动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。
- 贪心算法不会重新考虑过去的决策，而是一路向前地进行贪心选择，**不断缩小问题范围，直至问题被解决**。

一般情况下，贪心算法适用于以下两类问题。

1. **可以保证找到最优解**：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。
2. **可以找到近似最优解**：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解是非常困难的，能以较高效率找到次优解也是非常不错的。

## 算法特性

什么样的问题适合用贪心算法求解呢？或者说，**贪心算法在什么情况下可以保证找到最优解**？

相较于动态规划，贪心算法的使用条件更加苛刻，其主要关注问题的两个性质。

- **贪心选择性质**：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解。
- **最优子结构**：原问题的最优解包含子问题的最优解。

最优子结构已经在动态规划章节中介绍过，不再赘述。值得注意的是，一些问题的最优子结构并不明显，但仍然可使用贪心算法解决。

> 这个贪心选择性质是个困难的事情，一般用反证法能证一下就不错了

## 一般步骤

贪心问题的解决流程大体可分为以下三步。

1. **问题分析**：梳理与理解问题特性，包括**状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及**。
2. **确定贪心策略**：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终能解决整个问题。
3. **正确性证明**：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要使用到数学证明，例如归纳法或反证法等。

确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要包含以下原因。

- **不同问题的贪心策略的差异较大**。对于许多问题来说，贪心策略都比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了。
- **某些贪心策略具有较强的迷惑性**。当我们满怀信心设计好贪心策略，写出解题代码并提交运行，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，上文介绍的零钱兑换就是个典型案例。

为了保证正确性，我们应该对贪心策略进行严谨的数学证明，**通常需要用到反证法或数学归纳法**

## 例题

- **硬币找零问题**：在某些硬币组合下，贪心算法总是可以得到最优解。
  - 注意，如果要保证得到最优解，应该用动态规划。
- **区间调度问题**：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。
- **分数背包问题**：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。
- **股票买卖问题**：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。
- **霍夫曼编码**：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最小的两个节点合并，最后得到的霍夫曼树的带权路径长度（即编码长度）最小。
- **Dijkstra 算法**：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。

### 100255. 成为 K 特殊字符串需要删除的最少字符数

[100255. 成为 K 特殊字符串需要删除的最少字符数](https://leetcode.cn/problems/minimum-deletions-to-make-string-k-special/)

> 389场周赛Q3

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240317182418633.png" alt="image-20240317182418633" style="zoom:80%;" />

题意：统计字符串中每个字母出现频率，删除字符，使得任意两个字符频率之差不超过$k$​

![image-20240317185324036](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240317185324036.png)

**转换问题**

求需要删除字符的最小数量等价于保留的字符的最多数量

> 删除最小数量并不好求，为什么呢？

首先把上面的题目转换

- 求最少删除字符数量->求最多保留的字符数量
- 任意两个字符频率差值不超过$k$->最大频率字符-最小频率字符$<=k$

怎么实现呢？

我们可以证明，最后的所有字符的出现次数的最小的，应该是原来就出现过的

> 因为只能递减，所以最后无论是什么情况，**一定是用原来就有的出现次数当最小出现次数是最优的**
>
> 举例： a=4,b=2,c=1,k=2,   我们以b=2作为最小出现次数，所以只需移除c=1即可

- **枚举出现次数最少**的字母，只有26个字母，记为base
  - 如果字母出现次数<base,全部删除
  - 如果字母出现次数>base,保留min(c,base+k),c是这个字符出现次数
    - 因为我们求得是最多保留，所以要让尽可能多的字符留下来，因为当前最小为base，为了满足条件，所以最多也只能留下base+k
  - 维护一个最大值`max_save`表示以当前字母出现次数为base的最大保留字母数，每轮循环结束更新
- `return word.length-max_save`

> Question：为什么要枚举每个字母的出现次数作为出现次数最少的字母呢？
>
> Answer：因为这个解的集合中一定包含了最优解

具体实现：

- trick：对于频次升序排序，这样枚举时，当前位置左边的由于比base更小，所以全部删除了，不用统计，只需统计右边的

> Question：如果枚举出现次数最多字符可以吗？



```java
class Solution {
    public int minimumDeletions(String word, int k) {
        int []cnt = new int[26];
        for(char c:word.toCharArray()){
            cnt[c-'a']+=1;
        }
        Arrays.sort(cnt);
        int max_value = 0;//最多保留的字符数
        for(int i=0;i<26;i++){
            int base=cnt[i];
            int res=cnt[i];//以当前字符为base的最多保留次数
            for(int j=i+1;j<26;j++){
                res+=Math.min(cnt[j],base+k);
            }
            max_value=Math.max(res,max_value);
        }
        return word.length()-max_value;
    }
}
```

