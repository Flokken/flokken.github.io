---
title: 二分查找
date: 2023-10-25
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

> [详解二分查找，包括左闭右闭，左闭右开，以及其他变种问题](https://blog.csdn.net/lyx7762/article/details/128694594)
>
> [算法 | 二分查找及其变种][https://blog.csdn.net/weixin_52983138/article/details/125855641]

二分查找其实包含了很多细节，比如什么时候跳出循环，边界的变化意味着什么，数组中有重复元素怎么办，这些都需要认真考虑。

**一种是左闭右闭区间，还有一种是左闭右开区间**。我们说的这个区间，就是二分查找的区间范围。举个例子：有一个数组`arr=[1, 2, 3, 4]`，它的下标集合为[0, 1, 2, 3]。

此时如果使用左闭右闭区间搜索，那么搜索的区间为[0, arr.length-1]。如果采用左闭右开的区间，那么搜索范围是[0, arr.length]。

## 左闭右闭二分查找

在**有序**数组 $A$ 内，查找值 $target$

* 如果找到返回索引
* 如果找不到返回 $-1$

算法描述

|      |                                                              |
| ---- | ------------------------------------------------------------ |
| 前提 | 给定一个内含 $n$ 个元素的有序数组 $A$，满足 $A_{0}\leq A_{1}\leq A_{2}\leq \cdots \leq A_{n-1}$，一个待查值 $target$ |
| 1    | 设置 $i=0$，$j=n-1$                                          |
| 2    | 如果 $i \gt j$，结束查找，没找到                             |
| 3    | 设置 $m = floor(\frac {i+j}{2})$ ，$m$ 为中间索引，$floor$ 是向下取整 |
| 4    | 如果 $target < A_{m}$ 设置 $j = m - 1$，跳到第2步            |
| 5    | 如果 $A_{m} < target$ 设置 $i = m + 1$，跳到第2步            |
| 6    | 如果 $A_{m} = target$，结束查找，找到了                      |

java 实现


```java
public static int binarySearch(int[] nums, int target) {
    int i = 0, j = nums.length - 1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (nums[m]<target) {			
            i = m + 1;
        } else if (nums[m] > target) {		
            j = m - 1;
        } else {
            return m;
        }
    }
    return -1;
}

```

* $i,j$ 对应着搜索区间 $[0,a.length-1]$（注意是闭合的区间），$i<=j$ 意味着搜索区间内还有未比较的元素，**$i,j$ 指向的元素也会参与比较**
  * 思考：如果不加 $i==j$ 行不行？
  * 回答：不行，**因为这意味着 $i,j$ 相遇时指向的元素会漏掉**
  * 思考：为什么$j=m-1$?不能是$j=m$吗?（联系下面的看）
  * 回答：因为我们这个写法，$i<=j$，要求右区间是闭合的，而m已经查过了，所以只能把边界缩小到最近的$m-1$
* $m$ 对应着中间位置，中间位置左边和右边的元素可能不相等（有可能差一个，因为向下取整），不会影响结果
* 如果某次未找到，那么缩小后的区间内不包含 $m$，因为我们的右区间需要是查找的目标，而m已经查过了，再查就重复了。

## 左闭右开二分查找

另一种写法

```java
public static int binarySearch(int[] nums, int target) {
    int i = 0, j = nums.length;
    while (i < j) {
        int m = (i + j) >>> 1;
        if (nums[m]<target) {			// 在左边
            i = m +1;
        } else if (nums[m] > target) {		// 在右边
            j = m;
        } else {
            return m;
        }
    }
    return -1;
}
```

* $i,j$ 对应着搜索区间 $[0,a.length)$（注意是左闭右开的区间），$i<j$ 意味着搜索区间内还有未比较的元素，同时$j$ 指向的**一定不是**查找目标
  * 思考：为啥这次不加 $i==j$ 的条件了？
  * 回答：这回 $j$ 指向的不是查找目标，如果还加 $i==j$ 条件，就意味着 $j$ 指向的还会再次比较，找不到时，会死循环
* 如果某次要缩小右边界，那么 $j=m$，因为此时的 $m$ 已经**不是**查找目标了，
  * 思考：为什么是$j=m$，而不是$j=m-1$？
  * 回答：因为j指向的一定不是查找目标，而m肯定遇不到了，所以我们这里设为m。我们当然不能设为$m-1$,因为j是右边界，是不会遇到的，而$m-1$有可能是查找的目标。

## 变种问题

> 这些问题也可以用左闭右开的写法来做，这里先贴一下左闭右闭的搜索的办法

**求第一个大于等于target的下标（等价于求第一个等于target的下标）**

> 问题：为什么等于和大于的情况可以合在一起写？

~~~java
// 查找第一个大于等于target的下标 === 查找第一个等于target的下标
public int equalAndGreater(int[] array, int k) {
    if (array == null || array.length == 0) return -1;

    int left = 0, right = array.length - 1;

    while (left <= right) {
      int mid = (right + left) / 2;
      if (array[mid] < k) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return left;
}


//左闭右闭搜索
public int equalAndGreater(int[] array, int k) {
    if (array == null || array.length == 0) return -1;

    int left = 0, right = array.length ;

    while (left <right) {
      int mid = (right + left) / 2;
      if (array[mid] < k) {
        left = mid + 1;
      } else {
        right = mid ;
      }
    }
    return left;
}

~~~

**求第一个大于target的下标（等价于求最后一个target元素下标+1）**

```java
// 查找第一个大于target的下标-1 === target的最后下标
public int greater(int[] array, int k) {
    if (array == null || array.length == 0) return -1;
    int left = 0, right = array.length - 1;
    while (left <= right) {
      int mid = (right + left) / 2;
      if (array[mid] <= k) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return left;
}

```

**查找第一个小于target的值的下标**

```java
public int binarySearchOne() {
   int[] array = {0,1,2,3,4,5,6};
   int target = 3;
	int left = 0, right = array.length-1;
	while(left <= right) {
	    int mid = (left + right)/2;
    //只修改了判断的条件，相当于将大于等于归为一类。
		if(array[mid] >=  target)
            right = mid - 1;
		else
		     left = mid + 1;
	}
	return right;
}

```

**查找第一个小于等于target值的下标**

```java
public int binarySearchOne() {
   int[] array = {0,1,2,3,4,5,6};
   int target = 3;
	int left = 0, right = array.length-1;
	while(left <= right) {
	    int mid = (left + right)/2;
    //只修改了判断的条件，相当于将大于等于归为一类。
		if(array[mid] >  target)
            right = mid - 1;
		else
		     left = mid + 1;
	}
	return right;
}

```

**有查第一个，就有找最后一个，并且既然r可以超出界限，那么l也可以左移一位**。感觉很复杂，慢慢总结
