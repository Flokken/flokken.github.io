---
title: 二分查找
date: 2023-10-25
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 理论学习

>Update: 2024/02/07
>
>灵神基础算法精讲：[二分查找]
>
>[详解二分查找，包括左闭右闭，左闭右开，以及其他变种问题](https://blog.csdn.net/lyx7762/article/details/128694594)
>
>[算法 | 二分查找及其变种][https://blog.csdn.net/weixin_52983138/article/details/125855641]

### 左闭右闭区间

$Question:$给定一个有序数组，返回有序数组中**第一个** >=8的数的位置，如果所有数都<8，返回数组长度。

**时刻牢记**

- 注意这里求的是$>=targtet$的数，而不是找到一个等于$target$的数，这很重要，这叫做$lower\_bound$

- 这是左闭右闭区间，L和R都可以取到
- 所以L初始化为0，R是数组长度n-1
- 循环继续的条件是$R>=L$，跳出循环条件是$R<L$

![image-20240208101835568](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208101835568.png)

**红蓝染色法**

$[L,R]$左开右开区间二分查找![image-20240208102308510](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102308510.png)

下面是寻找到第一个>=8的数的过程

![image-20240208102345720](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102345720.png)

到这里之后，我们注意到下一次更新会导致$R<L$,所以要结束查找。那么此时应该返回$R+1$或者$L$(即第一个蓝色)

![image-20240208102939974](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102939974.png)



特殊情况考虑

**1.如果数组中元素都小于8会怎么样?**

这种情况下，R不会改变，L不断更新为M+1

![image-20240208115600432](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208115600432.png)

所以最后，返回的R+1或者L都是n，也就是数组长度

![image-20240208115547130](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208115547130.png)

注意：

- 循环不变量依然成立，L-1都是红色，R+1超出了界限不讨论颜色

**总结**

- 核心就是循环不变量，对于左闭右闭区间$[L,R]$
  - L-1一定是红色（不符合单调性）
  - R+1一定是蓝色（符合单调性）
- 初始化
  - $l=0,r=n-1$

- 循环条件$while(l<=r)$​
- 返回值是$left$或者$right+1$
  - 因为这里求的是$>=8$的数，$left-1$一定是红色即<8，所以这里返回$left$即一定蓝色$>=8$

- 对于二分查找，**我们要关注的是当前区间外的性质（因为已经确定）**，因为区间内还没有确定与target的关系

### 左闭右开区间

**时刻牢记**

- 这是左闭右开区间，即$[L,R)$
- 所以初始化时，如果数组长度是n，那么$L=0,R=n$而不是$n-1$
- 循环的条件应该是$L<R$

红蓝染色法

$[L,R)$左开右开区间二分查找![image-20240208144912971](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208144912971.png)

其查找更新过程如下

![image-20240208145109336](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208145109336.png)

返回答案

这里我们返回$L$或者$R$都可以

![image-20240208160713979](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208160713979.png)

**总结**

- 核心就是循环不变量，对于左闭右开区间$[L,R)$
  - L-1一定是红色（不符合单调性）
  - R一定是蓝色（符合单调性）
- 初始化
  - $l=0,r=n$​

- 返回值
  - $L$或者$R$都代表第一个蓝色即第一个$>=8$

- 循环条件$while(l<r)$

### 左开右开区间

红蓝染色法

$(L,R)$左开右开区间二分查找

![image-20240208184832064](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208184832064.png)

其查找更新过程如下

![image-20240208184944180](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208184944180.png)

返回答案

这里**图错了**，跳出循环时，应该是L+1=R，由于R一定是蓝色，所以可以返回R或者L+1

![image-20240208185200985](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208185200985.png)

总结

- 核心就是循环不变量，对于左闭右开区间$(L,R)$

  - L一定是红色

  - R一定是蓝色

- 初始化
  - $l=-1,r=n$​
  
- 返回值
  - R一定是蓝色，所以可以返回$R$或者$L+1$
  
- 循环条件$while(l+1<r)$

### 细节

- $lower\_bound(nums,x)$如果没有找到$x$，有两种情况
  - 整个数组中都$<x$，返回的是**数组长度**$nums.length$
  - 数组中没有$x$，但是有$>x$的数，此时返回来的是第一个大于$x$的位置，所以要判断返回位置的值是否为$x$​
- 循环不变量需要依据答案序列的单调性和采用了哪种区间来确定
  - 比如这里的问题，是求$>=8$的第一个数
    - 由于是升序，所有答案序列是[红色，红色，红色，，蓝色，蓝色,,,,,]
    - 如果是左闭右闭区间，更新时是当不满足条件更新$left=mid+1$，所以$left$左边都是红色，而$left$为蓝色，所以最终返回$left$

### 总结

- 二分的核心是怎么更新left和right，根据红蓝染色法和区间类型。我们每次mid进行某种判断后，已经确定的区间是什么，下一步$left$和$right$更新到不确定的区间的边界

  

### 34. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240321111428686.png" alt="image-20240321111428686" style="zoom:80%;" />

注意：

- 求$mid$时，直接$left+right/2$可能爆int
  - 所以这种写法    int mid = left+(right-left)/2;
- 注意不同区间$left$和$right$的更新

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int start = lowerBound1(nums,target);
        if(start == nums.length || nums[start] != target){
            return new int[]{-1,-1};
        }
        
        int end = lowerBound(nums,target+1)-1;//找最后一个小于等于target的数
        return new int[]{start,end};
    }
	//左闭右闭
    private int lowerBound1(int []nums,int target){
        int left =0,right=nums.length-1;//闭区间[left,right]
        while(left<=right){//区间不为空
            int mid = left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1; //已经确定[left,mid],不确定[mid+1,right]
            }else{
                right=mid-1; //已经确定[mid,right],不确定[left,mid-1]
            }
        }
        //跳出时，left=right+1,  [left,right]为空
        //return left;
        return right+1;
    }
    
   //左闭右开
    private int lowerBound1(int []nums,int target){
        int left =0,right=nums.length;//闭区间[left,right)
        while(left<right){//区间不为空
            int mid = left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1; ///已经确定[left,mid],不确定[mid+1,right)
            }else{
                right=mid; //已经确定[mid,right),不确定[left,mid)
            }
        }
        //跳出时，L=R [L,R)为空
        return left;
        //return right;
    }
    
    //左开右开
    private int lowerBound1(int []nums,int target){
        int left =-1,right=nums.length;//闭区间[left,right)
        while(left+1<right){//区间不为空
            int mid = left+(right-left)/2;
            if(nums[mid]<target){
                left=mid; //已经确定(left,mid]，不确定(mid,right)
            }else{
                right=mid; //已经确定[mid,right),不确定(left,mid)
            }
        }
        //跳出时，L+1=R,  (L,R)为空
        return right;
        //return left+1;
    }
    
}
```

### 变种问题思考

我们回顾题目

$Question:$​给定一个有序数组，返回有序数组中**第一个** >=x的数的位置，如果所有数都<x，返回数组长度。

> 注意：这个问题相当于是所有二分问题的模板，因为所有二分都能转换为这种情况的变形

这里如果不是$>=$怎么办？这里可以换成$>,<.>=,<=$这四种情况，这也是二分查找的**四种类型**

这四种类型可以**互相转换**

> 可以以[7,8,9]这数组为样例，x=8来思考

- $>$可以看成 $>=(x+1)$
  - 当然这里的前提是都是**整数**，比如我找$>8$的第一个数，其实也就是找 第一个$>=9$的数

- $<$可以看成$(>=x)-1$​，即>=x的那个数左边那个数
  - 比如$<8$，那么就是第一个$>=8$左边的那个数

- $<=$看成$(>x)-1$​​ ，
  - 首先可以转换成$>x$​的左边那个数，即$>(x)-1$
    - 比如$<=8$，那是实际上就是找第一个$>8$的左边那个数

  - $>(x)-1$又可以转换为$>=(x+1)-1$
    - 比如第一个$>8$，实际就是第一个$>=9$​​的位置


牢记细节：

$lower\_bound(nums,x)$如果没有找到$x$，有两种情况

- 整个数组中都$<x$，返回的是**数组长度**$nums.length$
- 数组中没有$x$，但是有$>x$的数，此时返回来的是第一个大于$x$的位置，所以要判断返回位置的值是否为$x$

> 2024.3.22

下面以数组$[1,2,4,6,6,7,8,8,9]$来模拟各种情况

- 求第一个等于8的位置，等同于第一个$>=8$的位置，那么就是$lower\_bound(8)$即可，注意**判断返回值**
- 求最后一个等于8的位置，等同于最后一个$<=8$，其实就是找第一个$>8$也就是第一个$>=9$的位置的**左边第一个数**，那么就是$lower\_bound(8+1)-1$，同样注意返回值
  - 注意都是整数才可以这么干

> $Question:最后一个$$>=x$和第一个$<=x$好像求不了？



### 例题 

#### 2529. 正整数和负整数的最大计数

[2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

![image-20240322150316968](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322150316968.png)

思路：

- 使用二分优化时间复杂度
- 数组长度-1  减去 求第一个>0的数的下标就是正整数个数
  - 注意考虑返回值为数组长度，那么所有数都是负数
  - 以及是不是0的情况（这道题无所谓）
- 求第一个$>=0$​的数的下标  -0就是负数个数

```java
class Solution {
    public int maximumCount(int[] nums) {
        int n=nums.length;
        int x= lower_bound(nums,0);
        if(x==n){//全是负数
            return n;
        }
        int y=lower_bound(nums,1);
        //考虑特殊情况，如果数组只有负数和0，那么y==n
        //此时正数个数为n-n=0,那么仍然正确
        y=n-y;
        return Math.max(x,y);
    }
    public int lower_bound(int [] nums, int x){
        int n=nums.length;
        int left =0,right=n;
        while(left<right){
            int mid = left+(right-left)/2;
            if(nums[mid]<x){
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return left;
    }
}
```

#### 2300. 咒语和药水的成功对数

[2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

![image-20240322152601564](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322152601564.png)

思路：

- 由于都是正整数，所以我们可以对药水进行排序，如果$spell[i]*nums[i]>=success$，那么剩下的都肯定符合
  - 注意上限是$10^{10}$，也就是一百亿，会爆int

```java
class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        int m=spells.length;
        int n=potions.length;
        int []ans =new int[m];
        Arrays.sort(potions);
        for(int i=0;i<m;i++){
            int p = lower_bound(potions,success,spells[i]);
            p=n-p;//代入特殊值，比如最后一个数n-1,那么p=1，所以这里不用减1
            ans[i]=p;
        }
        return ans;
    }
    public int lower_bound(int[] nums,long x,int sp){
        int n = nums.length;
        int left =0,right = n;
        while(left<right){
            int mid = left+(right-left)/2;
            if((long)nums[mid]*(long)sp<x){
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return left;
    }
}
```

#### 162.寻找峰值

[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240326220152696.png" alt="image-20240326220152696" style="zoom:80%;" />

- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

思路：

如果暴力的做，可以直接遍历一遍，判断$nums[i]$和其左右相邻数字的大小关系来确定$num[i]$​是否是峰顶

二分的做法可以达到$O(logn)$​的复杂度

二分的关键在于**红蓝染色法**

![image-20240326220415372](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240326220415372.png)

> Question:为什么这不是有序数组，可以二分
>
> A：因为我们要找的封顶具有单调性，峰顶左边的元素一定小于$nums[i]$，峰顶右边的元素一定大于$nums[i]$​。所以可以比较当前认为可能是峰顶的元素来判断怎么染色，这里感觉更像是**二分答案**

注意红蓝色的定义

- 红色：目标峰顶左侧
- 蓝色：目标峰顶右侧

根据上面的分析，我们判断第$n$个元素一定是蓝色，所以不确定，也就是还需要二分的范围是$[0,n-1]$​

如何更新下一步（相当于check（））？

- **判断M和M+1指向的元素**

left和right如何更新？

1. right 左移使右侧变蓝 (判断条件为 true )
2. left 右移使左侧变红 (判断条件为 false )
3. 故确定二分处 ( mid ) 的染色条件是关键（也就是check（））

![image-20240326220546702](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240326220546702.png)

所以这里的循环不变量,（上面图是闭区间）

- L-1一定是红色
- R+1一定是蓝色

开区间实现代码

> 上面讨论过，二分区间是[0,n-2]

(-1,n-1)

如果是开区间，那么

- L一定是红色
- R一定是蓝色

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left =-1;
        int n=nums.length;
        int right =n-1;
        while(left+1<right){
            int mid = left+(right-left)/2;
            if(nums[mid]<nums[mid+1]){
                left=mid;
            }else{
                right=mid;
            }
        }
        return right;
    }
}
```

左闭右开区间写法

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left =0;
        int n=nums.length;
        int right =n-1;//
        while(left<right){
            int mid = left+(right-left)/2;
            if(nums[mid]<nums[mid+1]){
                left=mid+1;//已经确定区间[left,mid],下面不确定区间[mid+1,right)
            }else{
                right=mid;//下面不确定区间，
            }
        }
        return right;
    }
}
```

#### 153. 寻找旋转排序数组中的最小值

[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240326225158242.png" alt="image-20240326225158242" style="zoom:80%;" />

同样的思路，红蓝染色法。

对于最小值的左右侧进行分类讨论，然后判断染色

> 这里是分类讨论得出结论的。
>
> 首先题目是有序数组，
>
> - 那么一定最小值左边是升序（或者没有）
> - 最小值右边是降序（或者没有）
>
> 举例：原本数组$[0,1,2,3,4,5]$，只可能以下几种情况
>
> [4,5,0,1,2,3]   最小值在中间
>
> [1,2,3,4,5,0]  最小值在右端点
>
> [0,1,2,3,4,5]  最小值在左端点
>
> 

- 最小值左侧染成红色

- 最小值及右侧染成蓝色

n-1必定是蓝色

更新条件check（）怎么写？

- 根据上面的分析，我们可以利用$nums[n-1]$和$nums[mid]$比较
  - 如果$nums[n-1]>nums[mid]$，说明是在最小值左边的序列
  - 否则是最小值或者最小值右边的序列

![image-20240326225342188](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240326225342188.png)

仍然是开区间写法

```java
class Solution {
    public int findMin(int[] nums) {
        int n=nums.length;
        int left=-1;
        int right = n-1;
        while(left+1<right){
            int mid = left+(right-left)/2;
            if(nums[mid]<nums[n-1]){//染成蓝色
                right=mid;
            }else{
                left=mid;
            }
        }
        return nums[right];
    }
}
```



## 总结

首先要注意一些题目关键字

- 非递减：其实就是每个数都$>=$上一个数
- 求$==$问题就可以转化为求第一个$>=$问题或者$<=$问题



还有数据上下限

- $10^{10}$是一百亿，$10^{9}$是十亿
- $10^{5}$是十万， $10^{4}$是一万

