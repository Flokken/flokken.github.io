---
title: 二分查找
date: 2023-10-25
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 理论学习

>Update: 2024/02/07
>
>灵神基础算法精讲：[二分查找]
>
>[详解二分查找，包括左闭右闭，左闭右开，以及其他变种问题](https://blog.csdn.net/lyx7762/article/details/128694594)
>
>[算法 | 二分查找及其变种][https://blog.csdn.net/weixin_52983138/article/details/125855641]

### 左闭右闭区间

$Question:$给定一个有序数组，返回有序数组中**第一个** >=8的数的位置，如果所有数都<8，返回数组长度。

**时刻牢记**

- 注意这里求的是$>=targtet$的数，而不是找到一个等于$target$的数，这很重要，这叫做$lower\_bound$

- 这是左闭右闭区间，L和R都可以取到
- 所以L初始化为0，R是数组长度n-1
- 循环继续的条件是$R>=L$，跳出循环条件是$R<L$

![image-20240208101835568](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208101835568.png)

**红蓝染色法**

$[L,R]$左开右开区间二分查找![image-20240208102308510](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102308510.png)

下面是寻找到第一个>=8的数的过程

![image-20240208102345720](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102345720.png)

到这里之后，我们注意到下一次更新会导致$R<L$,所以要结束查找。那么此时应该返回$R+1$或者$L$(即第一个蓝色)

![image-20240208102939974](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102939974.png)



特殊情况考虑

**1.如果数组中元素都小于8会怎么样?**

这种情况下，R不会改变，L不断更新为M+1

![image-20240208115600432](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208115600432.png)

所以最后，返回的R+1或者L都是n，也就是数组长度

![image-20240208115547130](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208115547130.png)

注意：

- 循环不变量依然成立，L-1都是红色，R+1超出了界限不讨论颜色

**总结**

- 核心就是循环不变量，对于左闭右闭区间$[L,R]$
  - L-1一定是红色（不符合单调性）
  - R+1一定是蓝色（符合单调性）
- 初始化
  - $l=0,r=n-1$

- 循环条件$while(l<=r)$​
- 返回值是$left$或者$right+1$
  - 因为这里求的是$>=8$的数，$left-1$一定是红色即<8，所以这里返回$left$即一定蓝色$>=8$

- 对于二分查找，**我们要关注的是当前区间外的性质（因为已经确定）**，因为区间内还没有确定与target的关系

### 左闭右开区间

**时刻牢记**

- 这是左闭右开区间，即$[L,R)$
- 所以初始化时，如果数组长度是n，那么$L=0,R=n$而不是$n-1$
- 循环的条件应该是$L<R$

红蓝染色法

$[L,R)$左开右开区间二分查找![image-20240208144912971](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208144912971.png)

其查找更新过程如下

![image-20240208145109336](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208145109336.png)

返回答案

这里我们返回$L$或者$R$都可以

![image-20240208160713979](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208160713979.png)

**总结**

- 核心就是循环不变量，对于左闭右开区间$[L,R)$
  - L-1一定是红色（不符合单调性）
  - R一定是蓝色（符合单调性）
- 初始化
  - $l=0,r=n$​

- 返回值
  - $L$或者$R$都代表第一个蓝色即第一个$>=8$

- 循环条件$while(l<r)$

### 左开右开区间

红蓝染色法

$(L,R)$左开右开区间二分查找

![image-20240208184832064](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208184832064.png)

其查找更新过程如下

![image-20240208184944180](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208184944180.png)

返回答案

这里**图错了**，跳出循环时，应该是L+1=R，由于R一定是蓝色，所以可以返回R或者L+1

![image-20240208185200985](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208185200985.png)

总结

- 核心就是循环不变量，对于左闭右开区间$(L,R)$

  - L一定是红色

  - R一定是蓝色

- 初始化
  - $l=-1,r=n$​
  
- 返回值
  - R一定是蓝色，所以可以返回$R$或者$L+1$
  
- 循环条件$while(l+1<r)$

### 细节

- $lower\_bound(nums,x)$如果没有找到$x$，有两种情况
  - 整个数组中都$<x$，返回的是**数组长度**$nums.length$
  - 数组中没有$x$，但是有$>x$的数，此时返回来的是第一个大于$x$的位置，所以要判断返回位置的值是否为$x$

### 变种问题思考

我们回顾题目

$Question:$​给定一个有序数组，返回有序数组中**第一个** >=x的数的位置，如果所有数都<x，返回数组长度。

> 注意：这个问题相当于是所有二分问题的模板，因为所有二分都能转换为这种情况的变形

这里如果不是$>=$怎么办？这里可以换成$>,<.>=,<=$这四种情况，这也是二分查找的**四种类型**

这四种类型可以**互相转换**

> 可以以[7,8,9]这数组为样例，x=8来思考

- $>$可以看成 $>=(x+1)$
  - 当然这里的前提是都是**整数**，比如我找$>8$的第一个数，其实也就是找 第一个$>=9$的数

- $<$可以看成$(>=x)-1$​，即>=x的那个数左边那个数
  - 比如$<8$，那么就是第一个$>=8$左边的那个数

- $<=$看成$(>x)-1$​​ ，
  - 首先可以转换成$>x$​的左边那个数，即$>(x)-1$
    - 比如$<=8$，那是实际上就是找第一个$>8$的左边那个数

  - $>(x)-1$又可以转换为$>=(x+1)-1$
    - 比如第一个$>8$，实际就是第一个$>=9$​​的位置


牢记细节：

$lower\_bound(nums,x)$如果没有找到$x$，有两种情况

- 整个数组中都$<x$，返回的是**数组长度**$nums.length$
- 数组中没有$x$，但是有$>x$的数，此时返回来的是第一个大于$x$的位置，所以要判断返回位置的值是否为$x$

> 2024.3.22

下面以数组$[1,2,4,6,6,7,8,8,9]$来模拟各种情况

- 求第一个等于8的位置，等同于第一个$>=8$的位置，那么就是$lower\_bound(8)$即可，注意**判断返回值**
- 求最后一个等于8的位置，等同于最后一个$<=8$，其实就是找第一个$>8$也就是第一个$>=9$的位置的**左边第一个数**，那么就是$lower\_bound(8+1)-1$，同样注意返回值
  - 注意都是整数才可以这么干

> $Question:最后一个$$>=x$和第一个$<=x$好像求不了？



### 例题 

#### 34. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240321111428686.png" alt="image-20240321111428686" style="zoom:80%;" />

注意：

- 求$mid$时，直接$left+right/2$可能爆int
  - 所以这种写法    int mid = left+(right-left)/2;

**左闭右闭**


```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int start = lowerBound1(nums,target);
        if(start == nums.length || nums[start] != target){
            return new int[]{-1,-1};
        }
        
        int end = lowerBound(nums,target+1)-1;//找最后一个小于等于target的数
        return new int[]{start,end};
    }
	//左闭右闭
    private int lowerBound1(int []nums,int target){
        int left =0,right=nums.length-1;//闭区间[left,right]
        while(left<=right){//区间不为空
            int mid = left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1; //[mid+1,right]
            }else{
                right=mid-1; //[left,mid-1]
            }
        }
        //跳出时，left=right+1,  [left,right]为空
        //return left;
        return right+1;
    }
    
   //左闭右开
    private int lowerBound1(int []nums,int target){
        int left =0,right=nums.length;//闭区间[left,right)
        while(left<right){//区间不为空
            int mid = left+(right-left)/2;
            if(nums[mid]<target){//已经确定，所以更新下一个查找区间
                left=mid+1; //[mid+1,right)
            }else{
                right=mid; //[left,mid)
            }
        }
        //跳出时，L=R [L,R)为空
        return left;
        //return right;
    }
    
    //左开右开
    private int lowerBound1(int []nums,int target){
        int left =-1,right=nums.length;//闭区间[left,right)
        while(left+1<right){//区间不为空
            int mid = left+(right-left)/2;
            if(nums[mid]<target){
                left=mid; //(mid,right)
            }else{
                right=mid; //(left,mid)
            }
        }
        //跳出时，L+1=R,  (L,R)为空
        return right;
        //return left+1;
    }
    
}
```

#### 2529. 正整数和负整数的最大计数

[2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

![image-20240322150316968](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322150316968.png)

思路：

- 使用二分优化时间复杂度
- 数组长度-1  减去 求第一个>0的数的下标就是正整数个数
  - 注意考虑返回值为数组长度，那么所有数都是负数
  - 以及是不是0的情况（这道题无所谓）
- 求第一个$>=0$​的数的下标  -0就是负数个数

```java
class Solution {
    public int maximumCount(int[] nums) {
        int n=nums.length;
        int x= lower_bound(nums,0);
        if(x==n){//全是负数
            return n;
        }
        int y=lower_bound(nums,1);
        //考虑特殊情况，如果数组只有负数和0，那么y==n
        //此时正数个数为n-n=0,那么仍然正确
        y=n-y;
        return Math.max(x,y);
    }
    public int lower_bound(int [] nums, int x){
        int n=nums.length;
        int left =0,right=n;
        while(left<right){
            int mid = left+(right-left)/2;
            if(nums[mid]<x){
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return left;
    }
}
```

#### 2300. 咒语和药水的成功对数

[2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

![image-20240322152601564](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322152601564.png)

思路：

- 由于都是正整数，所以我们可以对药水进行排序，如果$spell[i]*nums[i]>=success$，那么剩下的都肯定符合
  - 注意上限是$10^{10}$，也就是一百亿，会爆int

```java
class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        int m=spells.length;
        int n=potions.length;
        int []ans =new int[m];
        Arrays.sort(potions);
        for(int i=0;i<m;i++){
            int p = lower_bound(potions,success,spells[i]);
            p=n-p;//代入特殊值，比如最后一个数n-1,那么p=1，所以这里不用减1
            ans[i]=p;
        }
        return ans;
    }
    public int lower_bound(int[] nums,long x,int sp){
        int n = nums.length;
        int left =0,right = n;
        while(left<right){
            int mid = left+(right-left)/2;
            if((long)nums[mid]*(long)sp<x){
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return left;
    }
}
```

#### 275. H 指数 II

[275. H 指数 II](https://leetcode.cn/problems/h-index-ii/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322154507116.png" alt="image-20240322154507116" style="zoom:80%;" />

思路：

- 根据题意，如果h指数是$citation[i]$，那么也要有$citiations[i]$篇论文被引用。并且h取最大的那个

这道题是二分答案，所以参考灵神题解:https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/

![image-20240322160829894](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322160829894.png)

![1111](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322161954172.png)

单调性：

- 对于第$i$篇的论文是否有引用次数$>=i$​​的论文？

初始化

- 答案的区间是$[0,n]$即0到n篇论文，注意含义是篇数而不是二分查找的下标
- 优化（边界）：非常重要！
  - 由于0代表0篇论文引用数>=0,所以肯定成立，所有把区间改成$[1,n]$​
  - 因为这样做可以避免**$mid==0,nums[n-mid]$越界**

注意

- 由于数组有序，所以$citiation[n-i]>=i$​可以判断是否满足单调性
- 二分的区间不一定包括答案（就像二分查找不一定包括target），所以这里如果最后`right=0`，说明没有符合要求的指数
- 返回值：
  - 最后返回的是$right$

```java
class Solution {
    public int hIndex(int[] citations) {
        int n=citations.length;
        int left=1;
        int right=n;//左闭右闭区间，所以也用这个二分
        while(left<=right){
            int mid =left+(right-left)/2;
            if(citations[n-mid]>=mid){//满足单调性，染为红色
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        // 循环结束后 right 等于 left-1，回答一定为「是」
        // 根据循环不变量，right 现在是最大的回答为「是」的数
        return left-1;
    }
}
```

思考：

如果非要写成$[0,n]$，那么需要特判$mid==0$的情况

```java
class Solution {
    public int hIndex(int[] citations) {
        int n=citations.length;
        int left=0;
        int right=n;//左闭右闭区间，所以也用这个二分
        while(left<=right){
            int mid =left+(right-left)/2;
            if(mid==0){
                left=mid+1;//0位置一定成立，染成蓝色，然后更新范围
            }
            else if(citations[n-mid]>=mid){//满足单调性，染为红色
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        // 循环结束后 right 等于 left-1，回答一定为「是」
        // 根据循环不变量，right 现在是最大的回答为「是」的数
        return left-1;
    }
}
```

#### 2187. 完成旅途的最少时间

[2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240322170629176.png" alt="image-20240322170629176" style="zoom:80%;" />

> 灵神答案：https://leetcode.cn/problems/minimum-time-to-complete-trips/solutions/1295955/er-fen-da-an-python-yi-xing-gao-ding-by-xwvs8/

思路：

- 二分答案。

单调性 ：

- 对于当前时刻$t$，我们能完成的次数是$\sum_0^nint(x/time[i])$。我们用这个次数跟$total$比较是否能完成。
  - 必然是一开始不满足，到某一个时间点满足，后面就都满足，这就是这里的单调性。
  - 左边红色，右边蓝色，寻找第一个蓝色

边界：

- 假设最快的车速度是$t$，那么答案不可能花费时间比$t*total$的时间更长，可以用这个当**上界**
  - 这是显然的，假设time=[1,2,3]，只跑最快的车，需要5,但是由于我们还有其他车，所以3时就满足了
- 我们不知道下界是多少，由于题目t>=1，所以可以设下界为0

所以现在的枚举区间是$(0,t*total+1)$

**左开右开区间**

```java
class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        int n=time.length;
        Arrays.sort(time);
        long right = (long)time[0]*(long)totalTrips+1L;
        long left =0;
        while(left+1<right){
            long mid = left+(right-left)/2;
            if(getSum(mid,time)<(long)totalTrips){
                left=mid;
            }else{
                right=mid;
            }
        }
        return right;
    }

    public long getSum(long x, int []times){
        long sum = 0;
        for(var time:times){
            sum+=(long)x/(long)time;
        }
        return sum;
    }
}
```

也可以是左闭右闭区间

我们取$left=1,right=t*total$，枚举区间即$[1,t*total]$

```java
class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        int n=time.length;
        Arrays.sort(time);
        long right = (long)time[0]*(long)totalTrips;
        long left =1;
        while(left<=right){
            long mid = left+(right-left)/2;
            if(getSum(mid,time)<(long)totalTrips){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return left;
    }

    public long getSum(long x, int []times){
        long sum = 0;
        for(var time:times){
            sum+=(long)x/(long)time;
        }
        return sum;
    }
}
```

当然还可以是左闭右开区间即$[1,t*total+1)$

```java
class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        int n=time.length;
        Arrays.sort(time);
        long right = (long)time[0]*(long)totalTrips+1;
        long left =1;
        while(left<right){
            long mid = left+(right-left)/2;
            if(getSum(mid,time)<(long)totalTrips){
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return left;
    }

    public long getSum(long x, int []times){
        long sum = 0;
        for(var time:times){
            sum+=(long)x/(long)time;
        }
        return sum;
    }
}
```

#### 2861. 最大合金数

[2861. 最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240323195822020.png" alt="image-20240323195822020" style="zoom:80%;" />

题意：选出一台机子，在不超过预算的情况下，获得最大的合金数

> leetcode上的题，就算强调下标从一开始，好像也没什么区别，只是这么说而已

**思路**

二分答案

> Question：为什么不是背包问题？感觉有点像
>
> Answer：这里有k个机器都可以造合金，放到背包问题里就相当于有k个背包，这显然就不是背包问题了。

**挨个判断**每台机器最多可以制造多少份合金。

**单调性**：

- 假如要制造$num$份合金，那么$num$越小，花费越少，$num$越多，花费也越多
  - 所以这里其实就是找在第一个>=target(budget)时的num

**注意**

题目是有初始值的，对于第$j$类金属：

- 如果$compostion[i][j]*num<=stock[j]$，那么无需购买
- 如果$composition[i][j]*num>stock[j]$，需要购买，并且花费为
  - $(composition[i][j]*num-stock[j])*cost[j]$$

题目对于花费也有限制$budget$

- 如果花费超过$budget$，则无法制造$num$份合金，否则可以

**上下界**

- 二分上界：假设所有的$composition[i][j]$和$cost$都是1，那么此时最多可以制造的合金数是$min(stock)+budget$
  - 其实枚举上界就是找最好想的情况来估算一下二分的上界，
  - 这个上界是有可能取到的
- 二分下界：可以直接设为1，代表一份合金
  - 这里更好的办法是，假设当前答案是$ans$，那么设下界为$ans+1$，因为我们求的是能获取合金数最大值，如果当前机器达到的最大值小于等于$ans$，求出来也没有意义

**返回值**

这里以开区间为例

- 因为答案序列一定是一开始满足，后面不满足（即大于budget），
- 当$check$成立是，区间更改为(mid,right),  即left=mid，此时$[left$已经是确定了，为**蓝色**
- 所以$left$所在为蓝色，$(left$即$left+1$为**红色**

**更新答案**

- 如果二分中没有答案f符合条件（大于ans）的，这里会直接返回了$left$，所以这里可以是$ans=left$,而不必是$ans=Math.max(ans.left)$

代码

开区间写法

> 上下j界都能取到，所以要上界+1,下界-1

```java
// 全部转成 int[] 数组，效率比 List<Integer> 更高
class Solution {
    public int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> Stock, List<Integer> Cost) {
        int ans=0;
        int[] stock =Stock.stream().mapToInt(i->i).toArray();
        int[]cost =Cost.stream().mapToInt(i->i).toArray();
        int mx=Collections.min(Stock)+budget;
        for(int i=0;i<k;i++){
            int []comp = composition.get(i).stream().mapToInt(j->j).toArray();

            int left = ans;//开区间，闭区间应该设为ans+1
            int right=mx+1;
            while(left+1<right){
                int mid = left+(right-left)/2;
                boolean ok=true;//记录当前是否满足单调性
                long sum=0;
                for(int j=0;j<comp.length;j++){
                    long tmp=((long)comp[j]*(long)mid-(long)stock[j])*(long)cost[j];
                    sum+=tmp>0?tmp:0;
                    if(sum>budget){
                        ok=false;
                        break;
                    }
                }
                if(ok){
                    left=mid;
                }else{
                    right=mid;
                }
            }
            ans=left;   
        }
        return ans;
    }
}

```

左闭右开写法

注意循环不变量到底是什么？
```java
// 全部转成 int[] 数组，效率比 List<Integer> 更高
class Solution {
    public int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> Stock, List<Integer> Cost) {
        int ans=0;
        int[] stock =Stock.stream().mapToInt(i->i).toArray();
        int[]cost =Cost.stream().mapToInt(i->i).toArray();
        int mx=Collections.min(Stock)+budget;
        for(int i=0;i<k;i++){
            int []comp = composition.get(i).stream().mapToInt(j->j).toArray();

            int left = ans+1;//闭区间应该设为ans+1
            int right=mx+1;
            while(left<right){
                int mid = left+(right-left)/2;
                boolean ok=true;//记录当前是否满足单调性
                long sum=0;
                for(int j=0;j<comp.length;j++){
                    long tmp=((long)comp[j]*(long)mid-(long)stock[j])*(long)cost[j];
                    sum+=tmp>0?tmp:0;
                    if(sum>budget){
                        ok=false;
                        break;
                    }
                }
                if(ok){
                    left=mid+1;
                }else{
                    right=mid;
                }
            }
            ans=left-1;//注意返回值
        }
        return ans;
    }
}

```





## 总结

首先要注意一些题目关键字

- 非递减：其实就是每个数都$>=$上一个数
- 求$==$问题就可以转化为求第一个$>=$问题或者$<=$问题



还有数据上下限

- $10^{10}$是一百亿，$10^{9}$是十亿
- $10^{5}$是十万， $10^{4}$是一万

