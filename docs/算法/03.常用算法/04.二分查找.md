---
title: 二分查找
date: 2023-10-25
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 理论学习

>Update: 2024/02/07
>
>灵神基础算法精讲：[二分查找]
>
>[详解二分查找，包括左闭右闭，左闭右开，以及其他变种问题](https://blog.csdn.net/lyx7762/article/details/128694594)
>
>[算法 | 二分查找及其变种][https://blog.csdn.net/weixin_52983138/article/details/125855641]

### 左闭右闭区间

$Question:$给定一个有序数组，返回有序数组中第一个 >=8的数的位置，如果所有数都<8，返回数组长度。

*e时刻牢记**

- 这是左闭右闭区间，L和R都可以取到
- 所以L初始化为0，R是数组长度n-1
- 循环继续的条件是$R>=L$，跳出循环条件是$R<L$

![image-20240208101835568](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208101835568.png)

#### **红蓝染色法**

$[L,R]$左开右开区间二分查找![image-20240208102308510](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102308510.png)

下面是寻找到第一个>=8的数的过程

![image-20240208102345720](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102345720.png)

到这里之后，我们注意到下一次更新会导致$R<L$,所以要结束查找。那么此时应该返回$R+1$或者$L$

![image-20240208102939974](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208102939974.png)



#### 特殊情况考虑

**1.如果数组中元素都小于8会怎么样?**

这种情况下，R不会改变，L不断更新为M+1

![image-20240208115600432](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208115600432.png)

所以最后，返回的R+1或者L都是n，也就是数组长度

![image-20240208115547130](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208115547130.png)

注意：

- 循环不变量依然成立，L-1都是红色，R+1超出了界限不讨论颜色

#### 总结

- 核心就是循环不变量，对于左闭右闭区间$[L,R]$
  - L-1一定是红色
  - R+1一定是蓝色
- 循环条件$while(l<=r)$
- 对于二分查找，**我们要关注的是当前区间外的性质（因为已经确定）**，因为区间内还没有确定与target的关系

### 左闭右开区间

**时刻牢记**

- 这是左闭右开区间，即$[L,R)$
- 所以初始化时，如果数组长度是n，那么$L=0,R=n$而不是$n-1$
- 循环的条件应该是$L<R$

#### 红蓝染色法

$[L,R)$左开右开区间二分查找![image-20240208144912971](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208144912971.png)

其查找更新过程如下

![image-20240208145109336](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208145109336.png)

返回答案

这里我们返回$L$或者$R$都可以

![image-20240208160713979](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208160713979.png)

#### 总结

- 核心就是循环不变量，对于左闭右开区间$[L,R)$
  - L-1一定是红色
  - R一定是蓝色
- 循环条件$while(l<r)$

### 左开右开区间

#### 红蓝染色法

$(L,R)$左开右开区间二分查找

![image-20240208184832064](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208184832064.png)

其查找更新过程如下

![image-20240208184944180](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208184944180.png)

返回答案

这里返回$L$或者$R$都可以

![image-20240208185200985](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240208185200985.png)

#### 总结

- 核心就是循环不变量，对于左闭右开区间$(L,R)$

  - L一定是红色

  - R一定是蓝色

- 循环条件$while(l<r)$

### 变种问题

我们回顾题目

$Question:$给定一个有序数组，返回有序数组中第一个 >=8的数的位置，如果所有数都<8，返回数组长度。

> 根据红蓝染色法，我们可以求得第一个>=8的位置，但是最后一个$>=8$的位置应该是不能通过二分得到?

这里的>=，也可以换成>,<,<=。也就是转换为下面几个问题。**二分查找其实也就分为这四种类型，并且互相可以转换:**

- 给定一个有序数组，**返回有序数组中第一个 $>=x$的数的位置**，如果所有数都<x，返回数组长度。
  - **等同于求第一个等于x数的下标**

- 给定一个有序数组，**返回有序数组中最后一个$ <=x$的数的位置**，如果所有数都$>x$，返回数组长度。
  - 转换为求第一个$>x$的数的**左边那个数，也就是求出的下标再减一**
    - 然后$>x$继续转换为求第一个$>=x+1$的数
    - 总的来说就是找到第一个$>=x+1$的数的下标，然后再减一，就是最后一个$<=x$的数
  - **等同于求最后一个等于x的数的下标**
- 给定一个有序数组，**返回有序数组中最后一个 $<x$的数的位置**，如果所有数都$>=x$，返回数组长度。
  - 转换为求第一个$>=x$的**左边那个数，也就是求出的下标再减一**
- 给定一个有序数组，**返回有序数组中第一个$ >x$的数的位置**，如果所有数都$<=x$，返回数组长度。
  - 转换为求第一个$>=x+1$的数的位置(整数)

### 例题 

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)


```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int start = lowerBound(nums,target);
        if(start == nums.length || nums[start] != target){
            return new int[]{-1,-1};
        }
        //如果start存在，那么end比如存在
        int end = lowerBound(nums,target+1)-1;//找最后一个小于等于target的数
        return new int[]{start,end};
    }
    //找到第一个大于等于target的数
    private int lowerBound(int []nums,int target){
        int left =0,right=nums.length-1;//闭区间[left,right]
        while(left<=right){
            //循环不变量
            //L-1,R+1
            int mid = left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        //return left;
        return right+1;
    }
}
```

111

```java
public static int binarySearch(int[] nums, int target) {
    int i = 0, j = nums.length;
    while (i < j) {
        int m = (i + j) >>> 1;
        if (nums[m]<target) {			// 在左边
            i = m +1;
        } else if (nums[m] > target) {		// 在右边
            j = m;
        } else {
            return m;
        }
    }
    return -1;
}
```



## 二分查找变种问题

> 这些问题也可以用左闭右开的写法来做，这里先贴一下左闭右闭的搜索的办法
>
> 二分查找变种很多，要写对不容易，唉！
>
> [参考](https://blog.csdn.net/melonyzzZ/article/details/128599307)

### **求第一个大于等于target的下标）**

>等价于求第一个等于target的下标

> 问题：为什么等于和大于的情况可以合在一起写？

~~~java
// 查找第一个大于等于target的下标 === 查找第一个等于target的下标
//其实这种把==和>写一起的写法不好理解，在相等的时候用一个ans记录答案会更好写，也更好懂！！！这里之后有时间一定要改！
public int equalAndGreater(int[] array, int k) {
    if (array == null || array.length == 0) return -1;

    int left = 0, right = array.length - 1;

    while (left <= right) {
      int mid = (right + left) / 2;
      if (array[mid] < k) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return left;
}


//左闭右闭搜索
public int equalAndGreater(int[] array, int k) {
    if (array == null || array.length == 0) return -1;

    int left = 0, right = array.length ;

    while (left <right) {
      int mid = (right + left) / 2;
      if (array[mid] < k) {
        left = mid + 1;
      } else {
        right = mid ;
      }
    }
    return left;
}

~~~

### **求第一个大于target的下标**

>等价于求最后一个target元素下标+1

```java
// 查找第一个大于target的下标-1 === target的最后下标
public int greater(int[] array, int k) {
    if (array == null || array.length == 0) return -1;
    int left = 0, right = array.length - 1;
    while (left <= right) {
      int mid = (right + left) / 2;
      if (array[mid] <= k) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return left;
}

```

### **查找第一个小于target的值的下标**

```java
public int binarySearchOne() {
   int[] array = {0,1,2,3,4,5,6};
   int target = 3;
	int left = 0, right = array.length-1;
	while(left <= right) {
	    int mid = (left + right)/2;
    //只修改了判断的条件，相当于将大于等于归为一类。
		if(array[mid] >=  target)
            right = mid - 1;
		else
		     left = mid + 1;
	}
	return right;
}

```

### **查找第一个小于等于target值的下标**

```java
public int binarySearchOne() {
   int[] array = {0,1,2,3,4,5,6};
   int target = 3;
	int left = 0, right = array.length-1;
	while(left <= right) {
	    int mid = (left + right)/2;
    //只修改了判断的条件，相当于将大于等于归为一类。
		if(array[mid] >  target)
            right = mid - 1;
		else
		     left = mid + 1;
	}
	return right;
}

```

### **查找最后一个小于等于target的值的下标**

```java

int lastLE(int arr[], int size, int target)  // LE：Less than or Equal to
{
	int left = 0;
	int right = size - 1;
	while (left <= right)
	{
		int mid = (left + right) / 2;
		if (arr[mid] <= target)
		{
			left = mid + 1;
		}
		else  // arr[right] > target
		{
			right = mid - 1;
		}
	}
	return right;

```

> 过程模拟，假设我有1 2 3 4 5 6 7 ，index[0,6],查找4.
>
> 那么我第一次mid=3，arr[mid]=4=tar。但是这时候不会跳出，l=mid+1=5,   r=6.
>
> 继续执行， mid=(5+6)/2=5， 那么arr[mid]>target（肯定的，因为是升序并且无重复），l=5，r=mid-1=4，
>
> 最后我们返回r，的确是最后一个小于等于target的数字。
>
> 再来一个特殊一点的（有重复），假设1 2 3 4 4 4 4, ，查找最后一个小于等于4的索引。
>
> 第一次执行，mid3  ,arr[mid]=4=tar,  不会跳出，继续执行，  l=mid+1=5,r=6;
>
> 然后，mid=(5+6)/2=5,  arr[mid]=4=target,  l=mid+1=6,  r=6,
>
> 继续，mid=(6+6)/2=6, arr[mid]= 4 =target, l =mid+1=7, r=6;
>
> 发现l>r,跳出，返回r=6，r的确也是最后一个小于等于target的索引			
>
> 

**有查第一个，就有找最后一个，并且既然r可以超出界限，那么l也可以左移一位**。感觉很复杂，慢慢总结
