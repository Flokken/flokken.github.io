---
title: 动态规划
date: 2023-09-08
tags: 
  - STL
categories:  
  - 算法
  - 常用算法
---

> 参考：[hellogo-算法](https://github.com/krahets/hello-algo)
>
> ##### 先搬砖书里的内容，以后再看着补充

## 初识动规

「动态规划 dynamic programming」是一个重要的算法思想，**它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。**

下面用爬梯子为例，先给出它的**暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法。**

Q:给定一个共有 3阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908173546222.png" style="zoom:100%">

对于求解方法数量，首先想到肯定就是暴力穷举，或者回溯（递归）来遍历每一种方法

这里可以很显然的想到一种解法：

**拍脑门的想法**

**将爬楼梯想象为一个多轮选择的过程：从地面出发，每轮选择上 1 阶或 2 阶，每当到达楼梯顶部时就将方案数量加 1 ，当越过楼梯顶部时就将其剪枝。**

~~~C++
//回溯(暴力穷举)来直接解这个问题
void search(vector<int> &choice, int state, int n, int&ans){
    if(state==n){
        ans+=1;
        //递归终止
        return;
    }
    for(auto x:choice){
        //剪枝
        if(state+x>n)
            break;
        search(choice,state+x,n,ans);
    }
}
int main() {
    int n=0;
    cin>>n;
    vector<int>choice={1,2};
    //爬到第几楼
    int state = 0;
    //方法数量
    int ans=0;
    search(choice,state,n,ans);
    cout<<ans;

}
~~~

上面其实并没有**分解这个问题**，而是去试探和穷举以及剪枝来解决这个问题。

**1.暴力搜索(dfs)**

当然，应该要从分解的角度去看一下这个问题。设爬到第 $i$阶共有$dp[i]$ 种方案，那么 $dp[i]$就是原问题，其子问题包括:

$dp[i-1],dp[i-2],...,dp[2],dp[1]$

并且由于每次只能上一阶或者两阶，那么显然：**爬到$i-1$阶的方案加上爬到$i-2$的方案数就等于爬到第$i$阶的方案数**。

$dp[i]=dp[i-1]+dp[i-2]$

意味着在爬楼梯问题中，各个子问题之间存在递推关系，**原问题的解可以由子问题的解构建得来**

![image-20230908215626784](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908215626784.png)

具体做法：

以$dp[n]$为起始点，递归的将一个较大问题拆分成两个较小问题的和，直到到达$dp[1]=1$和$dp[2]=2$时返回

~~~C++
int dfs(int i){
       // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}

int main() {
    int n=0;
    cin>>n;
    cout<<dfs(n);
    return 0;
}
~~~

但是这种做法存在**大量重复**,因为有很多子问题是已经求解过的

![image-20230908220008161](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908220008161.png)

<center> 暴力搜索递归树</center>

**指数阶的时间复杂度是由于“重叠子问题”导致的**

**2.记忆化搜索**

了提升算法效率，**我们希望所有的重叠子问题都只被计算一次**。为此，我们声明一个数组 `mem` 来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。

1. 当首次计算 $dp[i]$ 时，我们将其记录至 `mem[i]` ，以便之后使用。
2. 当再次需要计算 $dp[i]$ 时，我们便可直接从 `mem[i]` 中获取结果，从而避免重复计算该子问题。

~~~C++
int dfs(int i, vector<int> &mem) {
      // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // 若存在记录 dp[i] ，则直接返回之
    if (mem[i] != -1)
        return mem[i];
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1, mem) + dfs(i - 2, mem);
    // 记录 dp[i]
    mem[i] = count;
    return count;
}
int main() {
    int n=0;
    cin>>n;
      // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录
    vector<int> mem(n + 1, -1);
    cout<<dfs(n, mem);
    return 0;
}
~~~

**经过记忆化处理后，所有重叠子问题都只需被计算一次**，时间复杂度被优化至 $O(n)$

![image-20230908221303846](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908221303846.png)

<center> 记忆化搜索递归树</center>

**3.动态规划**

**记忆化搜索是一种“从顶至底”的方法（因为有回溯过程来求解）**：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯将子问题的解逐层收集，构建出原问题的解。

与之相反，**动态规划是一种“从底至顶”的方法**：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。

**因此，动态规划不包含回溯过程，因此只需使用循环迭代实现，**

~~~C++
/* 爬楼梯：动态规划 */
int climbingStairsDP(int n) {
    if (n == 1 || n == 2)
        return n;
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = 1;
    dp[2] = 2;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
~~~

上面的代码中，**我们初始化一个数组 `dp` 来存储子问题的解，它起到了记忆化搜索中数组 `mem` 相同的记录作用。**

![image-20230908222119485](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908222119485.png)

**补充：空间优化**

由于$dp[i]$只与 $dp[i-1] $和 $dp[i-2]$有关，因此我们无须使用一个数组 `dp` 来存储所有子问题的解，而只需两个变量滚动前进即可

~~~C++
/* 爬楼梯：空间优化后的动态规划 */
int climbingStairsDPComp(int n) {
    if (n == 1 || n == 2)
        return n;
    int a = 1, b = 2;
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = a + b;
        a = tmp;
    }
    return b;
}
~~~

由于省去了数组 `dp` 占用的空间，因此空间复杂度从$O(n)$降低至 $O(1)$ 。

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。

### 总结

动态规划的常用术语。

- 将数组 `dp` 称为dp表，dp 表示状态 $i$对应子问题的解。
- 将最小子问题对应的状态（即第 1 和 2 阶楼梯）称为「初始状态」。
- 将递推公式 $dp[i]=dp[i-1]+dp[i-2]$ 称为「状态转移方程」。

## 动规问题特性

动态规划是通过子问题分解来求解问题的。实际上，**子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。**

- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题**，并在回溯中合并子问题的解，最终得到原问题的解。**
- 动态规划也对问题进行递归分解，**但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。**
- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，**我们可以将每个决策步骤之前的子序列看作为一个子问题。**

实际上，动态规划常用来求解最优化问题，它们不仅包含**重叠子问题，还具有另外两大特性：最优子结构、无后效性。**

> 强调动规三个特点，重叠子问题，最优子结构，无后效性

### 最优子结构

#### **爬楼梯最小代价**

为了更显然的考虑最优子问题这个定义，可以改一下题目

![image-20230908223018237](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908223018237.png)

示意图如下：

![image-20230908224548731](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908224548731.png)

这个时候就可以设$dp[i]$为爬到第$i$阶付出的代价，由于第$i$阶只可能从$i-1$阶和$i-2$阶来，因此$dp[i]$只能等于$dp[i-1]+cost[i]$或$dp[i-2]+cost[i]$。所以状态转移方程：

$dp[i]=min(dp[i-1],dp[i-2])+cost[i]$

这便可以引出最优子结构的含义：**原问题的最优解是从子问题的最优解构建得来的**。

> 我们从$dp[i-1]$和$dp[i-2]$中选择了更优的哪一个，用他来构建$dp[i]$这个最优解

**反问：**

原文题是不是没有最优子结构？它的目标是求解方案数量，看似是一个计数问题，但如果换一种问法：“求解最大方案数量”。我们意外地发现，**虽然题目修改前后是等价的，但最优子结构浮现出来了。**

第 $n$阶最大方案数量等于第 $n-1$ 阶和第 $n-2$阶最大方案数量之和。**所以说，最优子结构的解释方式比较灵活，在不同问题中会有不同的含义。**

```C++
/* 爬楼梯最小代价：动态规划 */
int minCostClimbingStairsDP(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = cost[1];
    dp[2] = cost[2];
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
    }
    return dp[n];
}
/* 爬楼梯最小代价：空间优化后的动态规划 */
int minCostClimbingStairsDPComp(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    int a = cost[1], b = cost[2];
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = min(a, tmp) + cost[i];
        a = tmp;
    }
    return b;
}
```

图解：子问题都是最优的，显然解就是最优的

![image-20230908225323754](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908225323754.png)

### 无后效性

