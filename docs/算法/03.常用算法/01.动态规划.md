---
title: 动态规划学习
date: 2023-09-08
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

> 参考：[hellogo-算法](https://github.com/krahets/hello-algo)
>

「动态规划 dynamic programming」是一个重要的算法思想，**它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。**

下面用爬梯子为例，先给出它的**暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法。**

Q:给定一个共有 3阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908173546222.png" style="zoom:100%">

对于求解方法数量，首先想到肯定就是暴力穷举，或者回溯（递归）来遍历每一种方法

这里可以很显然的想到一种解法：

**拍脑门的想法**

**将爬楼梯想象为一个多轮选择的过程：从地面出发，每轮选择上 1 阶或 2 阶，每当到达楼梯顶部时就将方案数量加 1 ，当越过楼梯顶部时就将其剪枝。**

~~~C++
//回溯(暴力穷举)来直接解这个问题
void search(vector<int> &choice, int state, int n, int&ans){
    if(state==n){
        ans+=1;
        //递归终止
        return;
    }
    for(auto x:choice){
        //剪枝
        if(state+x>n)
            break;
        search(choice,state+x,n,ans);
    }
}
int main() {
    int n=0;
    cin>>n;
    vector<int>choice={1,2};
    //爬到第几楼
    int state = 0;
    //方法数量
    int ans=0;
    search(choice,state,n,ans);
    cout<<ans;

}
~~~

上面其实并没有**分解这个问题**，而是去试探和穷举以及剪枝来解决这个问题。

**1.暴力搜索(dfs)**

当然，应该要从分解的角度去看一下这个问题。设爬到第 $i$阶共有$dp[i]$ 种方案，那么 $dp[i]$就是原问题，其子问题包括:

$dp[i-1],dp[i-2],...,dp[2],dp[1]$

并且由于每次只能上一阶或者两阶，那么显然：**爬到$i-1$阶的方案加上爬到$i-2$的方案数就等于爬到第$i$阶的方案数**。

$dp[i]=dp[i-1]+dp[i-2]$

意味着在爬楼梯问题中，各个子问题之间存在递推关系，**原问题的解可以由子问题的解构建得来**

![image-20230908215626784](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908215626784.png)

具体做法：

以$dp[n]$为起始点，递归的将一个较大问题拆分成两个较小问题的和，直到到达$dp[1]=1$和$dp[2]=2$时返回

~~~C++
int dfs(int i){
       // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}

int main() {
    int n=0;
    cin>>n;
    cout<<dfs(n);
    return 0;
}
~~~

但是这种做法存在**大量重复**,因为有很多子问题是已经求解过的

![image-20230908220008161](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908220008161.png)

<center> 暴力搜索递归树</center>

**指数阶的时间复杂度是由于“重叠子问题”导致的**

**2.记忆化搜索**

了提升算法效率，**我们希望所有的重叠子问题都只被计算一次**。为此，我们声明一个数组 `mem` 来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。

1. 当首次计算 $dp[i]$ 时，我们将其记录至 `mem[i]` ，以便之后使用。
2. 当再次需要计算 $dp[i]$ 时，我们便可直接从 `mem[i]` 中获取结果，从而避免重复计算该子问题。

~~~C++
int dfs(int i, vector<int> &mem) {
      // 已知 dp[1] 和 dp[2] ，返回之
    if (i == 1 || i == 2)
        return i;
    // 若存在记录 dp[i] ，则直接返回之
    if (mem[i] != -1)
        return mem[i];
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1, mem) + dfs(i - 2, mem);
    // 记录 dp[i]
    mem[i] = count;
    return count;
}
int main() {
    int n=0;
    cin>>n;
      // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录
    vector<int> mem(n + 1, -1);
    cout<<dfs(n, mem);
    return 0;
}
~~~

**经过记忆化处理后，所有重叠子问题都只需被计算一次**，时间复杂度被优化至 $O(n)$

![image-20230908221303846](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908221303846.png)

<center> 记忆化搜索递归树</center>

**3.动态规划**

**记忆化搜索是一种“从顶至底”的方法（因为有回溯过程来求解）**：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯将子问题的解逐层收集，构建出原问题的解。

与之相反，**动态规划是一种“从底至顶”的方法**：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。

**因此，动态规划不包含回溯过程，因此只需使用循环迭代实现，**

~~~C++
/* 爬楼梯：动态规划 */
int climbingStairsDP(int n) {
    if (n == 1 || n == 2)
        return n;
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = 1;
    dp[2] = 2;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
~~~

上面的代码中，**我们初始化一个数组 `dp` 来存储子问题的解，它起到了记忆化搜索中数组 `mem` 相同的记录作用。**

![image-20230908222119485](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908222119485.png)

**补充：空间优化**

由于$dp[i]$只与 $dp[i-1] $和 $dp[i-2]$有关，因此我们无须使用一个数组 `dp` 来存储所有子问题的解，而只需两个变量滚动前进即可

~~~C++
/* 爬楼梯：空间优化后的动态规划 */
int climbingStairsDPComp(int n) {
    if (n == 1 || n == 2)
        return n;
    int a = 1, b = 2;
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = a + b;
        a = tmp;
    }
    return b;
}
~~~

由于省去了数组 `dp` 占用的空间，因此空间复杂度从$O(n)$降低至 $O(1)$ 。

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。

### 总结

动态规划的常用术语。

- 将数组 `dp` 称为dp表，dp 表示状态 $i$对应子问题的解。
- 将最小子问题对应的状态（即第 1 和 2 阶楼梯）称为「初始状态」。
- 将递推公式 $dp[i]=dp[i-1]+dp[i-2]$ 称为「状态转移方程」。

## 动规问题特性

动态规划是通过子问题分解来求解问题的。实际上，**子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。**

- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题**，并在回溯中合并子问题的解，最终得到原问题的解。**
- 动态规划也对问题进行递归分解，**但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。**
- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，**我们可以将每个决策步骤之前的子序列看作为一个子问题。**

实际上，动态规划常用来求解最优化问题，它们不仅包含**重叠子问题，还具有另外两大特性：最优子结构、无后效性。**

> 强调动规三个特点，重叠子问题，最优子结构，无后效性

### 最优子结构

#### **爬楼梯最小代价**

为了更显然的考虑最优子问题这个定义，可以改一下题目

![image-20230908223018237](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908223018237.png)

示意图如下：

![image-20230908224548731](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908224548731.png)

这个时候就可以设$dp[i]$为爬到第$i$阶付出的代价，由于第$i$阶只可能从$i-1$阶和$i-2$阶来，因此$dp[i]$只能等于$dp[i-1]+cost[i]$或$dp[i-2]+cost[i]$。所以状态转移方程：

$dp[i]=min(dp[i-1],dp[i-2])+cost[i]$

这便可以引出最优子结构的含义：**原问题的最优解是从子问题的最优解构建得来的**。

> 我们从$dp[i-1]$和$dp[i-2]$中选择了更优的哪一个，用他来构建$dp[i]$这个最优解

**反问：**

原文题是不是没有最优子结构？它的目标是求解方案数量，看似是一个计数问题，但如果换一种问法：“求解最大方案数量”。我们意外地发现，**虽然题目修改前后是等价的，但最优子结构浮现出来了。**

第 $n$阶最大方案数量等于第 $n-1$ 阶和第 $n-2$阶最大方案数量之和。**所以说，最优子结构的解释方式比较灵活，在不同问题中会有不同的含义。**

```C++
/* 爬楼梯最小代价：动态规划 */
int minCostClimbingStairsDP(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = cost[1];
    dp[2] = cost[2];
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
    }
    return dp[n];
}
/* 爬楼梯最小代价：空间优化后的动态规划 */
int minCostClimbingStairsDPComp(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    int a = cost[1], b = cost[2];
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = min(a, tmp) + cost[i];
        a = tmp;
    }
    return b;
}
```

图解：子问题都是最优的，显然解就是最优的

![image-20230908225323754](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230908225323754.png)

### 无后效性

无后效性是动态规划能够有效解决问题的重要特性之一，定义为：**给定一个确定的状态，它的未来发展只与当前状态有关，而与当前状态过去所经历过的所有状态无关**。

> 注意，**后效性跟选择的状态也有关系**
>
> 也就是之前的决策不会给我现在做决策带来什么影响

比如爬楼梯问题，给定状态i  ，它会发展出状态 i+1 和状态 i+2 ，分别对应跳 1 步和跳 2 步。在做出这两种选择时，我们无须考虑状态 i之前的状态，它们对状态 i的未来没有影响。

下面给爬楼梯加一个约束，就不一样了

![image-20230909082221182](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909082221182.png)

这个时候，如果上一轮是跳 1 阶上来的，那么下一轮就必须跳 2 阶。这意味着，**下一步选择不能由当前状态（当前楼梯阶数）独立决定，还和前一个状态（上轮楼梯阶数）有关**。

因此在状态dp[i]表示当前阶梯i的方案数的定义之下，之前的$dp[i]=dp[i-1]+dp[i-2]$这个转移方程就已经失效了。

> 在这样的状态定义下，已经有后效性了，所以原先的状态转移方程失效了

但是依然可以用动规解决这个问题

首先拓展定义，**状态[$i,j]$表示处在第$i$阶，并且上一轮跳了$j$阶，其中$j∈1,2$。**

这样的状态考虑了上一次跳了多少，因此没有后效性了。

- 当 $j$ 等于 1 ，即上一轮跳了 1 阶时，这一轮只能选择跳 2 阶。
- 当 $j$ 等于 2 ，即上一轮跳了 2 阶时，这一轮可选择跳 1 阶或跳 2 阶。

此时，$dp[i,j]$表示状态$[i,j]$的方案数，转移方程变为:

$dp[i,1]=dp[i-1,2]$

$dp[i,2]=dp[i-2,1]+dp[i-2,2]$

![image-20230909084001452](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909084001452.png)

<center>考虑约束下的递推 </center>

**因此，最终的答案是$dp[n,1]+dp[n,2]$**

~~~C++
/* 带约束爬楼梯：动态规划 */
int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    // 初始化 dp 表，用于存储子问题的解
    vector<vector<int>> dp(n + 1, vector<int>(3, 0));
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i][1] = dp[i - 1][2];
        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
    }
    return dp[n][1] + dp[n][2];
}
~~~

### 没法用DP的情况

上面的案例中，**由于仅需多考虑前面一个状态，我们仍然可以通过扩展状态定义，使得问题重新满足无后效性**。然而，某些问题具有非常严重的“有后效性”。

![image-20230909084700489](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909084700489.png)

在这个问题中，下次跳跃依赖于过去所有的状态，**因为每一次跳跃都会在更高的阶梯上设置障碍，并影响未来的跳跃。对于这类问题，动态规划往往难以解决。**

实际上，许多复杂的组合优化问题（例如旅行商问题）都不满足无后效性。对于这类问题，我们通常会选择使用其他方法，例如启发式搜索、遗传算法、强化学习等，从而在有限时间内得到可用的局部最优解。

## 动规问题解题思路

上两节介绍了动态规划问题的主要特征，接下来我们一起探究两个更加实用的问题。

1. 如何判断一个问题是不是动态规划问题？
2. 求解动态规划问题该从何处入手，完整步骤是什么？

**总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常就适合用动态规划求解。**

然而，我们很难从问题描述上直接提取出这些特性。因此我们通常会放宽条件，**先观察问题是否适合使用回溯（穷举）解决**。

**适合用回溯解决的问题通常满足“决策树模型”**，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列。

换句话说，如果问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决。

在此基础上，动态规划问题还有一些判断的“**加分项**”。

- 问题包含最大（小）或最多（少）等最优化描述。
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。

相应地，也存在一些“**减分项**”。

- 问题的目标是找出所有可能的解决方案，而不是找出最优解。
- 问题描述中有明显的排列组合的特征，需要返回具体的多个方案。

**(!!!)如果一个问题满足决策树模型，并具有较为明显的“加分项“，我们就可以假设它是一个动态规划问题，并在求解过程中验证它。**

###  问题求解步骤

动态规划的解题流程会因问题的性质和难度而有所不同，但通常遵循以下步骤：**1 描述决策，2定义状态，3建立 $dp$ 表，4推导状态转移方程，5确定边界条件等。**

为了更形象地展示解题步骤，我们使用一个经典问题“最小路径和”来举例。

![image-20230909091701664](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909091701664.png)

示例

![image-20230909091738662](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909091738662.png)

#### **第一步：思考每轮的决策，定义状态，从而得到$dp$ 表**

首先看到这个问题，可以很容易的想到，这个问题应该可以通过一系列的决策解决（每次都选小的那个走）。

本题每一次的决策就是从当前格子向下或者向右走一步（选小的那个）。

**状态定义**

设当前格子的行列索引为 $[i,j]$，则向下或向右走一步后，索引变为 $[i+1,j]$或 $[i,j+1]$ 。因此，状态应包含行索引和列索引两个变量，记为 $[i,j]$。

状态$[i,j]$对应的子问题就是：从起始点$[0,0]$走到$[i,j]$的最小路径和，记为$dp[i,j]$

那么有如下二维$dp$矩阵，尺寸与输入网格$grid$相同

![image-20230909094153148](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909094153148.png)

**Note:**

动态规划和回溯过程可以被描述为一个决策序列，而状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态。

每个状态都对应一个子问题，我们会定义一个$dp$ 表来存储所有子问题的解，状态的每个独立变量都是 $dp$ 表的一个维度。本质上看，$dp$ 表是状态和子问题的解之间的映射。

#### **第二步：找出最优子结构，进而推导出状态转移方程**

对于状态$dp[i,j]$,他只能上边$[i-1,j]$和左边格子$[i,j-1]$转移而来。因此最优子序列为:到达$[i,j]$的最小路径和由$[i-1,j]$和$[i,j-1]$的最小路径决定，取他们中小的那个加上当然这个格子的数。

那么转移方程:

$dp[i,j]=min(dp[i-1,j],dp[i,j-1])+grid[i,j]$

![image-20230909095718958](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909095718958.png)

>根据定义好的 dp 表，思考原问题和子问题的关系，找出通过子问题的最优解来构造原问题的最优解的方法，即最优子结构。
>
>一旦我们找到了最优子结构，就可以使用它来构建出状态转移方程。

#### **第三步：确定边界条件和状态转移顺序**

在本题中，处在首行的状态只能向右转移，首列状态只能向下转移，因此首行 $i=0$ 和首列 $j=0$是边界条件。

由于每个格子是由其左方格子和上方格子转移而来，因此我们使用采用循环来遍历矩阵，外循环遍历各行、内循环遍历各列。

![image-20230909095854744](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909095854744.png)

**NOTE:**

**边界条件在动态规划中用于初始化 $dp$ 表，在搜索中用于剪枝。**

状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确地计算出来。

根据以上分析，我们已经可以直接写出动态规划代码。然而子问题分解是一种从顶至底的思想，**因此按照“暴力搜索 → 记忆化搜索 → 动态规划”的顺序实现更加符合思维习惯。**

**1. 暴力搜索(回溯)：**

从状态$[i,j]$开始搜索，不断分解为更小的状态$[i-1,j]$和$[i,j-1]$,递归函数包括：

- 递归参数:状态$[i,j]$
- 返回值:从$[0,0]$到$[i,j]$的最小路径和
- 终止条件：当$i=0$且$j=0$时，返回代价$grid[0,0]$
- 剪枝（边界条件）：当$i<0$或者$j<0$时索引越界，返回代价$+∞$

~~~C++
/* 最小路径和：暴力搜索 */
int minPathSumDFS(vector<vector<int>> &grid, int i, int j) {
    // 若为左上角单元格，则终止搜索
    if (i == 0 && j == 0) {
        return grid[0][0];
    }
    // 若行列索引越界，则返回 +∞ 代价
    if (i < 0 || j < 0) {
        return INT_MAX;
    }
    // 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价
    int left = minPathSumDFS(grid, i - 1, j);
    int up = minPathSumDFS(grid, i, j - 1);
    // 返回从左上角到 (i, j) 的最小路径代价
    return min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;
}

~~~

下图给出了以 $dp[2,1] $为根节点的递归树，其中包含一些重叠子问题，其数量会随着网格 `grid` 的尺寸变大而急剧增多。

![image-20230909101910651](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909101910651.png)

<center> 暴力搜索递归树</center>

每个状态都有向下和向右两种选择，从左上角走到右下角总共需要 $m+n-2$步，所以最差时间复杂度为 $O(2^{m+n})$ 。请注意，这种计算方式未考虑临近网格边界的情况，当到达网络边界时只剩下一种选择。因此实际的路径数量会少一些。

**2.记忆化搜索**

我们引入一个和网格 `grid` 相同尺寸的记忆列表 `mem` ，用于记录各个子问题的解，并将重叠子问题进行剪枝。

~~~C++
/* 最小路径和：记忆化搜索 */
int minPathSumDFSMem(vector<vector<int>> &grid, vector<vector<int>> &mem, int i, int j) {
    // 若为左上角单元格，则终止搜索
    if (i == 0 && j == 0) {
        return grid[0][0];
    }
    // 若行列索引越界，则返回 +∞ 代价
    if (i < 0 || j < 0) {
        return INT_MAX;
    }
    // 若已有记录，则直接返回
    if (mem[i][j] != -1) {
        return mem[i][j];
    }
    // 左边和上边单元格的最小路径代价
    int left = minPathSumDFSMem(grid, mem, i - 1, j);
    int up = minPathSumDFSMem(grid, mem, i, j - 1);
    // 记录并返回左上角到 (i, j) 的最小路径代价
    mem[i][j] = min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;
    return mem[i][j];
}

~~~

在引入记忆化后，所有子问题的解只需计算一次，因此时间复杂度取决于状态总数，即网格尺寸 $O(mn)$。

![image-20230909102922559](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230909102922559.png)

<center> 记忆化搜索递归树</center>

**3.动态规划**

基于迭代实现动态规划解法。

**这里注意边界条件，需要先对首行和首列进行初始化，并且循环时已经限制了边界，就不会出现越界的情况。**显然时间复制度$O(mn)$

~~~C++
/* 最小路径和：动态规划 */
int minPathSumDP(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    // 初始化 dp 表
    vector<vector<int>> dp(n, vector<int>(m));
    dp[0][0] = grid[0][0];
    // 状态转移：首行
    for (int j = 1; j < m; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    // 状态转移：首列
    for (int i = 1; i < n; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    // 状态转移：其余行列
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
        }
    }
    return dp[n - 1][m - 1];
}

~~~

**空间优化**

由于每个格子只与其左边和上边的格子有关，因此我们可以只用一个单行数组来实现 $dp$ 表(**把二维的状态表压缩成一维的，也叫状态压缩)**。

**请注意，因为数组 `dp` 只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行中更新它。**

> 感觉很难想，压缩后代码更难懂

~~~C++
/* 最小路径和：空间优化后的动态规划 */
int minPathSumDPComp(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    // 初始化 dp 表
    vector<int> dp(m);
    // 状态转移：首行
    dp[0] = grid[0][0];
    for (int j = 1; j < m; j++) {
        dp[j] = dp[j - 1] + grid[0][j];
    }
    // 状态转移：其余行
    for (int i = 1; i < n; i++) {
        // 状态转移：首列
        dp[0] = dp[0] + grid[i][0];
        // 状态转移：其余列
        for (int j = 1; j < m; j++) {
            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];
        }
    }
    return dp[m - 1];
}

~~~

>dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]; 这里 min里面的dp[j - 1]代表左边的格子，dp[j]是上一行赋值的，代表上面的格子。

