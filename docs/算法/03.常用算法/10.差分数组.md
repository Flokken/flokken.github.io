---
title: 差分数组和前缀和数组
date: 2024-4-17
tags: 
  - null
categories:  
  - 算法
  - 题单分类
---

## 理论学习

### 差分数组

> 灵神的讲解文章：https://leetcode.cn/circle/discuss/FfMCgb/

对于一个数组$a$，定义其差分数组为

$d[i]=a[0],i=0$

$d[i]=a[i]-a[i-1],i>=1$

- 性质1：从左往右**累加**$d$中的元素，可以得到数字$a$​，也就是$a[i]=\sum{d[i]}$
- 性质2：可以把$a$上的区间操作，等价转变为$d$上的单点操作。

**区间操作**:给$a[i],a[i+1],...a[j]$都加上$x$

**单点操作**，给$d[i]$增加$x$，给$d[j+1]$减去$x$

举例：

$a=[1,3,3,5,8]$，那么$d=[1,2,0,2,3]$​

性质1,：从左往右累积$d$中元素，还原了a

性质2：如果给a数组$[0,3]$这个区间都加上1，那么$a$数组变为$[2,4,4,5,8]$

等同于$d$数组变为$[2,2,0,1,3]$。我们累加一下，发现d数组仍然可以转变为区间操作后的a数组，说明性质正确。

### 前缀和数组

对于一个数组$a$，定义其前缀和数组为

$pre[i]=\sum{a[i]}$

- 性质1：区间和查询。

对于查询$a$数组$a[i],a[i+1],...a[j]$的和，等同于$pre[j]-pre[i-1]$

## 例题

### 差分数组

#### 1094. 拼车

[1094. 拼车](https://leetcode.cn/problems/car-pooling/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240417170152405.png" alt="image-20240417170152405" style="zoom:80%;" />

灵神题解：

>https://leetcode.cn/problems/car-pooling/solutions/2550264/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra

![image-20240417170212221](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240417170212221.png)

其实就是维护一个差分数组，并使用差分数组进行区间操作，然后通过差分数组还原原数组

注意：这里的区间操作是$[from,to)$，因为在$to$已经下车了，所以是左开右闭区间

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int n=trips.length;
        int []d = new int[1001];
        for(int []t:trips){
            int num=t[0],from = t[1],to=t[2];
            d[from]+=num;
            d[to]-=num;
        }
        int s=0;
        for(int x:d){
            s+=x;
            if(s>capacity){
                return false;
            }
        }
        return true;
    }
}
```

## 练习

### 1109. 航班预订统计

[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240417170408499.png" alt="image-20240417170408499" style="zoom:80%;" />

思路：

维护一个差分数组进行区间操作，最后还原为数组即可。注意$[f,e]$​是闭区间

注意：由于这里查询从1开始到n，所以可以把差分数组也初始化到1-n

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int []d =new int [n+2];//因为题目查询从1开始
        int []ans =new int [n];
        for(int []book:bookings){
            int x=book[0],y=book[1],num = book[2];
            d[x]+=num;
            d[y+1]-=num;
        }
        int s=0;
        for(int i=1;i<=n;i++){
            s+=d[i];
            ans[i-1]=s;
        }
        return ans;
    }
}
```

### 2381. 字母移位 II(学习，循环移位)

[2381. 字母移位 II](https://leetcode.cn/problems/shifting-letters-ii/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240417171211842.png" alt="image-20240417171211842" style="zoom:80%;" />

思路：

这里是a-z循环移位，那么可以把向前移位看成-1，向后移位看成1.对于移位结果，我们都应该取模。

- 0->-1
- 1->1

那我们使用一个差分数组维护移位后的结果，然后计算这个移位后字符串即可

注意：

- 对于负数$x$，我们一直用$x+=mod$，直到其变成一个正数

- 假设移位数是$y$,使用$'a'+(c-'a'+y)\%mod$来计算移位后结果

```java
class Solution {
    public String shiftingLetters(String s, int[][] shifts) {
        int mod =26;
        int n=s.length();
        int []d =new int[n+1];
        for(int i=0;i<shifts.length;i++){
            int []sh =shifts[i];
            int x = sh[0],y=sh[1],num= (sh[2]==0?-1:1);
            d[x]+=num;
            d[y+1]-=num;
        }
        StringBuilder sb = new StringBuilder();
        int sum=0;
        for(int i=0;i<n;i++){
            char ch =s.charAt(i);
            sum+=d[i];
            int step = (sum+mod*10000)%mod;//根据数据范围，我们这样做保证其是一个正数
            sb.append((char)('a'+(ch-'a'+step)%mod));
        }
        return sb.toString();
    }
}
```

