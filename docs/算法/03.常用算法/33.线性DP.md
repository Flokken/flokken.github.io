---
title: 线性DP
date: 2024-02-23
tags: 
  - null
categories:  
  - 算法
  - 常用算法
---

## 线性DP



### 1143.最长公共子序列（LCS）

[1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

> 灵神讲解:【最长公共子序列 编辑距离】 https://www.bilibili.com/video/BV1TM4y1o7ug/?share_source=copy_web&vd_source=bd8913ef91bbd10ac3097704082ea53b

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240407083026687.png" alt="image-20240407083026687" style="zoom: 80%;" />

本质还是**选不选**的问题，只不过有两个序列$s$和$t$，对于一对字母$s[i]$和$t[j]$，有四种情况

![image-20240407084139700](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240407084139700.png)

回溯三问：

- 当前操作？考虑$s[i]$和$t[j]$选或者不选
- 子问题?$s$的前$i$个字母和$t$的前$j$个字母的LCS长度
- 下一个子问题：
  - $s$的前$i-1$个字母和$t$的前$j-1$个字母的LCS长度
  - $s$的前$i-1$个字母和$t$的前$j$个字母的LCS长度
  - $s$的前$i$个字母和$t$的前$j-1$个字母的LCS长度

好像可以这样定义转移方程

$dfs(i,j)=max(dfs(i-1,j),dfs(i,j-1),dfs(i-1,j-1)+1),s[i]=t[j]$

$dfs(i,j)=max(dfs(i-1,j),dfs(i,j-1),dfs(i-1,j-1)),s[i]!=t[j]$

进一步思考：

- 当$s[i]==t[j]$时，需要考虑只选一个的情况吗
- 当$s[i]!=[tj]$时，需要考虑都不选的情况吗



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240407085231855.png" alt="image-20240407085231855" style="zoom:80%;" />

解释一下这个图：

通过反证法证明当$s[i]=t[j]$时，只选一个的情况不会更优，只需要都选即可

假设当前LCS长度为$x$，如果都一样，那么都选，最长子序列增加到$x+1$。假如只选一个更优，那么我们继续迭代下去，发现其LCS<=x。那么肯定也就$<=x+1$，也就是并没有更优，都选即可。







### 2369. 检查数组是否存在有效划分

[2369. 检查数组是否存在有效划分](https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240301224238734.png" alt="image-20240301224238734" style="zoom:67%;" />

#### 回溯做法

我们假设数组长度为n，那么当前问题就是:从前n(n>=2)个数字中，找到一种有效划分。

对于一个数组，一般存在两种思考方向，**从前往后或者从后往前**

我们先**从后往前**

- 当前操作: 枚举第i个位置是否可以做为有效划分?

- 子问题: 从前n(n>=2)个数字中，找到一种有效划分。

- 下一个子问题，分类讨论

  - 选2个元素，if(nums[i]=nums[i-1]),问题规模缩小到n-2去找一个有效划分

  - 选3个元素，if(nums[i]=nums[i-1]=nums[i-2]),问题规模缩小到n-3去找一个有效划分

  - 选3个元素，if(nums[i]=nums[i-1]+1=nums[i-2]+2),问题规模缩小到n-3去找一个有效划分

因此我们可以定义$dfs(i)$表示长度为i的nums数组是否存在一种有效划分

**转移方程**

- $dfs(i)=dfs(i-2) \quad if\quad  nums[i]=nums[i-1] \quad i>=1$
- $dfs(i)=dfs(i-3) \quad if\quad  nums[i]=nums[i-1]=nums[i-2]\quad i>=2$
- $dfs(i)=dfs(i-3) \quad if\quad  nums[i]=nums[i-1]+1=nums[i-2]+2\quad i>=2$

**边界条件**

$i<0$，这个时候直接返回true，因为这时候表示划分完成

```java
class Solution {
    int []vis;
    int []nums;
    public boolean validPartition(int[] nums) {
        this.nums=nums;
        vis= new int[nums.length];
        return dfs(nums.length-1);
    }
    public boolean dfs(int i){
        if(i<0){
            return true;
        }
        if(vis[i]!=0){
            return vis[i]==-1?false:true;
        }
        boolean flag=false;
        if(i>=1 &&nums[i-1]==nums[i]){
            flag = flag | dfs(i-2);
        }
        if(i>=2 && nums[i]==nums[i-1]&&nums[i]==nums[i-2]){
            flag = flag | dfs(i-3);
        }
        if(i>=2 && nums[i]==nums[i-1]+1&&nums[i]==nums[i-2]+2){
            flag= flag | dfs(i-3);
        }
        vis[i]=flag==false?-1:1;
        return flag;


    }
}
```

**我们再尝试一下从前往后思考**

- 当前操作: 枚举第i个位置是否可以做为有效划分?

- 子问题: 从前n(n>=2)个数字中，找到一种有效划分。

- 下一个子问题，分类讨论，**这里和从后往前有区别**

  - 选2个元素，if(nums[i]=nums[i+1]),问题规模缩小到n-2去找一个有效划分

  - 选3个元素，if(nums[i]=nums[i+1]=nums[i+2]),问题规模缩小到n-3去找一个有效划分

  - 选3个元素，if(nums[i]=nums[i+1]-1=nums[i+2]-2),问题规模缩小到n-3去找一个有效划分

**状态的定义仍然是一样的**

定义$dfs(i)$表示长度为i的nums数组是否存在一种有效划分

**递归边界**

这里只需要考虑一种边界情况，即$i>=n$，返回true

因为**这种情况表示划分完成了**

```java
class Solution {
    int []vis;
    int []nums;
    int n;
    public boolean validPartition(int[] nums) {
        this.nums=nums;
        n=nums.length;
        vis= new int[n];
        return dfs(0);
    }
    public boolean dfs(int i){
        if(i>=n){
            return true;
        }
        if(vis[i]!=0){
            return vis[i]==-1?false:true;
        }
        boolean flag=false;
        if(i+1<n &&nums[i+1]==nums[i]){
            flag = flag | dfs(i+2);
        }
        if(i+2<n && nums[i]==nums[i+1] && nums[i]==nums[i+2]){
            flag = flag | dfs(i+3);
        }
        if(i+2<n && nums[i]==nums[i+1]-1&& nums[i]==nums[i+2]-2){
            flag= flag| dfs(i+3);
        }
        vis[i]=flag==false?-1:1;
        return flag;


    }
}
```

#### 1:1翻译为递推

我们从从后往前的递归翻译到递推，首先把状态中的$i$用$i+3$替换，则

- $f[i+3]=f[i+1] \quad if\quad  nums[i]=nums[i-1]$
- $f[i+3]=f[i] \quad if\quad  nums[i]=nums[i-1]=nums[i-2]$
- $f[i+3]=f[i] \quad if\quad  nums[i]=nums[i-1]+1=nums[i-2]+2$

**边界**

$f[0]=true$，这个从递归中翻译而来，递归中的$i<0$表示已经划分完的状态

由于$i+3$,所以这里的f[0]也是划分完的状态，是初始状态

**代码**

```java
class Solution {
    public boolean validPartition(int[] nums) {
        int n=nums.length;
        boolean []f = new boolean[n+5];
        f[2]=true;
        for(int i=0;i<n;i++){
            if(i>=1 && nums[i]==nums[i-1]){
                f[i+3]=f[i+3]|f[i+1];
            }
            if(i>=2 &&  nums[i]==nums[i-1] && nums[i]==nums[i-2]){
                f[i+3]=f[i+3]|f[i];
            }
            if(i>=2 && nums[i]==nums[i-1]+1&&nums[i]==nums[i-2]+2){
                f[i+3]=f[i+3]|f[i];
            }
        }
        return f[n+2];
    }
}
```

