---
title: 集合(Map和Set)
date: 2024-01-18
tags: 
  - null
categories:  
  - 算法
  - 数据结构		
---

## Collection

首先我们看Collection继承体系，可以看到List和Set两个接口类是继承与Collection这个顶级接口之下的。

> 红色是接口，蓝色是实现类

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230919101416175.png)



### 共有方法介绍

| 方法声明                   | 功能描述                     |
| -------------------------- | ---------------------------- |
| boolean add(Object o)      | 向集合中添加一个元素         |
| boolean remove(Object o)   | 删除该集合中指定的元素       |
| boolean isEmpty()          | 判断该集合是否为空           |
| boolean contains(Object o) | 判断该集合中是否包含某个元素 |
| int size()                 | 获取该集合元素个数           |
| public Object[] toArray()  | 把集合总的元素，存储到数组中 |
| void clear()               | 删除该集合中的所有元素       |
| Iterator<E> iterator()     | 返回此集合中的元素的迭代器   |

### List

List系列是Collection中的一种，注意：

- Collection的方法都被List继承了
- List集合因为有索引，所以多了一些索引操作的方法

List是有序集合,这里的有序指的是存取顺序

- 有索引，用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素
- 与Set集合不同,列表通常允许重复的元素

####  特有方法介绍

| 方法名                        | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| void add(int index,E element) | **在此集合中的指定位置插入指定的元素（原来位置的自动后移，这个经常用）** |
| E remove(int index)           | 删除指定索引处的元素，返回被删除的元素（所以指定首尾位置也可删除首尾元素） |
| E set(int index,E element)    | 修改指定索引处的元素，返回被修改的元素                       |
| E get(int index)              | 返回指定索引处的元素                                         |

#### 补充	

1.初始化数组

- List如果初始化并且有固定值

```java
List<String> stringList = Arrays.asList("a", "b", "c");
```

- 使用`List.of()`，这在返回答案时经常用到

```java
//返回一个List,其中是一对下标，比如[1,2]，[3,4]
return new ArrayList<>(List.of(1,2));
```

2.List如何移除首尾元素?**List没有提供特定的方法**

我们用remove(int index)实现

```java
List<Integer> ans = {1,2,3};
ans.remove(0);//移除第一个元素
ans.remove(ans.size()-1);//删除最后一个元素
```

### Set

特点

- 无序
- **不重复：可以去除重复**
- 无索引：**没有带索引的方法，所以不能用索引获取元素**

Set接口实现类

- HashSet:**无序，不重复，无索引**
- LinkedHashSet：**有序，不重复，无索引**
- TreeSet：**可排序，不重复，无索引**

#### 方法介绍

set的方法和collection接口基本一样，但是由于其不允许重复，所以实现上有一些区别

| 方法名                            | 描述                               |
| --------------------------------- | ---------------------------------- |
| public boolean add(E e)           | 添加给定元素到集合                 |
| public void clear()               | 清空集合中所有元素                 |
| public boolean remove(E e)        | 移除元素，不存在这个元素返回false, |
| public boolean isEmpty()          | 判断集合是否为空                   |
| public boolean contains(Object o) | 判断集合是否包含此元素             |
| public int size()                 | 返回集合元素个数                   |

- 当添加一个重复元素时。add 的返回值为false，并且不能添加进去，（List允许重复，永远是true）
- `remove(E e)` 方法是通过比较元素的 `equals()` 方法来判断元素是否相等的,不存在这个元素返回false

## Map

Map是双列集合，双列集合就是指里面的一个元素，是两列或者说一对

- 双列集合一次需要存一对数据，分别为键和值
- **键不能重复，值可以重复**
- 键和值是一一对应的，每一个键只能找到自己对应的值
- (key,value)这个整体我们称之为**键值对**或者**键值对对象**，**在java中叫做“Entry对象”**

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/9e258e1db83699006c9e1d3908afb528.png" alt="img" style="zoom:67%;" />

**实例化和初始化**

1.初始化并赋值，java8

```java
HashMap<String, String > myMap  = new HashMap<String, String>(){{  
      put("a","b");  
      put("b","b");       
}};  //第一层大括号，匿名内部类
//第二层大括号，匿名内部类初始化块

```

2.遍历一个String[]数组words，并且统计String出现次数

```java
 for(String s:words){
            map.put(s,map.getOrDefault(s,0)+1);//注意这种写法，经常用到
}
```

3.内部Pair节点

```java
 Class Pair{
        int index;
        double value;
        //构造函数参数列表初始化
           Pair(int index, double value) {
        this.index = index;
        this.value = value;
        }
    }   
```

>**注意java没有构造函数参数列表初始化！！！**        `Pair(int in,double va):index(index),value(va);`,
>
>老老实实赋值！构造函数

常用方法

### 方法介绍

| 方法名                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| V put(K key,V value)                                         | 添加元素                                                     |
| V remove(Object key)                                         | 根据键删除键值对元素                                         |
| void clear()                                                 | 移除所有的键值对元素                                         |
| boolean containsKey(Object key)                              | 判断集合是否包含指定的键                                     |
| boolean containsValue(Object value)                          | 判断集合是否包含指定的值                                     |
| boolean isEmpty()                                            | 判断集合是否为空                                             |
| int size()                                                   | 集合的长度，也就是集合中键值对的个数                         |
| Set<K>   keySet()                                            | 获取所有键的集合(是Set，因为key不重复)                       |
| Collection<V>   values()                                     | 获取所有value的集合（是Collection，因为value可重复）         |
| computeIfAbsent(K key, Function remappingFunction)           | 如果key存在则直接返回val，否则执行function得到value，并且将(key,value)加入map中 |
| default V **merge**(K key, V value, Function remappingFunction) | merge() 方法会先判断指定的 key 是否存在，如果不存在，则添加键值对到 hashMap 中。<br />如果存在，则返回通过 remappingFunction 重新计算后的值。 |

### 例子

1.`computeIfAbsent(K key, Function remappingFunction)`

场景：我有一个数组[1,1,2,2,3,3]，我想构建一个哈希表，其key是对应的值，value是相同数据下标的集合.

```java
int []nums=new int[]{1,1,2,2,3,3};
int n=nums.size();
Map<Integer,List<Integer>> map = new HashMap<>();
for(int i=0;i<n;i++){
    map.computeIfAbsent(nums.get(i),k->new ArrayList<>()).add(i);
}
```

- `k->new ArrayList<>()`,这个是lambda表达式，省略了return
- ` map.computeIfAbsent(nums.get(i),k->new ArrayList<>())`意思是如果这个key不存在，则把这个key和对应list这个键值对压进去map，如果key存在，当然不会调用这个lambda表达式
- add(i)是把对应下标加到对应list中

### TreeMap

- TreeMap底层是红黑树结构（和TreeSet一样）
- 依赖自然排序或者比较器排序,对键进行排序，注意默认按照键的从小到大进行排序

**独有方法**

| 方法名        | 说明                                   |
| ------------- | -------------------------------------- |
| K   lastKey() | 返回此映射中当前的最后一个（最高）键。 |
| K firstKey()  | 返回此映射中当前的第一个（最低）键。   |

#### 例题

[3092. 最高频率的 ID](https://leetcode.cn/problems/most-frequent-ids/)

![image-20240325102405377](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240325102405377.png)

- TreeMap是根据key来排序的，所以我们可以用一个$cnt[x]$来记录$x$出现次数；再用一个有序集合来对出现次数维护





## Collections工具类

Collections 是一个操作Set和List(Collection)  ,以及Map的集合工具类。

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/v2-f52e8432b3c0e0395045a2b6b5630019_720w.webp)

> 注意Collection和Map是两个独立的接口，但是Collections可以操作这个两个接口体系的所有实现类

### 常用方法

| 方法                                                         | 作用                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| static <T> void  sort(List<T> list, Comparator<? super T> c) | 根据指定的比较器引起的顺序对指定的列表进行排序。 |
| static void  reverse(List<?> list)                           | 反转指定列表中元素的顺序(元素内部顺序不变)。     |

> Question: reverse对于`List<List<Integer>>ans`,是什么效果
>
> A:只会反转ans的元素，也就是第一级列表，内部的小列表的元素不变

### 例子

1.根据指定比较器对集合中元素进行排序，比如list。

> list等集合用Collections工具类排序，数组用Arrays进行排序

这里可以看这道题[451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/)。我们用一个map存储了字符频率，然后把字符放到一个list里。然后调用工具类，重载比较器对list进行排序。**这个场景很常见**。

> 感觉也可以用内部类Node来表示(字符，频率)，然后对node列表排序，但没有这么简单。

```java
class Solution {
    public String frequencySort(String s) {
        Map<Character,Integer>map = new HashMap<>();
        int n = s.length();
        for(int i=0;i<n;i++){
            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);
        }
        List<Character>list = new ArrayList(map.keySet());
        Collections.sort(list,(a,b)->map.get(b)-map.get(a));//对list降序排列
        //这里相当于用·(a,b)->map.get(b)-map.get(a)这个lambda表达式实现这个比较器接口
        int size = list.size();
        StringBuilder str = new StringBuilder();
        for(int i=0;i<size;i++){
            for(int j=0;j<map.get(list.get(i));j++){
                str.append(list.get(i));
            }
        }
        return str.toString();

    }
}
```

## Arrays工具类

位于java.util 包中。该类提供了一些列方法来操作数组，如排序、复制、比较、填充等。

### 常用方法

> 基本类型即int,char,long,float,double,boolean,byte,short

| 方法名                                                       | 作用                                |
| ------------------------------------------------------------ | ----------------------------------- |
| void sort(int []a/float[] a... 基本类型的数组)               | 对数组进行升序排列                  |
| void sort(int []a,int start, int end)                        | 对数组[start,end]进行升序排列       |
| void sort(T[] a,  int start, int end, Comparator<? super T> c) | 根据比较器对数组[start,end]进行排序 |
| String toString(int a...基本类型的数组)                      | 将所给数组转换为String返回          |
| void fill(int []a, int value)(基本类型数组都可以)            | 用所给值赋给这个数组的每一项        |

- 注意fill入参是一维数组，如果是`a[m][n]`这样的长m，宽n二维数组，那么应该
  - for(int i=0;i<a[0].length;i++) Arrays.fill(a[i],x);//这样调用才对

## 包装类

