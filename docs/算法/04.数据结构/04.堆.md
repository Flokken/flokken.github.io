---
title: 堆
date: 2023-11-16
tags: 
  - null
categories:  
  - 算法
  - 数据结构		
---

> 参考：
>
> [Hello 算法-堆](https://www.hello-algo.com/chapter_heap/)

## 概述

「堆 heap」是一种满足特定条件的完全二叉树，主要可分为两种：大顶堆和小顶堆。

- 「大顶堆 max heap」：任意节点的值 ≥ 其子节点的值。
- 「小顶堆 min heap」：任意节点的值 ≤ 其子节点的值。

![image-20231116193042558](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231116193042558.png)

堆作为完全二叉树的一个特例，具有以下特性。

- 最底层节点靠左填充，其他层的节点都被填满。
- 我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”。
- 对于大顶堆（小顶堆），堆顶元素（即根节点）的值分别是最大（最小）的。

## 堆常用操作

我们在写代码时，经常说什么用优先队列来实现堆，需要指出的是，**这是因为许多编程语言提供的是「优先队列 priority queue」**，这是一种抽象数据结构，定义为具有优先级排序的队列。实际上，**堆通常用作实现优先队列，大顶堆相当于元素按从大到小顺序出队的优先队列**。

**从使用角度来看，我们可以将“优先队列”和“堆”看作等价的数据结构。**

> 因此可以不对两者不做特别区分，统一叫做“堆“

堆常用的操作和栈，队列很像，即

- 入堆，出堆，大小，查看堆顶，查看堆是否为空

> 因此java用`priorityQueue类`来实现堆，用`Deque接口`实现栈，都继承自`Queue`

java中假设我创建一个堆，使用的是`PriorityQueue`这个类

~~~java
PriorityQueue<E>heap =new PriorityQueue<>();
~~~

其使用方法和栈的`Deque`差不多

| 方法名    | 描述             | 时间复杂度 |
| --------- | ---------------- | ---------- |
| add(E e)  | 将元素插入堆     | O(logn)    |
| peek()    | 获取堆顶元素     | O(1)       |
| poll()    | 获取并移除堆顶   | O(logn)    |
| size()    | 返回堆中元素个数 | O(1)       |
| isEmpty() | 查看是否为空     | O(1)       |
| clear()   | 清楚所有元素     |            |

在实际应用时，**我们一般要分大根堆或者小根堆，这时需要重写`Comparator`（或者说这个优先队列的排序规则）**

>类似于排序算法中的“从小到大排列”和“从大到小排列”，我们可以通过修改 Comparator 来实现“小顶堆”与“大顶堆”之间的转换。

### 排序规则重载

使用优先队列/堆的时候，我们常常需要实现`Comparable`接口或者使用`Comparator`比较器

>Arrays和Collections工具类
>
>Java为我们提供了实用的操作数组和集合的工具类，Arrays和Collections。内含对数组或集合的各种[排序方法](https://so.csdn.net/so/search?q=排序方法&spm=1001.2101.3001.7020)，数组与集合的转换方法。
>
>对于这两种类涉及到排序时，要么让其元素的类实现`Comparable`接口，要么传入`Comparator`比较器

**`Comparable`接口**

最常见的是对一个自定义的类来实现`Comparable`接口，然后才能加入到`PriorityQueue()`中去，这个感觉用起来没那么方便。可以看下面的例子

>[参考](https://flokken.github.io/pages/597c1c/#comparator%E6%8E%92%E5%BA%8F)

**`comparator`比较器**



哪个类要用，就让这个类的构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法。

~~~java
TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {
        int len = nums.length;
        // 使用一个含有 k 个元素的最小堆，PriorityQueue 底层是动态数组，为了防止数组扩容产生消耗，可以先指定数组的长度
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k,new Comparator<Integer>(){
            @Override
            public int compare(Teacher o1, Teacher o2) {return o1-o2;}
            
        });
        // Java 里没有 heapify ，因此我们逐个将前 k 个元素添加到 minHeap 里
        });
~~~

>`Comparator.comparingInt(a -> a)` 是一个比较器（Comparator），用于设定元素之间的优先级关系。在这里，比较器通过 `comparingInt` 方法根据元素自身的值进行比较，即按照整数大小进行比较。

对于 `public int compare(int o1,int o2)...{}`

- 如果返回值为负数，表示当前存入的元素是较小值，存左边
- 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存
- 如果返回值为正数，表示当前存入的元素是较大值，存右边
- **根据上面的规则，我们知道`return o1-o2`是升序排序，`return o2-o1`是降序排序**

### 一个常用的模板

## 自己实现堆

## Top-K问题

Q:给定一个长度为 n 无序数组 `nums` ，**请返回数组中前 k 大的元素。**

最好想的就是排序，排序一般是O(nlogn)

基于堆可以更高效的解决该问题。

> 注意：前K大是建立小根堆，前K小是建立大根堆。
>
> 仔细看下面的算法流程，解答了我多年的疑惑

求前K大思路：

1. 初始化一个小顶堆，其堆顶元素最小。
2. 先将数组的前 K 个元素依次入堆。
3. 从第 K+1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。
   1. 这里因为是小跟堆，所以**每次出去的就是当前最小的元素，因为堆里始终保持K个元素，所以堆里就是前K大个元素。**

复杂度分析：总共有n轮的入堆和出堆，堆最大长度为K，因此时间复杂度为O(nlogk)

## 一个小概念辨析

**数据结构的“堆”与内存管理的“堆”是同一个概念吗？**

**两者不是同一个概念，只是碰巧都叫堆**。计算机系统内存中的堆是动态内存分配的一部分，程序在运行时可以使用它来存储数据。程序可以请求一定量的堆内存，用于存储如对象和数组等复杂结构。当这些数据不再需要时，程序需要释放这些内存，以防止内存泄露。相较于栈内存，堆内存的管理和使用需要更谨慎，不恰当的使用可能会导致内存泄露和野指针等问题。