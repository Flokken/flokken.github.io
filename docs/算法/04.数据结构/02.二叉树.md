---
title: 二叉树
date: 2023-10-29
tags: 
  - null
categories:  
  - 算法
  - 数据结构		
---

> 参考：
>
> 《黑马数据结构2023》
>
> **[Hello 算法][https://www.hello-algo.com/]**

二叉树是这么一种树状结构：每个节点最多有两个孩子，左孩子和右孩子

重要的二叉树结构

* 完全二叉树（complete binary tree）是一种二叉树结构，除最后一层以外，每一层都必须填满，填充时要遵从先左后右
* 平衡二叉树（balance binary tree）是一种二叉树结构，其中每个节点的左右子树高度相差不超过 1

## 1 存储

存储方式分为两种

1. 定义树节点与左、右孩子引用（TreeNode）
2. 使用数组，若以 0 作为树的根，索引可以通过如下方式计算
   * 父 = floor((子 - 1) / 2)
   * 左孩子 = 父 * 2 + 1
   * 右孩子 = 父 * 2 + 2

二叉树节点一般定义为这样

```java
public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
          this.left = left;
          this.right = right;
      }
 }
```



## 2 遍历

遍历也分为两种

1. 广度优先遍历（Breadth-first order）：尽可能先访问距离根最近的节点，也称为层序遍历
2. 深度优先遍历（Depth-first order）：对于二叉树，可以进一步分成三种（要深入到叶子节点）
   1. pre-order 前序遍历，对于每一棵子树，先访问该节点，然后是左子树，最后是右子树
   2. in-order 中序遍历，对于每一棵子树，先访问左子树，然后是该节点，最后是右子树
   3. post-order 后序遍历，对于每一棵子树，先访问左子树，然后是右子树，最后是该节点

### 广度优先

![image-20230216153607396](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230216153607396.png)

| 本轮开始时队列 | 本轮访问节点 |
| -------------- | ------------ |
| [1]            | 1            |
| [2, 3]         | 2            |
| [3, 4]         | 3            |
| [4, 5, 6]      | 4            |
| [5, 6]         | 5            |
| [6, 7, 8]      | 6            |
| [7, 8]         | 7            |
| [8]            | 8            |
| []             |              |

1. 初始化，将根节点加入队列
2. 循环处理队列中每个节点，直至队列为空
3. 每次循环内处理节点后，将它的孩子节点（即下一层的节点）加入队列

> 注意
>
> * 以上用队列来层序遍历是针对  TreeNode 这种方式表示的二叉树
>
> * 对于数组表现的二叉树，则直接遍历数组即可，自然为层序遍历的顺序

广度优先（BFS）实现如下:

~~~java
void bfs(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}
//输出:[1,2,3,4,5,6,7,8]
~~~

#### 例题：层序遍历

> [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

注意，bfs输出的是一维数组，但是这里需要二维数组，第二维是每一层的节点。所以需要稍微修改一下代码。**我们每次while时将queue中的数据全部出栈，刚好就是那一层的节点**

![img](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif)

~~~java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new ArrayDeque<>();
    if (root != null) {
        queue.add(root);
    }
    while (!queue.isEmpty()) {
        int n = queue.size();
        List<Integer> level = new ArrayList<>();
        for (int i = 0; i < n; i++) { 
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        res.add(level);
    }
    return res;
}
//输出：[[1]  ,[2,3],[4,5,6],[7,8,9]]
~~~

> [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
>
> 这道题稍微改一点点二叉树层序遍历，因为最右边的节点肯定层序遍历中最后出栈的那个

~~~java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root==null){
            return res;
        }
        Queue<TreeNode>queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int size =queue.size();
            for(int i=0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
                if(i==size-1){
                    res.add(node.val);
                }
            }
        }
        return res;

    }
     
}
~~~

### 深度优先（前中后）

![image-20230221110443230](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230221110443230.png)

| 栈暂存    | 已处理                                     | 前序遍历 | 中序遍历 |
| --------- | ------------------------------------------ | -------- | -------- |
| [1]       | 1 ✔️ 左💤 右💤                                | 1        |          |
| [1, 2]    | 2✔️ 左💤 右💤<br />1✔️ 左💤 右💤                 | 2        |          |
| [1, 2, 4] | 4✔️ 左✔️ 右✔️<br />2✔️ 左💤 右💤<br />1✔️ 左💤 右💤 | 4        | 4        |
| [1, 2]    | 2✔️ 左✔️ 右✔️<br />1✔️ 左💤 右💤                 |          | 2        |
| [1]       | 1✔️ 左✔️ 右💤                                 |          | 1        |
| [1, 3]    | 3✔️ 左💤 右💤<br />1✔️ 左✔️ 右💤                 | 3        |          |
| [1, 3, 5] | 5✔️ 左✔️ 右✔️<br />3✔️ 左💤 右💤<br />1✔️ 左✔️ 右💤 | 5        | 5        |
| [1, 3]    | 3✔️ 左✔️ 右💤<br />1✔️ 左✔️ 右💤                 |          | 3        |
| [1, 3, 6] | 6✔️ 左✔️ 右✔️<br />3✔️ 左✔️ 右💤<br />1✔️ 左✔️ 右💤 | 6        | 6        |
| [1, 3]    | 3✔️ 左✔️ 右✔️<br />1✔️ 左✔️ 右💤                 |          |          |
| [1]       | 1✔️ 左✔️ 右✔️                                 |          |          |
| []        |                                            |          |          |

#### 递归实现

```java
/**
 * <h3>前序遍历</h3>
 * @param node 节点
 */
static void preOrder(TreeNode node) {
    if (node == null) {
        return;
    }
    System.out.print(node.val + "\t"); // 值
    preOrder(node.left); // 左
    preOrder(node.right); // 右
}

/**
 * <h3>中序遍历</h3>
 * @param node 节点
 */
static void inOrder(TreeNode node) {
    if (node == null) {
        return;
    }
    inOrder(node.left); // 左
    System.out.print(node.val + "\t"); // 值
    inOrder(node.right); // 右
}

/**
 * <h3>后序遍历</h3>
 * @param node 节点
 */
static void postOrder(TreeNode node) {
    if (node == null) {
        return;
    }
    postOrder(node.left); // 左
    postOrder(node.right); // 右
    System.out.print(node.val + "\t"); // 值
}
```

#### 非递归实现

**前序遍历**

```java
LinkedListStack<TreeNode> stack = new LinkedListStack<>();
TreeNode curr = root;

while (!stack.isEmpty() || curr != null) {
    if (curr != null) {
        stack.push(curr);
        System.out.println(curr);
        curr = curr.left;
    } else {
        TreeNode pop = stack.pop();
        curr = pop.right;
    }

}
```

**中序遍历**

```java
LinkedListStack<TreeNode> stack = new LinkedListStack<>();
TreeNode curr = root;

while (!stack.isEmpty() || curr != null) {
    if (curr != null) {
        stack.push(curr);
        curr = curr.left;
    } else {
        TreeNode pop = stack.pop();
        System.out.println(pop);
        curr = pop.right;
    }
}
```

**后序遍历**

```java
LinkedListStack<TreeNode> stack = new LinkedListStack<>();
TreeNode curr = root;
TreeNode pop = null;

while (!stack.isEmpty() || curr != null) {
    if (curr != null) {
        stack.push(curr);
        curr = curr.left;
    } else {
        TreeNode peek = stack.peek();
        if (peek.right == null || peek.right == pop) {
            pop = stack.pop();
            System.out.println(pop);
        } else {
            curr = peek.right;
        }
    }
}
```

对于后序遍历，向回走时，需要处理完右子树才能 pop 出栈。如何知道右子树处理完成呢？

* 如果栈顶元素的 $right \equiv null$ 表示没啥可处理的，可以出栈

* 如果栈顶元素的 $right \neq null$，

  * 那么使用 lastPop 记录最近出栈的节点，即表示从这个节点向回走
  * 如果栈顶元素的 $right==lastPop$ 此时应当出栈

对于前、中两种遍历，实际以上代码从右子树向回走时，并未走完全程（stack 提前出栈了）后序遍历以上代码是走完全程了

## 3 一些概念

> 都是指二叉树里的概念

- 「根节点 root node」：位于二叉树顶层的节点，没有父节点。
- 「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 None 。
- 「边 edge」：连接两个节点的线段，即节点引用（指针）。
- **节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。**
  - 所以节点的层应该是深度加一，不过了leetcode里深度要加一，所以才和层一样
- 节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。
- 二叉树的「高度 height」：**从根节点到最远叶节点所经过的边的数量。**
- 节点的「深度 depth」：**从根节点到该节点所经过的边的数量**。
- 节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。
- 二叉树的直径：是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

>请注意，我们通常将“高度”和“深度”定义为“走过边的数量”，
>
>**但有些题目或教材可能会将其定义为“走过节点的数量”。在这种情况下，高度和深度都需要加 1 (leetcode里的题目就需要加一)。**

![二叉树的常用术语](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/binary_tree_terminology.png)

### 习题

#### 二叉树的深度

[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

非常经典也简单的题。用dfs在遍历树的过程中，顺便求深度。

首先我们要知道二叉树深度是Max(左子树深度，右子树深度)。

具体递归写法：

- 如果root ==null,直接返回
- 否则求当前节点的左边的深度，右子树深度
- 返回两者最大值加1

```java
class Solution {
    public int maxDepth(TreeNode root) {
       if(root==null){
           return 0;
       }
       int L=  maxDepth(root.left);
       int R = maxDepth(root.right);
       return Math.max(L,R)+1;   
    }
}
```

#### 二叉树的直径

>[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
>
>二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。
>
>两节点之间路径的 **长度** 由它们之间边数表示

~~~java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        dpeth(root);
        return ans-1;
    }
    public int dpeth(TreeNode node){//求节点的深度的过程中顺便求出直径
        if(node == null){
            return 0;
        }
        int L = dpeth(node.left);
        int R = dpeth(node.right);
        ans = Math.max(ans,L+R+1);//都是回溯的时候计算深度，这里加1，详细理解可以去看求树的深度
        return Math.max(L,R)+1;//注意返回的是这个节点的深度
        }
}
~~~

#### 对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231228222826392.png" alt="image-20231228222826392" style="zoom:67%;" />

**思路：**

如果同时满足下面的条件，两个树互为镜像：
它们的两个根结点具有相同的值
**每个树的右子树都与另一个树的左子树镜像对**

所以我们可以维护两个指针，都自顶向下的递归的遍历树，
区别是两个指针更新的左右子树是刚好相反的，这样就能满足镜像对比了

**写法和相同二叉树很像**

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root,root);
    }
    public boolean check(TreeNode p,TreeNode q){
        if(p==null &&q==null){
            return true;
        }
        if(p==null||q==null){//一个为null，另一个不是，肯定是null
            return false;
        }
        if(p.val!=q.val) return false;
        return check(p.left,q.right)&&check(p.right,q.left);//互为镜像的方法更新

    }
}
```



#### 二叉树的最近公共祖先

> [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
>
> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。
>
> **祖先的定义**，若节点p在节点root的左右子树中，**或者root=p**，那么p是root的祖先。
> **最近公共祖先**：如果节点p，q的祖先表示为x，那么x中深度最大（离p，q）最近的节点，就是最近公共祖先。
> 注意q是p的子孙节点这种情况，那么p就是p,q的最终公共主线。

假设x是最近公共祖先，那么可能有这么几种情况。



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240101185144757.png" style="zoom:80%;" />



## 公共祖先

### 236 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

> LCA :最近公共祖先

![image-20240226172333193](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240226172333193.png)

思路

分类讨论：

**当前节点是空节点，p，q 返回当前节点**

> 这仍然是在归的过程中求解，我们先递归到p或者q或者null，然后当前节点根据返回的节点进行判断

**其他节点**

- 左右子树都找到: 返回当前节点
  - 找到的意思是找到p或者q

- 只有左子树找到: 返回递归左子树的结点
- 只有右子树找到：返回递归右子树的结点
- 左右子树都没有找到: 返回空节点
- 

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240403165601950.png" alt="image-20240403165601950" style="zoom:67%;" />

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return dfs(root,p,q);
    }
    public TreeNode dfs(TreeNode root, TreeNode p, TreeNode q){
        if(root==null||root==p||root==q) return root;
        TreeNode left = dfs(root.left,p,q);
        TreeNode right = dfs(root.right,p,q);
        if(left!=null&&right==null) return left;
        if(right!=null&&left==null) return right;
        if(right!=null&&left!=null) return root;
        //两边都没找到
        return null;

    }
}
```

### 235 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

思路

直接交上一题的代码也可以过，但是这是二叉搜索树，所以可以有更简洁的做法。

分类讨论

- p,q都在左子树，返回左子树递归节点
  - p,q都小于当前节点

- p,q都在右子树，返回右子树递归节点
  - p,q都大于当前节点

- 其他情况，返回当前节点
  - p和q分别在左右子树
  - 当前节点是p
  - 当前节点是q

> Question：当前节点是空节点(需要判断吗?)，
>
> Answer： 因为题目要求根节点不为空，而p,q也不能为空，根据下面的讨论，当前节点肯定也不为空，所以绝对不会返回空，所以不用判空
>
> $Question:$​为什么上一题需要判断呢?
>
> $Answer:$因为在root时，我们无法确定p，q的情况（同在一遍或者两边），只能都去找，**如果一边没有，就只能返回空**

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return dfs(root,p,q);
    }
    public TreeNode dfs(TreeNode root,TreeNode p, TreeNode q){
        if(root==p||root==q) return root;
        int x=root.val;
        if(p.val<x&&q.val<x) return dfs(root.left,p,q);
        if(p.val>x && q.val>x) return dfs(root.right,p,q);
        return root;
    }
}
```

### 练习

#### 1123. 最深叶节点的最近公共祖先

[1123. 最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)

![image-20240403172954932](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240403172954932.png)

最大深度叶子节点不在同一子树

![image-20240403173837391](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240403173837391.png)

最大深度叶子节点在同一子树

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240403173921902.png"/>

**注意，对于单个最大深度叶子节点来说，最近公共祖先他自己**

![image-20240403191557324](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240403191557324.png)





思路：

分类讨论。

> 这是基于[归]的

首先我们需要递归到叶子节点才知道他们的深度，然后可以发现

- 如果当前节点是叶子节点
  - 如果是最大深度叶子节点，我们直接返回他自己（这就是最近公共祖先）
  - 如果不是返回null
- 如果当前节点是中间节点
  - 如果其左右儿子中找到了最大深度叶子节点，那么返回其左儿子/右儿子
  - 如果都没找到，返回null
  - 如果其左右儿子都找到了最大深度叶子节点，返回当前节点
- 如果当前节点是空，那么直接返回空

所以需要两次dfs

- 需要一次dfs找到最大深度
- 一次返回公共祖先

找最大公共祖先应该是后序遍历

```java
class Solution {
    int mx=0;
    public TreeNode lcaDeepestLeaves(TreeNode root) {
        depth(root,0);
        return dfs(root,0);
    }
    public void depth(TreeNode root,int d){
        if(root==null) return;
        mx=Math.max(mx,d);
        depth(root.left,d+1);
        depth(root.right,d+1);
    }
    public TreeNode dfs(TreeNode root,int d){
        if(root==null) return null;
        if(root.left==null&&root.right==null){
            return d!=mx?null:root;
        }
        TreeNode left = dfs(root.left,d+1);
        TreeNode right = dfs(root.right,d+1);
        if(left!=null&&right!=null) return root;
        if(left!=null) return left;
        if(right!=null) return right;
        return null;
    }
}
```

拓展：

看了题解之后，发现有更简单的分类方法

> 灵神题解:https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/solutions/2428724/liang-chong-di-gui-si-lu-pythonjavacgojs-xxnk

对于本题，如果左子树的最大深度比右子树的大，那么最深叶结点就只在左子树中，所以最近公共祖先也只在左子树中。

但是我们递归时不确定当前是否是最大深度，所以需要不断更新

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240403193610979.png" alt="image-20240403193610979" style="zoom:80%;" />

```java
class Solution {
    private TreeNode ans;
    private int maxDepth = -1; // 全局最大深度

    public TreeNode lcaDeepestLeaves(TreeNode root) {
        dfs(root, 0);
        return ans;
    }

    private int dfs(TreeNode node, int depth) {
        if (node == null) {
            maxDepth = Math.max(maxDepth, depth); // 维护全局最大深度
            return depth;
        }
        int leftMaxDepth = dfs(node.left, depth + 1); // 获取左子树最深叶节点的深度
        int rightMaxDepth = dfs(node.right, depth + 1); // 获取右子树最深叶节点的深度
        if (leftMaxDepth == rightMaxDepth && leftMaxDepth == maxDepth)
            ans = node;
        return Math.max(leftMaxDepth, rightMaxDepth); // 当前子树最深叶节点的深度
    }
}
```

#### 2096. 从二叉树一个节点到另一个节点每一步的方向

> 1800分

[2096. 从二叉树一个节点到另一个节点每一步的方向](https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/)

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240403193709715.png" alt="image-20240403193709715" style="zoom:80%;" />

思路：

比较容易想到，对于s,t的最短路径，假设s,t的最近公共祖先是x,那么就是s->x->t。

所以最直白的想法，我们应该先找到两个点的最近公共祖先，然后从这个祖先分别在去找其到s的路径，和到t的路径。

- 并且x->s的路径是反的，所以都要修改为U，也就是走父节点

**暴力做法：**

三次dfs

- 一次求祖先
- 一次求祖先到s路径
  - 构造路径，所以这里应该使用回溯
- 一次求祖先到t的路径
  - 构造路径，所以这里应该使用回溯

拼接答案即可

两次dfs的做法：

假设根节点是root，开始节点s，结束节点t，公共祖先x。

那么可以dfs一次求root>s,dfs一次求root->t

**那么这两个路径的最长公共前缀就是root->x(根节点到最近公共祖先)**

- 那么root->s  -  root-x=   x->s，也就是祖先到s的路径
- root-t  - root-x =  x->t  祖先到t的路径

这里使用最好想的三次dfs做法

```java
class Solution {
    StringBuilder s1= new StringBuilder();//s->x
    StringBuilder s2 = new  StringBuilder();//x->t
    StringBuilder path = new StringBuilder();
    public String getDirections(TreeNode root, int startValue, int destValue) {
        TreeNode node= lca(root,startValue,destValue);//找祖先
        dfs1(node,startValue);
        dfs2(node,destValue);
        return path.toString();

    }
    public TreeNode lca(TreeNode root, int s, int t){
        if(root==null||root.val==s||root.val==t) return root;
        TreeNode left = lca(root.left,s,t);
        TreeNode right = lca(root.right,s,t);
        if(left!=null&&right!=null) return root;
        if(left!=null) return left;
        if(right!=null) return right;
        return null;
    }
    public void dfs1(TreeNode root, int s){
        if(root==null) return;
        if(root.val==s){
            path.append(s1);
            return;
        }
        //我们需要的是从s到祖先，所以都换成U
        s1.append('U');
        dfs1(root.left,s);
        s1.deleteCharAt(s1.length()-1);

        s1.append('U');
        dfs1(root.right,s);
        s1.deleteCharAt(s1.length()-1);
    }
    public void dfs2(TreeNode root, int t){
        if(root==null) return;
        if(root.val==t){
            path.append(s2);
            return;
        }
        s2.append('L');
        dfs2(root.left,t);
        s2.deleteCharAt(s2.length()-1);

        s2.append('R');
        dfs2(root.right,t);
        s2.deleteCharAt(s2.length()-1);
    }
}
```

