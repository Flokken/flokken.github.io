---
title: 栈
date: 2023-11-13
tags: 
  - null
categories:  
  - 算法
  - 数据结构		
---

## java中的栈

java中有Stack，但是已经`deprecated`了,现在在java中使用栈，对应的数据结构是接口类`Deque`,即双端队列。

> Stack继承自Vector，Vector都弃用了

下面是jdk6文档的解释：

一个线性 collection，支持在两端插入和移除元素。名称 *deque* 是“double ended  queue（双端队列）”的缩写，通常读为“deck”。大多数 `Deque`  实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 

### 常用方法

| 方法名                     | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| void addLast(E e)          | 将指定元素插入此双端队列的末尾                               |
| void addFirst(E e)         | 将指定元素插入此双端队列的开头                               |
| boolean contains(Object o) | 如果此双端队列包含指定元素，则返回 `true`。                  |
| E  peek()                  | 获取，但不移除此双端队列所表示的队列的头部(第一个元素)；如果此双端队列为空，则返回 `null`。 |
| E  peekFirst()             | 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 `null`。 |
| E  peekLast()              | 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 `null`。 |
| E  poll()                  | 获取并移除此双端队列所表示的队列的头部(第一个元素)；；如果此双端队列为空，则返回 `null`。 |
| E  pollFirst()             | 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 `null`。 |
| E  pollLast()              | 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 `null`。 |
| boolean isEmpty()          | 如果双端队列为空，返回true                                   |
| void push(E e)             | 将一个元素推入此双端队列所表示的堆栈（换句话说，此双端队列的头部） |
| E pop()                    | 从此双端队列所表示的堆栈中弹出一个元素。                     |
| int size()                 | 返回元素个数                                                 |

常用来说，我们定义一个双端队列表示栈：

~~~java
Deque<Integer>stack = new ArrayDeque<Integer>;
~~~

那么：

- 查看栈顶：`peek`
- 出栈: 	`pop/poll`
- 入栈  `push`

>下面一套作用相同
>
>- 查看栈顶：`peekLast()`
>- 出栈: 	`pollLast()`
>- 入栈  `addLast()`
>
>

## 单调栈

> [参考](https://blog.csdn.net/m0_73096566/article/details/129232233)

单调栈，也就是栈内元素具有单调性。如果是栈底元素到栈顶元素单调递增，则是递增栈；如果是栈底元素到栈顶元素单调递减，就是递减栈。

> 注意有些地方好像不是栈底到栈顶，反而是栈顶到栈底，这样就反过来了，但是我们学习需要统一，就认为是栈底到栈顶把。**而且从栈底到栈顶比较符合我们的直觉思维。**

这样不太直观，我们直接看图

![image-20231115222229869](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231115222229869.png)

**单调递减栈**：只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。

>这样才能保证从栈底到栈顶的元素值是单调递减的。

**单调递增栈**：只有比栈顶元素大的元素才能直接进栈，否则需要先将栈中比当前元素大的元素出栈，再将当前元素入栈。

>这样才能保证栈底到栈顶的元素值是单调递增的。

**举例：**

我们以数组[2,4,7,5,1]这个数组模拟一下单调递增栈的进展出栈过程。

- 数组元素为[2,5,4,7,1,8]，遍历顺序为从左到右

| 第i步 | 待插入元素 | 操作             | 栈      |
| ----- | ---------- | ---------------- | ------- |
| 1     | 2          | 2入栈            | [2]     |
| 2     | 5          | 5入栈            | [2,5]   |
| 3     | 4          | 5出栈，4入栈     | [2,4]   |
| 4     | 7          | 7入栈            | [2,4,7] |
| 5     | 1          | 7,4,2出栈，1入栈 | [1]     |
| 6     | 8          | 8入栈            | [1,8]   |

注意：**单调栈常常用来找该元素左边/右边的第一个大/小的元素的位置，那么应该压入下标而不是元素本身，这样才能求解。当然也有例外**

单调栈常见问题有四种情况：

**向左找第一个比当前元素大的数。**

从左到右遍历元素，构造单调递减栈：

- 因为是递减栈，**所以遇到当前元素< 栈顶元素时弹栈，直到栈顶元素>当前元素**，一个元素左侧第一个比它大的元素就是将其插入栈时的栈顶元素。
- 如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。

**向左找第一个比当前元素小的数。**

从左到右遍历元素，构造单调递增栈：

- 因为是递增栈，**所以遇到当前元素>栈顶元素时弹栈，直到栈顶元素<当前元素**，所以一个元素左侧第一个比它小的元素就是将其插入栈时的栈顶元素。
- 如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。

**向右找第一个比当前元素大的数。**

从右到左遍历元素，构造单调递减栈：

- 因为是递减栈，**所以遇到当前元素< 栈顶元素时弹栈，直到栈顶元素>当前元素**，一个元素左侧第一个比它大的元素就是将其插入栈时的栈顶元素。
- 如果该元素没有被弹出栈，则说明右侧不存在比当前元素大的元素。

**向右找第一个比自身当前元素小的数。**

从右到左遍历元素，构造单调递增栈：

- 因为是递增栈，**所以遇到当前元素> 栈顶元素时弹栈，直到栈顶元素<当前元素**，所以一个元素左侧第一个比它小的元素就是将其插入栈时的栈顶元素。

- 如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。


总结一下：

- **从右开始找数是从右往左，从左开始找数是从左往右**
- 查找 **「比当前元素大的元素」** 就用 **单调递减栈**，查找 **「比当前元素小的元素」** 就用 **单调递增栈**。

细节：

数组中有相等的元素，如何处理？

要根据情况而定，读题提炼出，需要的是严格递增的栈还是可以容易相等元素的栈。

## 例题

1.[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

向右找第一个大于当前元素，递减栈

细节：本体要求是找到第一个大于，所以是`>`时弹栈，才能保证弹出来的都符合要求

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //递减栈
            int n=temperatures.length;
            int []ans = new int[n];
            Deque<Integer>stack = new ArrayDeque<>();
            for(int i=0;i<n;i++){
                while(!stack.isEmpty()&&temperatures[i]>temperatures[stack.peekLast()]){
                    int t = stack.pollLast();
                    ans[t]=i-t;
                }
                stack.addLast(i);
            }
            return ans;
    }
}
```

**单调栈的经典例题**

[1944. 队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/)
