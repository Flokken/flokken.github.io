---
title: springboot3.0.6连接mongoDB5
date: 2023-05-08
tags: 
  - null
categories: 
  - 深度学习
  - 入门介绍
---

## MongoDB Server安装

> 可参考文档
>
> https://springdoc.cn/spring-data-mongodb/

首先在服务器上安装mongdb server

下载tgz文件，解压后就可以使用

![image-20230504162138374](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230504162138374.png)

配置

~~~shell
#首先要把他上传到服务器，然后解压和移动位置
cd /use/wj
tar -xf mongodb-linux-x86_64-rhel70-4.4.21.tgz
mv mongodb-linux-x86_64-rhel70-4.4.21/ /usr/local/mongodb-4.4.21
cd /usr/local/mongodb-4.4.21
mkdir logs
touch mongodb.log
mkdir data

#之后是编写配置文件
vim mongodb.conf
#端口号
port=27017
#db目录
dbpath=/usr/local/mongodb-4.4.21/data
#日志目录
logpath=/usr/local/mongodb-4.4.21/logs/mongodb.log
#后台
fork=true
#日志输出
logappend=true
#允许远程IP连接
bind_ip=0.0.0.0
#auth = true
#加到环境目录，可要可不要
#export PATH=/usr/local/mongodb-5.0.17/bin/bin:$PATH
#启动
./mongod -f mongodb.conf 
~~~

这样子就启动成功

![image-20230504162403826](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230504162403826.png)

### 开启认证

mongodb 默认无认证，需要先创建用户，再在配置文件里开启认证`auth=true`

在bin目录下，通过./mongo可以进入shell

~~~shell
use admin
db.createUser(
{
   user: "inet_admin",
   pwd: "inet_store_2018@!", 
   roles: [ { role: "root", db: "admin" } ]
})
db.shutdownServer()
exit
~~~

注意db.shutdownServer(),可以在shell中关闭服务器。

再在配置文件里开启认证`auth=true`

重新启动服务器./mongod -f mongodb.conf 

### 导入数据

配合使用studio 3T和navicat



### 连接

spring-data-mongodb 文档,这里也可以看到对应的driver和server版本

> https://docs.spring.io/spring-data/mongodb/docs/3.4.1/reference/html/
>

创建MongoTemplate

>https://blog.csdn.net/weixin_43454365/article/details/127949574

~~~java
//MongoConfig

package com.inet.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.MongoDatabaseFactory;
import org.springframework.data.mongodb.core.MongoDatabaseFactorySupport;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper;
import org.springframework.data.mongodb.core.convert.MappingMongoConverter;

import javax.annotation.Resource;

//使用springboot连接需要重写Mongotemplate，并且注入，因为官方包没有提供bean对象
@Configuration
public class MongoConfig {
    @Resource
    private MongoDatabaseFactorySupport mongoDatabaseFactorySupport;

    @Resource
    private MappingMongoConverter mappingMongoConverter;

    @Bean
    public MongoTemplate mongoTemplate(){
        mappingMongoConverter.setTypeMapper(new DefaultMongoTypeMapper(null));
        MongoTemplate mongoTemplate = new MongoTemplate(mongoDatabaseFactorySupport,mappingMongoConverter);
        return mongoTemplate;
    }
}
~~~

~~~java
package com.inet.entity;


import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

@Document(collection = "users")
public class User {

     public String getName() {
          return name;
     }

     public void setName(String name) {
          this.name = name;
     }

     public String getAge() {
          return age;
     }

     public void setAge(String age) {
          this.age = age;
     }


     @Field(value = "name")
     private String name;

     @Field(value = "age")
     private String age;

     public String getDate() {
          return date;
     }

     public void setDate(String date) {
          this.date = date;
     }

     @Override
     public String toString() {
          return "User{" +
                  "name='" + name + '\'' +
                  ", age='" + age + '\'' +
                  ", date='" + date + '\'' +
                  '}';
     }

     @Field(value = "date")
     private String date;
}

~~~

~~~java
//test
package com.inet;

import com.inet.entity.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.core.MongoTemplate;

import java.text.SimpleDateFormat;
import java.util.Date;

@SpringBootTest
class SbomBackendApplicationTests {

	@Autowired
	private MongoTemplate mongoTemplate;

	@Test
	void insertDataTest(){
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		User user = new User();
		user.setName("wj");
		user.setAge("22");
		user.setDate(simpleDateFormat.format(new Date()));
		mongoTemplate.insert(user,"users");
	}

}

~~~



### 使用到的注解

#### @Resource

@Resource 的作用相当于 @Autowired，只不过 @Autowired 按 byType 自动注入，面 @Resource 默认按 byName 自动注入罢了。@Resource 有两个属性是比较重要的，分别是 name 和 type，Spring 将 @Resource 注释的 name 属性解析为 Bean 的名字，而 type 属性则解析为 Bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不指定 name 也不指定 type 属性，**这时将通过反射机制使用 byName 自动注入策略。**

#### @Value

在Springboot中，该注解作用是将我们配置文件的属性读出来，有**@Value(“${}”)**和**@Value(“#{}”)**两种方式。

注意，使用了@Value的类，只能用@AutoWired来定义，而不能new()一个出来。

假设`application.yml`中数据如下：

~~~java
hugegraph:
  server:
    graph-name: sbom
    host: 10.245.142.233
    port: 8280

~~~

那么读取可以是

~~~java
@Configuration
public class HugeGraphConfig {
    @Value(value = "${hugegraph.server.graph-name}")
    private String graphName;

    @Value(value = "${hugegraph.server.host}")
    private String host;

    @Value(value = "${hugegraph.server.port}")
    private String port;

    @Bean
    public HugeClient hugeClient(){
        System.out.println("http://"+host+":"+port+"/"+graphName);
        return HugeClient.builder("http://"+host+":"+port,graphName).build();
    }
}
~~~

##### @Value注入的对象为null

>https://blog.csdn.net/ITzhongzi/article/details/105489035
>
>https://blog.csdn.net/SugarXiXixi/article/details/112005351



如果我在service/impl下写一个类，如下

~~~java
package com.inet.service.impl;

import com.inet.config.HugeGraphConfig;
import org.apache.hugegraph.driver.HugeClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class Test {
    @Autowired
    HugeGraphConfig hugeGraphConfig ;
    public  void process() {
        System.out.println(hugeGraphConfig.hugeClient());

    }

    public static void main(String[] args) {
        Test tt = new Test();
        tt.process();
    }

}

~~~

运行报错，并且什么都没有打印，

![image-20230508221524692](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230508221524692.png)

> 这里报错是hugegraphConfig都没有自动装配成功
>
> @**Autowired 注入为null**的原因可能有以下几种：（1）该类没有托管给spring管理，需要在类上添加@Component或其他注解[1](https://blog.csdn.net/qq_42572245/article/details/116199878)[2](https://blog.csdn.net/huwei2003/article/details/117512114)[3](https://blog.csdn.net/qq_42479528/article/details/120131668)[4](https://www.cnblogs.com/weibanggang/p/11373243.html) （2）该类有被new出来的实例，new过的对象不会交给spring容器管理，无法注入[1](https://blog.csdn.net/qq_42572245/article/details/116199878)[2](https://blog.csdn.net/huwei2003/article/details/117512114)[3](https://blog.csdn.net/qq_42479528/article/details/120131668)[4](https://www.cnblogs.com/weibanggang/p/11373243.html) （3）该类继承了某个第三方框架，框架内部创建了该类的实例，导致@Component不起作用[3](https://blog.csdn.net/qq_42479528/article/details/120131668)[5](https://huaweicloud.csdn.net/63874ef4dacf622b8df8aa2c.html) （4）注入静态变量，静态变量不是对象的属性，而是类的属性，spring是基于对象的依赖注入[4](https://www.cnblogs.com/weibanggang/p/11373243.html)。

**但是，在springtest下这样写，就可以装配成功。**

猜想：肯定跟java类的加载顺序2或者说spring Bean的装载顺序相关。

#### @TODO

以后补充到底是为什么