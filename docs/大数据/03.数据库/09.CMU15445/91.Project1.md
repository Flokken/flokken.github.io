---
title: Project#1
date: 2023-12-10
tags: 
  - C++
categories: 
  - 大数据
  - CMU15445
---

## Task1 实现LRU-K

> [LRU-K论文](https://dl.acm.org/doi/epdf/10.1145/170036.170081)
>
> [一篇比较详细的博客](https://blog.csdn.net/AntiO2/article/details/128439155)
>
> [比较简述的博客](https://blog.csdn.net/jjclove/article/details/124511119)

这里说一下大概LRU-K的实现。这里先看一下他的简介

```
The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with less than k historical accesses is given +inf as its backward k-distance. When multipe frames have +inf backward k-distance, the replacer evicts the frame with the earliest timestamp.
```

大意是说，LRU-K算法的Replacer会选择具有最大的`backward k-distance`的frame移除，`backward k-distance`等于当**前时间减去第k次访问访问时间**。

其实LRU-K的核心就是：

- 只有某个页的记录到了k次以上，才会考虑让他留的久一点，把他加入缓存队列，然后根据`backward k-distance`删除
  - 当要删除缓存队列的page时，**当前now是固定的，而`backward k-distance`与第k次访问时间负相关，也就是越早访问的页，他的`backward k-distance`越大，所以先删除，所以此时实际上就已经退化了成LRU了。**
- 如果某页的访问次数不到k次，直接给他的`backward k-distance`加上`inf`,也就是让其丢弃优先级最高（因为最大的先丢弃）。
  - 如果有多个`inf`的页，那么删除其`timestamp`最早的那个，其实就是FIFO

> 所以LRU算法其实就是LRU-k的k等于1时的特殊情况。
>
> 如果有inf就删inf的，没有的话就按照lru删除缓存队列的

数据结构：

两个队列

- 一个历史队列维护页的访问历史，即`history_list`
  - 为了方便操作，我们还需定义一个map，存储id到队列位置的映射
- 一个缓存队列维护访问次数达到k的索引。即`cache_list`
  - 为了方便操作，我们还需定义一个map，存储id到队列位置的映射

```C++
   size_t curr_size_{0};//当前存放的可驱除的页面数量
   size_t replacer_size_;//整个主存的大小
   size_t k_;  //lru-k中k的值


   std::mutex latch_;
   std::unordered_map<frame_id_t,size_t>access_count_;//记录所有页的访问次数

   std::list<frame_id_t>history_list_;//访问次数不到k次的页
   //这个页面的id对应的上面这个队列迭代器的map
   std::unordered_map<frame_id_t, std::list<frame_id_t>::iterator> history_map_;

   std::list<frame_id_t>cache_list_;//访问次数到达k次的页
    //这个页面的id对应的上面这个队列迭代器的map
   std::unordered_map<frame_id_t,std::list<frame_id_t>::iterator>cache_map_;

   std::unordered_map<frame_id_t,bool> is_evictable_;//记录页是否可以被驱除
```

算法流程:

- 数据第一次被访问，加入到访问历史列表；
- 如果数据在访问历史列表里后没有达到K次访问，则按照FIFO淘汰；
- 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；
- 缓存数据队列中被再次访问后，需要更新其优先级
- 需要淘汰数据时，首先淘汰历史队列中的数据，历史队列数据为空，才淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。

**这里注意，维护缓存队列时，我们可以只在队头进行插入，队尾出队，来保证队列元素的顺序，从而避免排序**，具体来说

- 我们插入数据时，插入到队头，那么后面的元素就被移动到队尾，就达到了最早访问的元素优先级最低的要求（最先出队）

**维护历史队列，也是一样的道理**

- 我们插入数据时，插入到队头，那么队尾就是最早访问的元素，出队队尾就满足算法要求的多个inf，时间最早的最先出队

这里让我们实现的是各种功能函数。并且还要实现并发控制。



本地测试之前需要删除Test前面的`Distabled`,也就是改成这样

`TEST(LRUKReplacerTest, SampleTest) {......}`

### Lock

这里统一用一个大锁锁起来，每个函数都一样，调用玩这个函数后，自动释放

```C++
  std::scoped_lock<std::mutex>lock(latch_);
```

### Evict()

根据LRU-K算法，我们首先移除`history_list`里的元素；如果没有，再去移除`cache_list`里的元素。

这里由于我们插入的时候维护其顺序，所以我们直接出队队尾即可（队尾就是优先级最低的元素）。不过由于还有`is_evict`这东西限制，所以我们得从后往前遍历，移除第一个`is_evict==true`的元素。

注意这个函数还要求我们修改传入的引用来返回此处移除的id，也即是`frame_id`时传入的参数，`frame`是我们这次移除的

`*frame_id = frame;`

### RecordAccess()

这里由于我们不维护时间戳，而是通过队列的特性实现，所以稍微麻烦一点。

首先记录`access_count`,根据出现次数与k的关系，有

- 大于k，刷新cache_list中对应page的优先级（具体做法是先移除，再加到队首）
- ==k,移除history_list,加入cache_list
- 小于k，直接加入history_list

### SetEvictable

将指定的frame的属性设置为evictable。

需要注意这个frame原先的属性是否与要设置的属性相同，如果不同，需要更新curr_size_。

### Remove

直接删除指定的frame。**删除时需要判断对应的frame是否存在**，如果存在，检测其evictable属性，来更新curr_size_。

如果不存在，抛出错误

### Size

返回current.size()

