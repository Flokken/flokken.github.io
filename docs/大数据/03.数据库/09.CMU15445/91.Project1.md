---
title: 2022fall Project#1
date: 2023-12-10
tags: 
  - C++
categories: 
  - 大数据
  - CMU15445
---

## Task1 Extendible Hash Table

实现可扩容的通用hash表，当然增删改查的api也需要实现

这个hash表会随着使用，根据使用需求而自动的实现扩容。



## Task2 实现LRU-K

> [LRU-K论文](https://dl.acm.org/doi/epdf/10.1145/170036.170081)
>
> [一篇比较详细的博客](https://blog.csdn.net/AntiO2/article/details/128439155)
>
> [比较简述的博客](https://blog.csdn.net/jjclove/article/details/124511119)

这里说一下大概LRU-K的实现。这里先看一下他的简介

```
The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with less than k historical accesses is given +inf as its backward k-distance. When multipe frames have +inf backward k-distance, the replacer evicts the frame with the earliest timestamp.
```

大意是说，LRU-K算法的Replacer会选择具有最大的`backward k-distance`的frame移除，`backward k-distance`等于当**前时间减去第k次访问访问时间**。

其实LRU-K的核心就是：

- 只有某个页的记录到了k次以上，才会考虑让他留的久一点，把他加入缓存队列，然后根据`backward k-distance`删除
  - 当要删除缓存队列的page时，**当前now是固定的，而`backward k-distance`与第k次访问时间负相关，也就是越早访问的页，他的`backward k-distance`越大，所以先删除，所以此时实际上就已经退化了成LRU了。**
- 如果某页的访问次数不到k次，直接给他的`backward k-distance`加上`inf`,也就是让其丢弃优先级最高（因为最大的先丢弃）。
  - 如果有多个`inf`的页，那么删除其`timestamp`最早的那个，其实就是FIFO

> 所以LRU算法其实就是LRU-k的k等于1时的特殊情况。
>
> 如果有inf就删inf的，没有的话就按照lru删除缓存队列的

数据结构：

两个队列

- 一个历史队列维护页的访问历史，即`history_list`
  - 为了方便操作，我们还需定义一个map，存储id到队列位置的映射
- 一个缓存队列维护访问次数达到k的索引。即`cache_list`
  - 为了方便操作，我们还需定义一个map，存储id到队列位置的映射

```C++
   size_t curr_size_{0};//当前存放的可驱除的页面数量
   size_t replacer_size_;//整个主存的大小
   size_t k_;  //lru-k中k的值


   std::mutex latch_;
   std::unordered_map<frame_id_t,size_t>access_count_;//记录所有页的访问次数

   std::list<frame_id_t>history_list_;//访问次数不到k次的页
   //这个页面的id对应的上面这个队列迭代器的map
   std::unordered_map<frame_id_t, std::list<frame_id_t>::iterator> history_map_;

   std::list<frame_id_t>cache_list_;//访问次数到达k次的页
    //这个页面的id对应的上面这个队列迭代器的map
   std::unordered_map<frame_id_t,std::list<frame_id_t>::iterator>cache_map_;

   std::unordered_map<frame_id_t,bool> is_evictable_;//记录页是否可以被驱除
```

算法流程:

- 数据第一次被访问，加入到访问历史列表；
- 如果数据在访问历史列表里后没有达到K次访问，则按照FIFO淘汰；
- 当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；
- 缓存数据队列中被再次访问后，需要更新其优先级
- 需要淘汰数据时，首先淘汰历史队列中的数据，历史队列数据为空，才淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。

**这里注意，维护缓存队列时，我们可以只在队头进行插入，队尾出队，来保证队列元素的顺序，从而避免排序**，具体来说

- 我们插入数据时，插入到队头，那么后面的元素就被移动到队尾，就达到了最早访问的元素优先级最低的要求（最先出队）

**维护历史队列，也是一样的道理**

- 我们插入数据时，插入到队头，那么队尾就是最早访问的元素，出队队尾就满足算法要求的多个inf，时间最早的最先出队

这里让我们实现的是各种功能函数。并且还要实现并发控制。



本地测试之前需要删除Test前面的`Distabled`,也就是改成这样

`TEST(LRUKReplacerTest, SampleTest) {......}`

### Lock

这里统一用一个大锁锁起来，每个函数都一样，调用玩这个函数后，自动释放

```C++
  std::scoped_lock<std::mutex>lock(latch_);
```

### Evict()

根据LRU-K算法，我们首先移除`history_list`里的元素；如果没有，再去移除`cache_list`里的元素。

这里由于我们插入的时候维护其顺序，所以我们直接出队队尾即可（队尾就是优先级最低的元素）。不过由于还有`is_evict`这东西限制，所以我们得从后往前遍历，移除第一个`is_evict==true`的元素。

注意这个函数还要求我们修改传入的引用来返回此处移除的id，也即是`frame_id`时传入的参数，`frame`是我们这次移除的

`*frame_id = frame;`

### RecordAccess()

这里由于我们不维护时间戳，而是通过队列的特性实现，所以稍微麻烦一点。

首先记录`access_count`,根据出现次数与k的关系，有

- 大于k，刷新cache_list中对应page的优先级（具体做法是先移除，再加到队首）
- ==k,移除history_list,加入cache_list
- 小于k，直接加入history_list

### SetEvictable

将指定的frame的属性设置为evictable。

需要注意这个frame原先的属性是否与要设置的属性相同，如果不同，需要更新curr_size_。

### Remove

直接删除指定的frame。**删除时需要判断对应的frame是否存在**，如果存在，检测其evictable属性，来更新curr_size_。

如果不存在，抛出错误

### Size

返回current.size()



## Task3 Buffer pool Manager  Instance

BufferPoolManager 负责从 DiskManager 获取数据库页并将其存储在内存中。当BufferPoolManager 还需要实现`evict  pages` 以及写入脏页到disk的功能

我们要知道系统的所有内存都由`page`表示，`page`是基本的容器，对应一个固定大小的内存块，用于缓存从disk读取的数据。由于page中的数据的换入换出，同一个page对象可能对应不同的物理块。`page_id`记录page包含的物理page，如果一个page不含物理页，必须标注为`INVALID_PAGE_ID`。

> 内存的页叫frame，disk的页才是page，frame拿来装page的，这里为了方便没有特别写出来

`Pin`:表示固定，具体来说，每个 Page 对象还维护一个计数器，用于记录“固定”该页面的线程数。我感觉可以理解成**引用计数**，有一个地方用了这个页，`pin_count+1`

`Dirty page`:每个`page`还会记录是否为脏页（这是我们要实现从，记录这个page被pin时有没有被修改），如果是的话，必须将脏页写回disk，才能重用这个`page`

**数据结构**：BufferManager类里面都给了，并且有注释。

- `pages`连续的空间（数组形式）表示当前所有的frame，pages是数组首地址（或者说指针）
- `free_list_`记录没有装page的frame
- `page_table_`记录page_id到frame的映射

> page定义在`src/include/storage/page/page.h`，我们可以用他的方法

其实每个函数代码里都有提示，这里我也稍微说一下

### NewPage

获取一个页，需要利用已经提供的`AllocatePage()`获取`page_id`。

> 这里并不是指去申请内存，而是从已有的frame中取出可用的，或者替换出一个页，并给予一个新的`page_id`
>
> diskManager代码在`src/storage/disk/disk_manager.cpp`

- 如果所有的`pin_count`都不为0，表明没有可用的frame，返回`nullptr`
- 如果有没有被引用的页，那么从`free_list_`中取一个空闲的`frame`,
- 如果没有空闲的页，那么我们可以通过LRU-K Replacer的 Evicit方法获取一个可以驱除的`frame_id`。
  - 如果不是脏页，清空，
  - 如果是脏页，调用disk manager的方法协会disk。
  - 最后都需要给新得到的`page`的`pin_count+1`,并且在`page_table`中建立`frame_id`和`page_id`的映射

### FetchPage

从当前空闲的page中获取一个page

### UnpinPage

取消一个页面的固定，更新`is_dirty`参数记录是否被修改

### FlushPage

刷新一个页面，无论其是否固定

### DeletePage

删除一个页，同样需要调用已经提供的`DeallocatePage()`去释放资源。

### FlushAllPage



