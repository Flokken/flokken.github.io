---
title: C++的一些语法
date: 2023-11-28
tags: 
  - C++
categories: 
  - 大数据
  - CMU15445
---

> 开始学习这个课程的时候，我的心情很复杂，认真学习计算机知识最好的时间是大学本科，其次是现在。回过头去看，我发现自己基本上什么也不会。
>
> 本科时卷绩点，卷一些毫无用处的东西，浪费了时间，浪费了精力，也导致了我狭隘的目光。记得21年的时候看知乎，推荐去看国外的课程，那时候却不以为然，浪费了大把时间。如今已经到了23年了，真的马上就业了才想起了主动学习的重要性，才来恶补。
>
> 劝君莫惜金缕衣，劝君惜取少年时。如今回头看20年-22年的自己，的确是虚度了，时不我待啊。

这里只介绍一些如果没做过项目，C++里可能不是很清楚的一些语法。

> 参考：https://subingwen.cn/cplusplus/
>
> <<黑马教程C++>>
>
> C++11
>
> -  [short tutorial](http://www.thegeekstuff.com/2016/02/c-plus-plus-11/) 
> - [cppreference](https://en.cppreference.com/w/) 
>
> 调试工具：gdb
>
> 在ubuntun上装了很久失败，centos一个yum命令搞定，果然不能轴。。。。

## 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

### 程序运行前

在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域

​	**代码区：**

- 存放 CPU 执行的机器指令

- 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

- 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令


​	**全局区：**

- 全局变量和静态变量

- 常量区： const修饰的全局常量  和 字符串常量比如（"aaaa"）

- ==该区域的数据在程序结束后由操作系统释放==.

**示例：**

```c++
//全局变量
int g_a = 10;
int g_b = 10;

//全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main() {

	//局部变量
	int a = 10;
	int b = 10;

	//打印地址
	cout << "局部变量a地址为： " << (int)&a << endl;
	cout << "局部变量b地址为： " << (int)&b << endl;

	cout << "全局变量g_a地址为： " <<  (int)&g_a << endl;
	cout << "全局变量g_b地址为： " <<  (int)&g_b << endl;

	//静态变量
	static int s_a = 10;
	static int s_b = 10;

	cout << "静态变量s_a地址为： " << (int)&s_a << endl;
	cout << "静态变量s_b地址为： " << (int)&s_b << endl;

	cout << "字符串常量地址为： " << (int)&"hello world" << endl;
	cout << "字符串常量地址为： " << (int)&"hello world1" << endl;

	cout << "全局常量c_g_a地址为： " << (int)&c_g_a << endl;
	cout << "全局常量c_g_b地址为： " << (int)&c_g_b << endl;

	const int c_l_a = 10;
	const int c_l_b = 10;
	cout << "局部常量c_l_a地址为： " << (int)&c_l_a << endl;
	cout << "局部常量c_l_b地址为： " << (int)&c_l_b << endl;

	system("pause");

	return 0;
}
```

打印结果：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231129144617000.png" alt="image-20231129144617000" style="zoom:80%;" />



### 程序运行后

> 这里和jvm运行时划分的堆和栈感觉很像

**栈区：**

- 由编译器自动分配释放, 存放函数的参数值,局部变量等

- 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放


**示例：**

```c++
int * func()
{
	int a = 10;
	return &a;
}

int main() {

	int *p = func();

	cout << *p << endl;
	cout << *p << endl;

	system("pause");

	return 0;
}
```

**堆区：**

- 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收

- **在C++中主要利用new在堆区开辟内存**

**示例：**

```c++
int* func()
{
	int* a = new int(10);
	return a;
}

int main() {

	int *p = func();

	cout << *p << endl;
	cout << *p << endl;
    
	system("pause");

	return 0;
}
```

### new与delete操作符

C++中利用==new==操作符在堆区开辟数据（也就是申请空间），释放利用操作符 ==delete==（也就是释放空间）

语法：` new 数据类型`

利用new创建的数据，会返回该数据对应的类型的指针

**示例：开辟数组**

```c++
//堆区开辟数组
int main() {

	int* arr = new int[10];

	for (int i = 0; i < 10; i++)
	{
		arr[i] = i + 100;
	}

	for (int i = 0; i < 10; i++)
	{
		cout << arr[i] << endl;
	}
	//释放数组 delete 后加 []
	delete[] arr;

	system("pause");

	return 0;
}

```

### 引用

作用：在C++里就是给变量起别名。

语法：`数据类型 &别名 = 原名`

本质：在C++内部实现是一个指针常量.

> 所以传引用和传指针是一个效果

```C++
//编译器发现是引用，转换为 int* const ref = &a;
void func(int& ref){
	ref = 100; // ref是引用，转换为*ref = 100
}
int main(){
	int a = 10;
    
    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
	int& ref = a; 
	ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;
    
	cout << "a:" << a << endl;
	cout << "ref:" << ref << endl;
    
	func(a);
    
    
    //特殊，常量引用，引用不能直接赋常量，但是加了const可以，具体如下：
    //int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误
	//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;
	const int& ref = 10;
	return 0;
}
```

注意事项：

* 引用必须初始化
* 引用在初始化后，不可以改变（因为是指针常量）

## 函数

### 默认参数

在C++中，函数的形参列表中的形参是可以有默认值的。

语法：` 返回值类型  函数名 （参数= 默认值）{}`

**示例：**

```C++
int func(int a, int b = 10, int c = 10) {
	return a + b + c;
}

//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数
int func2(int a = 10, int b = 10);
int func2(int a, int b) {
	return a + b;
}

int main() {

	cout << "ret = " << func(20, 20) << endl;
	cout << "ret = " << func(100) << endl;

	system("pause");

	return 0;
}
```

### 占位参数

C++中函数的形参列表里可以有占位参数，**用来做占位，调用函数时必须填补该位置**

**语法：** `返回值类型 函数名 (数据类型){}`

**示例：**

```C++
//函数占位参数 ，占位参数也可以有默认参数
void func(int a, int) {
	cout << "this is func" << endl;
}

int main() {

	func(10,10); //占位参数必须填补

	system("pause");

	return 0;
}
```

### 重载

> 和java重载基本一致，

**作用：**函数名可以相同，提高复用性

**函数重载满足条件：**

* 同一个作用域下
* 函数名称相同
* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**

**注意:**  函数的返回值不可以作为函数重载的条件

## 面对对象设计

高级程序设计语言里的类和继承的概念都大差不差。C++面对对象的三大特性分别是：**封装，继承，多态**

> C++也是一切皆对象，对象有其属性和行为

### 封装

* 将属性和行为作为一个整体，表现生活中的事物
* **将属性和行为加以权限控制**

### Struct和class的区别

在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**

区别：

* **struct 默认权限为公共**
* **class   默认权限为私有**

### 构造函数与析构函数

* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

> 构造函数处理无参构造函数，还有有参构造函数和拷贝构造函数
>
> 其中拷贝构造函数调用时机：
>
> * **使用一个已经创建完毕的对象来初始化一个新对象**
> * 值传递的方式给函数参数传值
> * 以值方式返回局部对象

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

举例

```c++
//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};
//2、构造函数的调用
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}
//调用有参的构造函数
void test02() {
	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//所以无参构造函数直接这么写，Person p1；
	//2.2 显式法
    //嗲用普通构造函数
	Person p2 = Person(10); 
    //调用拷贝构造函数
	Person p3 = Person(p2);
    //2.3直接复制
	Person p4 = 10; /0); 
    //注意这里，如果有指针类型变量，需要我们实现拷贝构造函数来实现深拷贝
	Person p5 = p4;

}
int main() {
	test01();
	system("pause");
	return 0;
}
```

**注意：**

- 如果没有实现构造函数或者析构函数，编译器会自动给这个类实现一个空的构造函数或者析构函数
- 如果类的成员中还有类，比如A类有成员变量B类，那么构造函数和析构函数顺序是
  - 创建一个A类对象时，先调用B类构造方法，再调用A类构造方法
  - 释放一个A类对象时，先调用A类析构方法，再调用B类析构方法

#### 深拷贝和浅拷贝

> 很经典的问题，需要掌握

浅拷贝：简单的赋值拷贝操作，编译器会自己实现

深拷贝：在堆区重新申请空间，进行拷贝操作。其实就是要我们写一个拷贝构造函数。

区别：**在未定义拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝（不用自己构造），它能够完成成员的简单的值的拷贝一一复制。**当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址（同一个堆区），**当对象快结束时，会调用两次析构函数**（析构函数也无需自己构造，但想要知道析构函数的工作可以自己构造析构函数用输出来记录），而导致**指针悬挂**现象，所以，此时，必须采用深拷贝。

**注：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题**

> 什么叫属性在堆开辟空间？我们知道java有引用类型，就是存在堆中的，这里C++里其实就是指针类型的属性，就需要在堆里开辟空间。
>
> 简而言之，**如果我们类的属性有指针类型，就要我们必须实现一个拷贝构造函数。**

示例:下面的person中就有一个属性`m_heigth`，那么我就需要实现拷贝构造函数来实现深拷贝

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		cout << "有参构造函数!" << endl;
		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题，然后造成指针悬挂
		m_age = p.m_age;
		m_height = new int(*p.m_height);
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);
	Person p2(p1);
	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;
	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}
int main() {
	test01();
	system("pause");
	return 0;
}
```

#### 初始化列表

C++提供了初始化列表语法，用来初始化属性。也就是更方便的构造函数

**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`

```C++
public:
	//传统方式初始化
	Person(int a, int b, int c) {
		m_A = a;
		m_B = b;
		m_C = c;
	}

	//初始化列表方式初始化
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
//Person p(1, 2, 3);调用时还是一样的
```

### 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

*  静态成员变量
   *  所有对象共享同一份数据
   *  在编译阶段分配内存
   *  类内声明，类外初始化
*  静态成员函数
   *  所有对象共享同一个函数
   *  **静态成员函数只能访问静态成员变量**

静态函数与静态变量访问方式：

- 对象访问与类名访问

举例

~~~C++
class Person
{
	
public:
	static int m_A; //静态成员变量
	static void func()
	{	//只能访问静态成员变量
		cout << "func调用" << endl;
		m_A = 100;
	}
private:
	static int m_B; //静态成员变量也是有访问权限的
};
//类里面声明，类外面初始化
int Person::m_A = 10;
int Person::m_B = 10;
int main{
   //1.对象访问
    Person p1;
	cout << "p1.m_A = " << p1.m_A << endl;
	//2、通过类名
	cout << "m_A = " << Person::m_A << endl;
    return 0;
}
~~~

>除了静态成员，还有两种特殊的成员，遇到再来补充吧
>
>**常函数：**
>
>* 成员函数后加const后我们称为这个函数为**常函数**
>* 常函数内不可以修改成员属性
>* 成员属性声明时加关键字mutable后，在常函数中依然可以修改
>
>
>
>**常对象：**
>
>* 声明对象前加const称该对象为常对象
>* 常对象只能调用常函数

### this指针

记住：**C++的this指针指向被调用的成员函数所属的对象**

### 多态

**多态是C++面向对象三大特性之一**

多态分为两类

* **静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名**
* **动态多态: 派生类和虚函数实现运行时多态**

静态多态和动态多态区别：

* 静态多态的函数地址早绑定  -  编译阶段确定函数地址
* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址

#### 虚函数与抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，**主要都是调用子类重写的内容**

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`

当类中有了纯虚函数，这个类也称为==抽象类==

**抽象类特点**：

 * 无法实例化对象
 * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

```C++
class Base
{
public:
	//纯虚函数
	//类中只要有一个纯虚函数就称为抽象类
	//抽象类无法实例化对象
	//子类必须重写父类中的纯虚函数，否则也属于抽象类
	virtual void func() = 0;
};

class Son :public Base
{
public:
	virtual void func() 
	{
		cout << "func调用" << endl;
	};
};

void test01()
{
	Base * base = NULL;
	//base = new Base; // 错误，抽象类无法实例化对象
	base = new Son;
	base->func();
	delete base;//记得销毁
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



## 模板



## 智能指针



## std::move

