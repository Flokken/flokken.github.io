---
title: Project#0
date: 2023-11-29
tags: 
  - C++
categories: 
  - 大数据
  - CMU15445
---

这一节主要是测试我们的C++背景够不够，

环境配置

[CMU15445（2023 Spring） lab - 环境配置](https://blog.csdn.net/J__M__C/article/details/129858032)

## Task 1 copy-on-write Trie

>[参考:](https://www.cnblogs.com/st0rmKR/p/17591533.html)

首先要了解Trie树是啥，这里不介绍。说一下写时复制trie/可持久化Trie。根据代码我们可以知道，其有两种节点`TrieNode`和`TrieNodeWithValue`。

- 其中叶子节点显然一定是一个`TrieNodeWithValue`，因为在该字符串的末尾字符存储其`value`

- 而部分中间节点也可能是`TrieNodeWithValue`,比如

  ```
  初始 Trie 树为空：
          root
  插入 ("an", 1)：
          root
           |
           a
           |
           n (value: 1)
  插入 ("a", 1)：
          root
           |
           a (value: 1)
           |
           n (value: 1)
  ```

**写时复制（Copy-on-Write，简称COW）**是一种内存管理技术，在该技术中，当多个引用共享同一个数据时，只有在某个引用试图修改数据时，才会进行实际的复制操作，以确保每个引用都具有独立的副本。

> 对应到这里，就是get()时直接查找，而put和remove涉及到修改元素，就需要对节点创建新副本，而不是修改元素本身

课程里分别介绍了其三个操作`get(),put(),delete()`

### Get()

这个和普通的trie没什么区别，就是查找对应key，返回对应value。

具体来说，直接用迭代的方式，从`root_`往下查找`children`,有以下情况:

- 对应的key在Trie树中不存在，那么应该提前退出，返回nullptr。
- 对应的key在Trie树中存在，但是其并非一个带值的节点，返回nullptr。
- 对应的key在Trie树中存在，且其是一个带值的节点，那么将该节点的值返回。

## Put

给定一个key和value，在Trie树中存储。由于copy-on-write的Trie树的特性，**这个key对应路径上的所有节点，都应该新建，其余的所有节点就复用以前版本的Trie树中节点。**

介绍一下课程介绍里的例子，假设一开始插入("ab",1)和("ac",val),那么这颗树本来就是虚线连起来的样子。

然后插入一个("ad",2),**那么要返回一颗实线连起来的下面那颗树。**

这里我们新增的节点只有 a对应的节点和2对应的节点，也就是这个key对应路径上的节点（包括root），并且要把其余节点复用（连起来）。

![image-20231204163045235](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231204163045235.png)

**具体做法**

这里选择迭代的做法，首先用一个数组把key对应的`TrieNode`存起来，因为后面需要新建（实际上就是调Clone()，底层数据并不会也跟着复制）

> 问题：Clone复制节点时，其与下属节点的关系也会复制过来吗？答案是的确会。
>
> 比如上面的node2，`node2=Clone(node1)`,那么`node2`也会有相关的连接信息。
>
> 原因：对于一个node,与其他node相连的方式是直接存`map`里。所以感觉Clone其实就是起了个别名。

我们遍历key, (for c :key )有以下情况:

- 这个c没有，那么就需要新建节点
- 这个c有，那么直接clone

这里值得一提是**叶子节点**，就是如果我们发现这次要新建的叶子节点trie中也有了（并且可能是中间节点），那么新建的这个叶子节点也需要应该是带`children`的，也需要把关系拷贝过来。

如果trie中没有，可以直接建没有`children`的节点

> 特殊情况，如果插入空串，那么相当于啥也没插入，此时应该只会新建`root_`,其他节点都复用

> 以后再更新递归的做法

### Remove()

给定一个Key，在Trie树中删除掉这个key对应的value。
同样在删除操作中，对应的key路径上的节点我们需要新建，其他的需要复用。

> 注意分析清楚再写，情况还是比较复杂的

1. 对应的key在Trie树中不存在，那么此时我们不需要做任何操作，将原先的Trie树原封不动的返回出去即可。
2. 对应的key在Trie树中存在路径，但是终端节点并不是一个带值节点。那么说明这个节点时其他节点的路径（中间节点），不能删去，此时我们不需要做任何操作，同样直接返回即可。
3. 对应的key在Trie树中存在路径，且终端节点是一个带值节点。此时需要分两种情况讨论。
   1. 该终端节点是一个叶子节点。那么我们可以直接将该叶子节点删去，同时在父结点的children列表中删去该节点。
   2. **该终端节点不是一个叶子节点，那么我们应该将该节点从带值节点转换成一个不带值节点，而链接关系之类的应该保持原封不动。**
