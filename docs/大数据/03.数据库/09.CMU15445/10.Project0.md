---
title: Project#0
date: 2023-11-29
tags: 
  - C++
categories: 
  - 大数据
  - CMU15445
---

这一节主要是测试我们的C++背景够不够，

环境配置

[CMU15445（2023 Spring） lab - 环境配置](https://blog.csdn.net/J__M__C/article/details/129858032)

## Task 1 copy-on-write Trie

>[参考:](https://www.cnblogs.com/st0rmKR/p/17591533.html)

首先要了解Trie树是啥，这里不介绍。说一下写时复制trie/可持久化Trie。根据代码我们可以知道，其有两种节点`TrieNode`和`TrieNodeWithValue`。

- 其中叶子节点显然一定是一个`TrieNodeWithValue`，因为在该字符串的末尾字符存储其`value`

- 而部分中间节点也可能是`TrieNodeWithValue`,比如

  ```
  初始 Trie 树为空：
          root
  插入 ("an", 1)：
          root
           |
           a
           |
           n (value: 1)
  插入 ("a", 1)：
          root
           |
           a (value: 1)
           |
           n (value: 1)
  ```

**写时复制（Copy-on-Write，简称COW）**是一种内存管理技术，在该技术中，当多个引用共享同一个数据时，只有在某个引用试图修改数据时，才会进行实际的复制操作，以确保每个引用都具有独立的副本。

> 对应到这里，就是get()时直接查找，而put和remove涉及到修改元素，就需要对节点创建新副本，而不是修改元素本身

课程里分别介绍了其三个操作`get(),put(),delete()`

### Get()

这个和普通的trie没什么区别，就是查找对应key，返回对应value。

具体来说，直接用迭代的方式，从`root_`往下查找`children`,有以下情况:

- 对应的key在Trie树中不存在，那么应该提前退出，返回nullptr。
- 对应的key在Trie树中存在，但是其并非一个带值的节点，返回nullptr。
- 对应的key在Trie树中存在，且其是一个带值的节点，那么将该节点的值返回。

### Put()

给定一个key和value，在Trie树中存储。由于copy-on-write的Trie树的特性，**这个key对应路径上的所有节点，都应该新建，其余的所有节点就复用以前版本的Trie树中节点。**

介绍一下课程介绍里的例子，假设一开始插入("ab",1)和("ac",val),那么这颗树本来就是虚线连起来的样子。

然后插入一个("ad",2),**那么要返回一颗实线连起来的下面那颗树。**

这里我们新增的节点只有 a对应的节点和2对应的节点，也就是这个key对应路径上的节点（包括root），并且要把其余节点复用（连起来）。

![image-20231204163045235](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231204163045235.png)

**具体做法**

这里选择迭代的做法，首先用一个数组把key对应的`TrieNode`存起来，因为后面需要新建（实际上就是调Clone()，底层数据并不会也跟着复制）

> 问题：Clone复制节点时，其与下属节点的关系也会复制过来吗？答案是的确会。
>
> 比如上面的node2，`node2=Clone(node1)`,那么`node2`也会有相关的连接信息。
>
> 原因：对于一个node,与其他node相连的方式是直接存`map`里。所以感觉Clone其实就是起了个别名。

我们遍历key, (for c :key )有以下情况:

- 这个c没有，那么就需要新建节点
- 这个c有，那么直接clone

这里值得一提是**叶子节点**，就是如果我们发现这次要新建的叶子节点trie中也有了（并且可能是中间节点），那么新建的这个叶子节点也需要应该是带`children`的，也需要把关系拷贝过来。

如果trie中没有，可以直接建没有`children`的节点

> 特殊情况，如果插入空串，那么相当于啥也没插入，此时应该只会新建`root_`,其他节点都复用

> 以后再更新递归的做法

### Remove()

给定一个Key，在Trie树中删除掉这个key对应的value。
同样在删除操作中，对应的key路径上的节点我们需要新建，其他的需要复用。

> 注意分析清楚再写，情况还是比较复杂的。
>
> 特别是cur_node和key[index]的关系

1. 对应的key在Trie树中不存在，那么此时我们不需要做任何操作，将原先的Trie树原封不动的返回出去即可。
2. 对应的key在Trie树中存在路径，但是终端节点并不是一个带值节点。那么说明这个节点时其他节点的路径（中间节点），不能删去，此时我们不需要做任何操作，同样直接返回即可。
3. 对应的key在Trie树中存在路径，且终端节点是一个带值节点。此时需要分两种情况讨论。
   1. 该终端节点是一个叶子节点。那么我们可以直接将该叶子节点删去，同时在父结点的children列表中删去该节点。
      1. 这里还有一个点需要注意，删除这个节点之后，我们还要自底向上的查看其父节点，**如果父节点的`children_`里只有当前这个`cur_node`,并且也还没遇到过带值的节点，那么这个节点需要删掉（两个条件）**。
      1. 我感觉这里我虽然最终蒙过去了，但没有完全理解，一个remove花了两天！唉
   2. 该终端节点不是一个叶子节点，那么我们应该将该节点从带值节点转换成一个不带值节点，而链接关系之类的应该保持原封不动。

## Task2  Concurrent Key-Values Stores

这里要求对于每次对树进行修改时，都需要获取新的树根来访问新内容，并且由于PUT()和Remove()操作没有返回值，需要使用并发原语来控制他们

这里的操作有些特殊，要求同时为多个读进程和一个写进程服务，也就是说哪怕有进程在读，这个写进程也能修改trie，但是是在旧的root()之上。

> 这里介绍一下C++的锁，这个实验使用的是互斥锁`std:: mutex`,读锁和写锁都是这个类型。

**Get():**

**要求返回value，**注意由于我们返回的是指针。那么存在一个问题。因为要同时让读进程和写进程一起处理，因此会产生一个问题，就是Get返回的指针指向数据可能已经没了

所以返回一个 `ValueGuard`，**它存储对值的引用**和与 trie 结构的根相对应的 TrieNode，以便在我们存储 ValueGuard 时可以访问该值。

> 这个`ValueGuard`还存了树根，在这个实验的test里好像也没啥用？对比value时都是直接返回存的value。

**Put():**

显然，对于读锁，我们要保证可以多个进程可以同时读取，所以读完树根马上就释放。

对于写锁，我们进行完这个写进程所有操作后才应该释放，保证只有一个写进程。

**要求不返回**。首先获取写锁，然后再获取树根锁，从而得到树根，释放树根锁（让其他读者可以获取树根进行读入）。然后调用Trie::Put，完成后需要更新树根，因此又需要获取树根锁，更新完再释放。最后释放写锁。（保证永远最多只有一个写者）

**Remove():**

**要求不返回**。加速逻辑和put一样

## Task3 Debug

就是打断点，调试看值，但是本地的测试数据和gradescope平台上的测试数据不一样。需要把TrieDebugger改成以下数据

```C++
 auto trie = Trie();
  trie = trie.Put<uint32_t>("65", 25);
  trie = trie.Put<uint32_t>("61", 65);
  trie = trie.Put<uint32_t>("82", 84);
  trie = trie.Put<uint32_t>("2", 42);
  trie = trie.Put<uint32_t>("16", 67);
  trie = trie.Put<uint32_t>("94", 53);
  trie = trie.Put<uint32_t>("20", 35);
  trie = trie.Put<uint32_t>("3", 57);
  trie = trie.Put<uint32_t>("93", 30);
  trie = trie.Put<uint32_t>("75", 29);
```

> 而且最后一个问题969的value是30，如果改成这样插入数据，根本就没有969？不过这里能过就不用管了也没啥用

## Task4:SQL String Functions

实现Lower和Upper函数，这个很好做。这两个函数在`string_expression.h`里

> clion可以用`ctrl+shift+N`查找某个文件

**这个的主要难点在于在BusTub中注册函数。**

找到plan_func_call.cpp这个文件，实现里面的函数Planner::GetFuncCallFromFactory即可。
