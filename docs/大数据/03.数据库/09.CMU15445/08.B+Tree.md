---
title: L7-B+Tree
date: 2023-12-10
tags: 
  - null
categories: 
  - 大数据
  - CMU15445
---

## B+Tree

> aka  "The Greatest  Data Structure  of All  Time"
>
> [动态可视化网站](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

### Table Index

B+ 树常常用于做`table index`，也就是表索引。

1.这里的定义看起来有点复杂，人话就是假设有一张大表比如人员信息表，有很多列比如ID,姓名，年龄，地点，电话等等。

那我现在抽出一列年龄来，并且一般是被排序了。那么他就是索引，也就是这张大表的一个小表就是索引。

2.DBMS需要维护索引和表的同步，也就是表如果有插入，删除了东西，那么索引应该也要变

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212102441311.png" alt="image-20231212102441311" style="zoom:50%;" />

建立索引可以极快的加速查询时间，但是也需要消耗额外的空间和时间维护索引，因此这里存在一个`trade-off`

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212102959638.png" alt="image-20231212102959638" style="zoom:50%;" />

### B-Tree

注意这不是B-树，这个-不是减号，他就叫B树。这是B-Tree family，这个B并不是哪个单词的缩写（特别注意不是balance），就是一个名字B。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212103123407.png" alt="image-20231212103123407" style="zoom:50%;" />

B树和B+树都是`self-balance`，即自平衡的

#### B+Tree

B+树是自平衡的树，查询，删除，插入都是`O(logn)`的

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212103450843.png" alt="image-20231212103450843" style="zoom:50%;" />

**B+Tree  Properties**

B+树的节点不是一对一，而可以是多对多（普通二叉树是一对一，一个kv键值对），特点：

- 每个叶子节点高度都一样
- 每个有key个键的内部节点都有k+1个不为空的子节点

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212103607013.png" alt="image-20231212103607013" style="zoom:50%;" />

下面是一个示例：

> 这个也很好，可以看到动态变化，而且各种数据结构都有：[可视化网站](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)



<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212105220353.png" alt="image-20231212105220353" style="zoom:50%;" />

##### Leaf Nodes

B+树中有两种nodes,`Inner nodes`,`lead nodes`

我们根据上面的例子可以看到，所有的实际数据，都在叶子节点上。并且他的叶子节点是按序分块的，这是一个很大的优势

> hash表没有分块，我们知道。但是对于一个磁盘来说，他有页的概念，我们如果B+树分的好，他的一个叶子节点可能就能对应一页，就会很好。

在实际实现时，我们可以用数组把key存起来，然后用另一个数组存values。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212105809238.png" alt="image-20231212105809238" style="zoom:50%;" />

**Values**

**B+树中的索引实际上就是我们在表中要索引的列，而value有下面的两种实现**

- Record ID
  - value记录的是这个record的id，比如我以人员信息表的年龄做索引，他的value就是这一行的id。根据这个id就可以得到这个record了
- TupleData
  - value直接就是这一行比如我以人员信息表的年龄做索引，他的value直接就是这一行，一整个元组。**比如主键索引（实际上这整张表都是B+树组织起来的）**,这样的好处时更快，但消耗空间也更多
  - 二级索引必须存Record ID

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212105702878.png" alt="image-20231212105702878" style="zoom:50%;" />

##### B-Tree  Vs B+Tree

B树中间节点既存索引也存数据，但是B+树只有叶子节点存数据，空间上更高效

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212111008361.png" alt="image-20231212111008361" style="zoom:50%;" />

##### Selection conditions

跳跃搜索

指的是对于一组属性，我们只需要其中一个或者说一部分就能检索而不是全部都要知道。

比如下面的的`<a,b,c>`，我们不一定需要a,b,c都知道，我们只知道a,b或者c的值就可以都检索到。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212134614388.png" alt="image-20231212134614388" style="zoom:50%;" />

> 所以数据库模糊搜索建议一般右模糊，因为左边的key确定的情况下，B+树可以直接跳的搜，如果左边不确定，只能做全表扫描

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212111317191.png" alt="image-20231212111317191" style="zoom:50%;" />

##### Duplicate Keys

如果key有多个，我们两个方案

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212135049460.png" alt="image-20231212135049460" style="zoom:50%;" />

- 给value附件行ID
  - <img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212135135559.png" alt="image-20231212135135559" style="zoom:50%;" />
- 叶子节点溢出
  - <img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212135212255.png" alt="image-20231212135212255" style="zoom:50%;" />



### Clustered Indexes

如果values存的是整行的数据(tuple)(这种方式也叫主键索引)，那么就是聚簇索引，否则不是

> 所以聚簇索引好像就是主键索引?就是value存的是整行的数据

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212111515438.png" alt="image-20231212111515438" style="zoom:50%;" />

聚簇索引的好处是遍历非常方便

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212135347693.png" alt="image-20231212135347693" style="zoom:50%;" />

如果不是聚簇索引，遍历会比较麻烦

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212142335126.png" alt="image-20231212142335126" style="zoom:50%;" />

### B+ Tree Design Choices

#### Node Size

如果存储设备越慢，那么推荐的B+树的节点大小越大

> 因为设备越慢，相同磁盘的I/O次数越少，设置的大一点可以多读取一些数据。
>
> 但是设备越快，设置的小一点，可以避免读取太多冗余数据

推荐大小也还需要考虑`workload`

> 比如TP型可以小一点，AP型大一点

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212140654019.png" alt="image-20231212140654019" style="zoom:50%;" />

#### Merge  Threshold

指当节点达到某个大小时，应该将其合并

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212141032870.png" alt="image-20231212141032870" style="zoom:50%;" />

#### Variable-Length  Keys

变长key的处理

- 指针
- 变长节点（用得少）
- padding（补长，比如填空字符串）
- 给key建立索引，通过这个索引能找到key，类似于之前页布局中的slot方法

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212141044537.png" alt="image-20231212141044537" style="zoom:50%;" />

#### Intra-Node Search

节点内部搜索方法

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212141411677.png" alt="image-20231212141411677" style="zoom:50%;" />

### Optimizations

#### Prefix compression

前缀压缩，这里是对key进行压缩，提取key的前缀

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212141741504.png" alt="image-20231212141741504" style="zoom:50%;" />

#### Deduplication

将冗余的key给合并了，比如有(k1,v1),(k1,v2)，(k1,v3),合并为(k1,{v1,v2,v3})

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212141831133.png" alt="image-20231212141831133" style="zoom:50%;" />

#### Bulk  insert

> bulk  大批的

如果要插入很多数据，先把数据的key排序后在插入，会比一个个插入好得多

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231212141956778.png" alt="image-20231212141956778" style="zoom:50%;" />

### Conclusion

The  Vulnerable  B+ Tree    is  always  your  choice for  DBMS

