---
title: 深入浅出索引
date: 2023-05-30 
tags: 
  - MySQL45讲
categories: 
  - 大数据
  - MySQL
---

## 索引

索引是数据库系统里面最重要的概念之一。一句话简单来说，**索引的出现其实就是为了提高数据查询的效率，就像书的目录一样**。

> 我们可以通过书的目录快速定位内容，同样，对于数据库的表而言，索引其实就是它的“目录”

## 索引的常见模型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里介绍三种常见、也比较简单的数据结构，它们分别是**哈希表、有序数组和搜索树**

### 哈希表

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/0c62b601afda86fe5d0fe57346ace957.png" style="zoom:70%">

图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，**处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。**

需要注意的是，图中四个 ID_card_n 的值并不是递增的**，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。**

>如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了,遍历所有值才能得到结果

所以，**哈希表这种结构适用于只有等值查询的场景**，比如 Memcached 及其他一些 NoSQL 引擎。

### 有序数组	

**有序数组在等值查询和范围查询场景中的性能就都非常优秀**。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/bfc907a92f99cadf5493cf0afac9ca49.png "  style="zoom:70%">

这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，**用二分法就可以快速得到，这个时间复杂度是 O(log(N))。**

同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环

缺点：**在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。**

>所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

### 二叉搜索树

二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -> UserC -> UserF -> User2 这个路径得到。这个时间复杂度是 O(log(N))。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/04fb9d24065635a6a637c25ba9ddde68.png "  style="zoom:70%">

**当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。**为了做这个保证，更新的时间复杂度也是 O(log(N))。树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。

**二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。**

> 这里很重要，因为如果所有数据都在内存中，平均搜索速度最快的应该是平衡二叉树。但如果要读磁盘，B+树读磁盘的次数是比二叉树少的，所以B+树也就更快

**例子：**

一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询非常慢

为了让一个查询尽量少地读磁盘**，就必须让查询过程访问尽量少的数据块**。那么，我们就不应该使用二叉树**，而是要使用“N 叉”树**。**这里**，“**N 叉”树中的“N”取决于数据块的大小。**

>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

>不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中

数据库底层存储的核心就是基于这些数据模型的。**每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景**

### B树（B-tree或者B-树）

> 参考：https://zhuanlan.zhihu.com/p/87124501

#### 基本介绍

先来了解一下什么是 B 树，其实，B 树和二叉查找树一样，都是**树**，**B 树**相当于是一棵**多叉查找树**。

B+树包含结点：

0、根结点：(一般区分为两种，这里将根结点分开说明，因为根节点非常特殊而且唯一)

      若树只有一层：仅有根结点，此根结点也是叶结点，根结点中索引值个数无最少限制。
      若树为两层以及以上：最上面那一层为根结点，根结点属于内部结点，根节点中指针最少为2个。

1、叶结点：叶节点在B树的最底层（**所有叶节点都在一层**），**叶结点中存放索引值、指向记录的指针、指向下一个叶结点的指针**。叶结点内的索引值是记录中键的拷贝，这些索引值以排好序的形式，从左到右分布在叶节点中。

2、内部结点：所有非叶结点都属于内部结点**，所有内部结点上的索引值都是叶结点的副本。内部结点中存放索引值、指向某一个结点**（可以是叶结点也可以是内部节点）的指针。

**叶子节点和内部节点存储结构本质上一样**

![image-20230531163536313](https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230531163536313.png)

对于一棵 m 阶的 B 树具有如下特性：

1、根节点至少有两个孩子。

2、每个中间节点都包含 k - 1 个元素和 k 个孩子，其中 m/2 <= k <= m。

3、每一个叶子节点都包含 k - 1 个元素，其中 m/2 <= k <= m。

4、所有的叶子节点都位于同一侧。

5、每个节点中的元素从小到大排列，节点当中的 k - 1 个元素正好是 k 个孩子包含的元素的值域划分。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230531163744584.png "  style="zoom:70%">

> 阶是一个节点可以有的**最大**的子节点数目，比如这张图，（3,7）这个内部节点有三个子节点，所以是3阶
>
> **度数：**在树中，每个节点的子节点（子树）的个数就称为该节点的度（degree）。
>
> 注意B+树可以由阶数定义，也可以由度数定义，**一般用阶数定义**
>
> https://blog.csdn.net/God_Mood/article/details/82828431
>
> https://www.zhihu.com/question/64704576

图中是一棵m = 3 的 3 阶 B 树，可以看出，树中有些节点是有**多个元素**的，并且和二叉查找树一样，**左节点的所有元素的值都比父亲元素小**。例如对于(3, 7)这个节点。两个元素把这个节点分割成**三个值域**，即可以有 3 个孩子。2 相当于 3 的左孩子节点，而 （4，6）相当于 3 的右孩子，同时也是 7 的左孩子，而 9 是 7 的右孩子。

#### B树查找

从根结点开始，首先从结点内部查找（由于结点内部是升序的，二分查找即可），然后没有，则根据指针向子节点找。

以上面树为例，比较二叉树与B+树查找的区别

先画出二叉树

<img src=" https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20230531164352473.png"  style="zoom:70%">

假设查找9，

B树查找次数为4次，10->(3,7)(这里比两次，比3大，比7大)->9（比较发现相等，返回），所以是4次

二叉树是，10->6->7->9,也是4次

**两者一样，为什么B树在存储时更快？**

因为大部分数据一般存在磁盘里，主要影响速度的原因是**磁盘的寻址加载次数**。

> 在把磁盘里的数据加载到内存中的时候，是以**页**为单位来加载的，而我们也知道，**节点与节点之间的数据是不连续的**，所以不同的节点，很有可能分布在不同的**磁盘页**中

**对于二叉树，可能需要去4次磁盘寻址，而B树，一个节点可以有多个元素，所以寻址次数更少，只需3次**

### B+树

B+树是在B树的基础上又一次的改进，其主要对两个方面进行了提升，一方面是查询的稳定性，另外一方面是在数据排序方面更友好。

> https://zhuanlan.zhihu.com/p/149287061

**构建规则**（与B-树区别）

（1）B+树的**非叶子**节点**不保存具体的数据，而只保存用来索引的数据（关键字key），数据只存在于叶子节点**。因为所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样，这样一来B+树的查询速度也就会比较稳定**，

> B+树查询次数都是树高，
>
> 而B树的查找过程中，不同的关键字查找的次数很有可能都是不同的（有的数据可能在根节点，有的数据可能在最下层的叶节点），**所以在数据库的应用层面，B+树就显得更合适。**

（2）B+树叶子节点的关键字从小到大有序排列，**左边结尾数据都会保存右边节点开始数据的指针。因为叶子节点都是有序排列的，所以B+树对于数据的排序有着更好的支持。**

> 叶子节点之间使用指针连接成一个链表，**方便范围查询操作。**

（3）设 m 为非根节点的可行子节点数.

设 k 为B树和B+树的非根节点可行键数，那么满足：k+1=m

#### B+树查询

​	假设有B+树

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/v2-65789684f319ca8675040ee7044e365c_b.jpg"  style="zoom:100%">

如果查询59

第一次磁盘 I/O ：访问根结点 `[59、97]` ，发现 `59` 小于等于 `[59、97]` 中的 `59` ，则访问根结点的第一个孩子结点。

第二次磁盘 I/O : 访问结点 `[15、44、59]` ，发现 `59` 大于 `44` 且小于等于 `59` ，则访问当前结点的第三个孩子结点 `[51、59]` .

第三次磁盘 I/O ：访问叶子结点 `[51、59]` ，顺序遍历结点内部，找到要查找的元素 `59` .

>和 B-树的区别，**对于 B+树中单个元素的查找而言，每一个元素都有相同的磁盘 I/O操作次数，即使查询的元素出现在根结点中，但那只是一个充当控制查找记录的媒介，并不是数据本身，数据真正存在于叶子结点当中**，所以 B+树中查找任何一个元素都要**从根结点一直走到叶子结点才可以。**

与B树相比好处：

B+树的非叶子结点均不存储 `Data`，所以与 B-树相比，同样大小的磁盘页，B+树的非叶子结点可以存储更多的指针（也就是能找到更大范围数据），这也就意味着在数据量相同的情况下，**B+树的结构比 B-树更加 “矮胖”，查询时磁盘 I/O 次数会更少。**

> B+树查询次数都是树高，B树则不稳定，可能一次找到，也可能多次查询才能找到

## InnoDB 的索引模型

在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。**由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛**，所以下面就以 InnoDB 为例，分析一下其中的索引模型。

在 InnoDB 中，**表都是根据主键顺序以索引的形式存放的**，**这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。**

**补充：InnoDB的索引树的根节点是常驻内存的，子节点才放在磁盘**

> 因为InnoDB很常用，一般认为MYSQL的索引使用的就是B+树的存储结构
>
> 每个索引在InnoDB里面对应一颗B+树
>
> B树属于多叉树又名平衡多路查找树（查找路径不只两个）
>
> B+树是在B树的基础上又一次的改进
>
> https://zhuanlan.zhihu.com/p/27700617

假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。

~~~sql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;

insert into t(id,k) values(100,1),(200,2),(300,3),(500,5),(600,6);
~~~

假设表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/dcda101051f28502bd5c4402b292e38d.png "  style="zoom:70%">

> 注意内部节点的如ID的300,700，k的3,7都是关键字，不是真实数据；B+树的真实数字在叶子节点

从图中不难看出，根据叶子节点的内容，**索引类型分为主键索引和非主键索引。**

> 这里ID是主键，k是非主键。两个都有索引，主键ID的索引不需要额外创建，因为创建主键时，mysql会自动添加一个与主键对应的唯一索引

**主键索引的叶子节点存的是整行数据**。在 InnoDB 里，**主键索引也被称为聚簇索引**（clustered index）。

**非主键索引的叶子节点内容是主键的值**。在 InnoDB 里，**非主键索引也被称为二级索引**（secondary index）。

这里需要思考，这两种索引在查询的时候有什么区别？

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
- **如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。**

>也就是说，**基于非主键索引的查询需要多扫描一棵索引树**。因此，我们在应用中应该尽量使用主键查询。

## 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。**如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。**

**特殊情况**：如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。**这个过程称为页分裂。在这种情况下，性能自然会受影响。**

>页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

**案例：**哪些场景下应该使用自增主键，而哪些场景不应该

**自增主键是指自增列上定义的主键**，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。

**插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。**

> 也就是主键会自己设置，因为自增嘛

也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，**都不涉及到挪动其他记录，也不会触发叶子节点的分裂。**

**而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。**

除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，**比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？**

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，**而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。**

显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

**所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。**

有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的

- 只有一个索引；
- 该索引必须是唯一索引。

**这也是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。**

这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，**直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树（因为如果用了自增主键，就要通过他来查，当然就是两棵树）。**

## MYSQL查询

> 总结：
>
> 主键索引的key，value(key，整条记录（一行）)，非主键索引的key,value(key，主键)
>
> 回表：查的时候，是非主键索引，有些时候需要去主键在查，才能查找值，称为回表
>
> 覆盖索引：优化性能，优化回表
>
> 联合索引：冗余记录来实现覆盖索引，对于高频的查询，可以不用回表，优化性能
>
> 最左前缀原则：只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
>
> ​	这个原则让我们可以少写一些索引
>
> 索引下推：，**对索引中包含的字段先做判断，直接过滤掉不满足条件的记录（不去接着查），减少回表次数。**

还是上面那个例子，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？

~~~sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
~~~

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/dcda101051f28502bd5c4402b292e38d.png "  style="zoom:70%">

1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300；
2. 再到 ID 索引树查到 ID=300 对应的 R3；
3. 在 k 索引树取下一个值 k=5，取得 ID=500；
4. 再回到 ID 索引树查到 ID=500 对应的 R4；
5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束。

>**回到主键索引树搜索的过程，我们称为回表**。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。

### 覆盖索引

由于查询结果所需要的数据只在主键索引上有，所以不得不回表。**那么，有没有可能经过索引优化，避免回表过程呢？**

**如果执行的语句是改成select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，**不需要回表。也就是说，在这个查询里面**，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。**

> 注意这里和上面的区别是，上面需要返回ID对应的R3-R5,改成ID后，只需要返回主键（ID）的值，但是k索引中本来就有主键（ID）的值，因此不需要查询，直接返回，这样叫覆盖索引。
>
> **由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**
>
> 需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录(R3,R4)，因此 MySQL 认为扫描行数是 2。

### 联合索引

基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，**是否有必要将身份证号和名字建立联合索引**？

>联合索引概念，参考链接： https://cloud.tencent.com/developer/news/44861 另外，一般不建议使用业务相关字段作为主键，即使其具有唯一性特性（如身份证）。因为，当业务变更（如身份证升位），就会带来灾难。
>
>我的理解就是如果只有身份证号，就是单列，如果联合索引（身份证号，名字），就是两列，之前的一列的情况（包括内部节点和叶子节点），全部换成（身份证号，名字）这样的两列**，这样就可以实现覆盖索引了，进一步也就可以避免回表。**

~~~sql

CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
~~~

我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，**这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。**

>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。

### 最左前缀原则

**问题：**如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？

**结论：B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录**。

为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/89f74c631110cfbc83298ef27dcd6370.jpg "  style="zoom:70%">

可以看到，**索引项是按照索引定义里面出现的字段顺序排序的。（B+树叶子节点是有序的）**

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是"where name like ‘张 %’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。

可以看到，不只是索引的全部定义，**只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。**



基于上面对最左前缀索引的说明，**我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。**

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此**，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。**

**开头的问题:**

我们要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求

那么**，如果既有联合查询，又有基于 a、b 各自的查询呢？**查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你**需要同时维护 (a,b)、(b) 这两个索引。**

**这时候，我们要考虑的原则就是空间了**。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那建议**创建一个（name,age) 的联合索引和一个 (age) 的单字段索引**

### 索引下推

满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。**那些不符合最左前缀的部分，会怎么样呢？**

**以市民表的联合索引（name, age）为例**：如果现在有一个需求：**检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”**。那么，SQL 语句是这么写

的：

~~~sql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
~~~

> 这里查询有三个字段，一个是名字第一个是张，第二个是年龄是10，第三个是性别为男，为什么说只匹配张？
>
> 因为索引只有（name，age），类似(张三，20)，这里注意，我们只用了姓，所以对于name，基于最左匹配原则，也只能匹配姓“张”的，后面不一样的，也就是到这里截止了。

这个语句在搜索索引树的时候，**只能用 “张”，找到第一个满足条件的记录 ID3**。当然，这还不错，总比全表扫描要好。

接下来还需要判断其他条件是否满足：

- 在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。
- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， 可以在索引遍历过程中，**对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**

无下推优化

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/b32aa8b1f75611e0759e52f5915539ac.jpg "  style="zoom:70%">

有索引下推优化

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/76e385f3df5a694cc4238c7b65acfe1b.jpg "  style="zoom:70%">

>这两个图里面，每一个虚线箭头表示回表一次。

- 图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，**需要回表 4 次。**
- 图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，**就只需要回表 2 次。**

## **总结**

InnoDB 采用的 B+ 树结构

为什么 InnoDB 要这么选择？B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数

InnoDB 是索引组织表，一般情况下建议你创建一个自增主键，这样非主键索引占用的空间最小。但事无绝对，**也有使用业务逻辑字段做主键的应用场景（KV）**

后面讨论了数据库索引的概念，包括了**覆盖索引、前缀索引（最左前缀原则）、索引下推**

在满足语句需求的情况下， 尽**量少地访问资源是数据库设计的重要原则之一。我们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。**

## Q & A

1 对于上面例子中的 InnoDB 表 T，如果你要重建索引 k，你的两个 SQL 语句可以这么写：

~~~sql
alter table T drop index k;
alter table T add index(k);
~~~

如果你要重建主键索引，也可以这么写

~~~sql
alter table T drop primary key;
alter table T add primary key(id);
~~~

对于这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？

> 第一次看到的想法，应该是删除后重建非常消耗性能？

答：**重建索引 k 的做法是合理的，可以达到省空间的目的。**但是，重建主键的过程不合理。**不论是删除主键还是创建主键，都会将整个表重建。**所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。(这个语句在后面章节分析)

>InnoDB 这种引擎,**虽然删除了表的部分记录,但是它的索引还在, 并未释放. 只能是重新建表才能重建索引.**

2主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：

~~~sql

CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
~~~

公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。

但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”,“cb”这两个索引？同事告诉他，是因为他们的业务里面有这样的两种语句：

~~~sql
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
~~~

问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？

**解**：

表记录

–a--|–b--|–c--|–d--

1 2 3 d

1 3 2 d

1 4 3 d

2 1 3 d

2 2 2 d

2 3 4 d

**主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。**

索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键

–c--|–a--|–主键部分b-- （注意，这里不是 ab，而是只有 b）

2 1 3

2 2 2

3 1 2

3 1 4

3 2 1

4 2 3

这个跟索引 c 的数据是一模一样的。

索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键

–c--|–b--|–主键部分a-- （同上）

2 2 2

2 3 1

3 1 2

3 2 1

3 4 1

4 3 2

所以，**结论是 ca 可以去掉，cb 需要保留。**

