---
title: 事务隔离
date: 2023-05-31 
tags: 
  - MySQL45讲
categories: 
  - 大数据
  - MySQL

---

## 事务隔离

### 问题引入

和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。

转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，**这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账**，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。

### **事务是什么**？

简单来说，**事务就是要保证一组数据库操作，要么全部成功，要么全部失败（原子性）**。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 **InnoDB** 取代的重要原因之一。

#### 事务四个特性

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

### 隔离性与隔离级别

当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）**的问题，为了解决这些问题，就有了“隔离级别”的概念。

在谈隔离级别之前，**你首先要知道，你隔离得越严实，效率就会越低（我觉得是因为并发性变低了）**。因此很多时候，我们都要在二者之间寻找一个平衡点。

**SQL 标准的事务隔离级别包括：**

读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

> 这里有个默认知识，事务要提交了才起效

#### 举例

**其中“读提交”和“可重复读”比较难理解**

~~~sql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
~~~

假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/7dea45932a6b722eb069d2264d0066f8.png" style="zoom:70%">

不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
- 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

不同的隔离级别下，数据库行为是有所不同的。**Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。**

配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。

~~~sql

mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+
~~~

总结来说，存在即合理，每种隔离级别都有自己的使用场景，你要根据自己的业务情况来定。我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。

##### 可重复读应用

> 注意视图是在**事务启动时创建的，整个事务存在期间都用这个视图**

假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

这时候使用“可重复读”隔离级别就很方便。**事务启动时的视图可以认为是静态的，不受其他事务更新的影响。**

### 事务隔离实现

> 总结：MVCC（并发控制）

**在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/d9c313809e5ac148fc39feff532f0fee.png" style="zoom:70%">

当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，**就是数据库的多版本并发控制（MVCC**）。对于 read-view A，要得到 1，**就必须将当前值依次执行图中所有的回滚操作得到。**

同时你会发现，**即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的**。

> 在T1时，开启事务A，读到1，对应read-view-A。 在T2时，事务a执行update，将1改成2； 在T3时，开启事务B，读到2，对应read-view-B。 在T4时，事务b执行update，将2改成3； 在T5时，事务c执行update，将3改成4； 在T6时，开启事务C，读到4，对应read-view-C。 所以 假如在T7时，有事务d将4改成5，都不会影响read-view-A，read-view-B，read-view-C。这3个读视图分别将当前值做相应的回滚操作得到。 主要体现‘可重复读’的基本原理。

**什么时候删除回滚日志**？

**就是当系统里没有比这个回滚日志更早的 read-view 的时候。**基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。

长事务意味着系统里面**会存在很老的事务视图**。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，**这就会导致大量占用存储空间**。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。除了对回滚段的影响，**长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。**

### 事务启动方式 

如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL 的事务启动方式有以下几种：

- 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。
- set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接

有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。**这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。**

**因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。**

> 但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用 commit work and chain 语法

在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

**查询长事务**

可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

~~~sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
~~~

## 事务到底是隔离的还是不隔离的

已知：

- 如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样
- 一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，会被锁住，进入等待状态

那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？

> 这个问句的点是：一方面事务是可重复读，即整个事务期间都看到的是事务刚刚启动时候的视图；但是又因为行锁，事务在执行过程中可能需要等待别的事务更新同一行，那这时候如果该事务也要更新，看到的还是事务刚刚创建时事务的状态吗？ **显然不是，这里的关键就是对于更新操作来说，需要当前读**。

### 举例

~~~sql
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
~~~

假设有事务A，B，C

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/823acf76e53c0bdba7beab45e72e90d6.png" style="zoom:70%">

**这里，我们需要注意的是事务的启动时机。**

begin/start transaction 命令并不是一个事务的起点，**在执行到它们之后的第一个操作 InnoDB 表的语句(任意语句，比如增删改查)，事务才真正启动**。**如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。**

>Begin/start transaction与start transaction with consistent snapshot的区别 **也说明一个事务并不是都有readview，比如一个仅有update的事务**

- 第一种启动方式，一致性视图是在执行第一个快照读语句时创建的（即begin/start transaction ）；
- 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。

> 默认 autocommit=1。

在这个例子中，事**务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。**事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。

这时，**如果我告诉你事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1，你是不是感觉有点晕呢？**

### MySQL视图概念

在 MySQL 里，有两个“视图”的概念：

- 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
- 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。

>1.普通视图（view）：是有物理结构的 
>
>2.一**致性视图（consistent read view）：没有物理结构**

### “快照”在 MVCC 里是怎么工作的？

**在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。**

如何实现快照？

> 假设数据库100G，怎么能在瞬间记录这么大的数据呢？

InnoDB 里面每个事务有一**个唯一的事务 ID**，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。

而**每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本**，**并且把 transaction id 赋值给这个数据版本的事务 ID**，记**为 row trx_id**。同时，旧的数据版本要保留，并且在新的数据版本中，**能够有信息可以直接拿到它**。

> 也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

<img src="https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/68d08d277a6f7926a41cc5541d3dfced.png" style="zoom:70%">

图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。

前面提到，**语句更新会生成 undo log（回滚日志）吗？那么，undo log 在哪呢？**

实际上，图 2 中的三个虚线箭头，就是 undo log；**而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。**

按照**可重复读**的定义，**一个事务启动的时候，能够看到所有已经提交的事务结果****。但是之后，这个事务执行期间，其他事务的更新对它不可见。

因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，**如果一个数据版本是在我启动之前生成的，就认**；**如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”**

>**如果“上一个版本”也不可见，那就得继续往前找**。还有，如果是这个事务自己更新的数据，它自己还是要认的。

所以，在实现上， **InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。**

数组里面事务 ID 的最小值记为**低水位**，当前系统里面已经创建过的事务 ID 的最大值加 1 记为**高水位**。

**！！！这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。**



<img src="" style="zoom:70%">

<img src="" style="zoom:70%">

## 总结

MySQL 的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地使用 MySQL 的事务特性。

理解：读提交(RC)，读未提交，可重复读(RR)，串行化。

还有幻读，脏读等

## Q & A

系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？

