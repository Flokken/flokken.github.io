(window.webpackJsonp=window.webpackJsonp||[]).push([[208],{534:function(v,_,t){"use strict";t.r(_);var s=t(4),a=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"引言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[v._v("#")]),v._v(" 引言")]),v._v(" "),_("p",[v._v("Redis的快，到底是快在哪里呢？实际上，这里有一个重要的表现：它接收到一个键值对操作后，能以"),_("strong",[v._v("微秒级别")]),v._v("的速度找到数据，并快速完成操作。")]),v._v(" "),_("p",[v._v("数据库这么多，为啥Redis能有这么突出的表现呢？")]),v._v(" "),_("p",[v._v("一方面，这是因为它是内存数据库，"),_("strong",[v._v("所有操作都在内存上完成，内存的访问速度本身就很快。")])]),v._v(" "),_("p",[v._v("另一方面，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，"),_("strong",[v._v("所以高效的数据结构是Redis快速处理数据的基础。")])]),v._v(" "),_("p",[v._v("Redis底层数据结构一共有6种，分别是"),_("strong",[v._v("简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组")]),v._v("。它们和数据类型的对应关系如下图所示")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231015214810889.png",alt:"image-20231015214810889"}})]),v._v(" "),_("p",[v._v("可以看到，String类型的底层实现只有一种数据结构，也就是简单动态字符串。")]),v._v(" "),_("p",[v._v("而"),_("strong",[v._v("List、Hash、Set和Sorted Set这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，"),_("strong",[v._v("它们的特点是")]),v._v("一个键对应了一个集合的数据")]),v._v("。")]),v._v(" "),_("p",[v._v("考虑如下问题：")]),v._v(" "),_("ul",[_("li",[v._v("这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？")]),v._v(" "),_("li",[v._v("为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？")]),v._v(" "),_("li",[v._v("什么是简单动态字符串，和常用的字符串是一回事吗？")])]),v._v(" "),_("p",[_("strong",[v._v("所以Redis的数据类型可以分为String和集合")])]),v._v(" "),_("h2",{attrs:{id:"键和值用什么结构组织"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#键和值用什么结构组织"}},[v._v("#")]),v._v(" 键和值用什么结构组织？")]),v._v(" "),_("p",[_("strong",[v._v("为了实现从键到值的快速访问，Redis使用了一个哈希表来保存所有键值对。")])]),v._v(" "),_("p",[v._v("一个哈希表，其实就是一个数组，"),_("strong",[v._v("数组的每个元素称为一个哈希桶")]),v._v("。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。")]),v._v(" "),_("p",[v._v("注意，**这里的哈希桶的value存储的是指针。**因此，不管数据是什么类型（字符串，数组....），哈希桶都能存，因为存的不是具体值，而是指向他们的指针")]),v._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231015220639887.png",alt:"image-20231015220639887"}}),v._v(" "),_("p",[v._v("因为这个哈希表保存了所有的键值对，所以，我也把它称为"),_("strong",[v._v("全局哈希表")]),v._v("。哈希表的最大好处很明显，就是让我们可以用O(1)的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的entry元素。")]),v._v(" "),_("h3",{attrs:{id:"为什么会慢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么会慢"}},[v._v("#")]),v._v(" 为什么会慢？")]),v._v(" "),_("p",[v._v("我们知道，哈希表虽然访问是O（1），但是写入数据时，其可能发生哈希冲突。也就是两个key的哈希值计算后，正好在一个哈希桶中。")]),v._v(" "),_("blockquote",[_("p",[v._v("毕竟，哈希桶的个数通常要少于key的数量（这是显然的，可以无穷无尽但是存储空间有限），这也就是说，难免会有一些key的哈希值对应到了同一个哈希桶中。")])]),v._v(" "),_("p",[v._v("Redis解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指"),_("strong",[v._v("同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("这里我感觉redis底层和java底层处理hash冲突思路很像")])]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231015220958357.png",alt:"image-20231015220958357"}}),v._v(" "),_("p",[v._v("但是如果冲突导致哈希链越来越长，也是一个问题。因为链上的元素只能挨个查找，速度会慢。")]),v._v(" "),_("p",[_("strong",[v._v("所以，Redis会对哈希表做rehash操作。rehash也就是增加现有的哈希桶数量（当然也就会减少冲突）")])]),v._v(" "),_("p",[v._v("具体来说：")]),v._v(" "),_("p",[v._v("Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多，Redis开始执行rehash，这个过程分为三步：")]),v._v(" "),_("ol",[_("li",[v._v("给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；")]),v._v(" "),_("li",[v._v("把哈希表1中的数据重新映射并拷贝到哈希表2中；")]),v._v(" "),_("li",[v._v("释放哈希表1的空间。")])]),v._v(" "),_("p",[v._v("到此，我们就可以从哈希表1切换到哈希表2，用增大的哈希表2保存更多数据，而原来的哈希表1留作下一次rehash扩容备用。")]),v._v(" "),_("p",[v._v("这个过程看似简单**，但是第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据都迁移完，会造成Redis线程阻塞，无法服务其他请求。**")]),v._v(" "),_("p",[v._v("因此Redis最终使用的是"),_("strong",[v._v("渐进式hash")])]),v._v(" "),_("blockquote",[_("p",[v._v("也就是用到谁了，才把他拷贝过去")])]),v._v(" "),_("p",[v._v("简单来说就是在第二步拷贝数据时，Redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有entries拷贝到哈希表2中；等处理下一个请求时，再顺带拷贝哈希表1中的下一个索引位置的entries。如下图所示：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231015221339168.png",alt:"image-20231015221339168"}})]),v._v(" "),_("p",[_("strong",[v._v("这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。")])]),v._v(" "),_("p",[v._v("String类型来说，访问到即可直接进行增删改查，是O(1)复杂度；但是集合类型的数据，访问到了还需进一步处理")]),v._v(" "),_("h3",{attrs:{id:"集合数据操作效率"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集合数据操作效率"}},[v._v("#")]),v._v(" 集合数据操作效率")]),v._v(" "),_("p",[v._v("和String类型不同，一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。")]),v._v(" "),_("p",[v._v("那么，集合的操作效率和哪些因素相关呢？")]),v._v(" "),_("ul",[_("li",[v._v("首先，"),_("strong",[v._v("与集合的底层数据结构有关")]),v._v("。例如，使用哈希表实现的集合，要比使用链表实现的集合访问效率更高。")]),v._v(" "),_("li",[v._v("其次，"),_("strong",[v._v("操作效率和这些操作本身的执行特点有关")]),v._v("，比如读写一个元素的操作要比读写所有元素的效率高。")])]),v._v(" "),_("p",[v._v("集合类型的底层数据结构主要有5种："),_("strong",[v._v("整数数组、双向链表、哈希表、压缩列表和跳表。")])]),v._v(" "),_("p",[_("strong",[v._v("整数数组和双向链表很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是O(N)")])]),v._v(" "),_("h4",{attrs:{id:"压缩列表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#压缩列表"}},[v._v("#")]),v._v(" 压缩列表")]),v._v(" "),_("p",[v._v("压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段zlbytes、zltail和zllen，分别表示列表长度、列表尾的偏移量和列表中的entry个数；压缩列表在表尾还有一个zlend，表示列表结束。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231015221703656.png",alt:"image-20231015221703656"}})]),v._v(" "),_("p",[v._v("在压缩列表中，"),_("strong",[v._v("如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)。")])]),v._v(" "),_("p",[v._v("而查找其他元素时，就没有这么高效了，"),_("strong",[v._v("只能逐个查找，此时的复杂度就是O(N)了")]),v._v("。")]),v._v(" "),_("h4",{attrs:{id:"跳表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跳表"}},[v._v("#")]),v._v(" 跳表")]),v._v(" "),_("p",[v._v("跳表在链表的基础上，"),_("strong",[v._v("增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位")]),v._v("，如下图所示：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231015221750009.png",alt:"image-20231015221750009"}})]),v._v(" "),_("p",[v._v("如果我们要在链表中查找33这个元素，只能从头开始遍历链表，查找6次，直到找到33为止。此时，复杂度是O(N)，查找效率很低。")]),v._v(" "),_("p",[v._v("为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。"),_("strong",[v._v("这些索引再通过指针指向原始的链表")])]),v._v(" "),_("p",[v._v("如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取1、27、100作为二级索引，"),_("strong",[v._v("二级索引指向一级索引。")])]),v._v(" "),_("p",[v._v("所以跳表的跳指的是查找时会来回在多级索引上跳来跳去，时间复杂度O(N)")]),v._v(" "),_("blockquote",[_("p",[v._v("解析一下二级索引下的3次，首先是找二级索引，定位到[27,100],然后跳到一级索引[27,50]，最后跳到原始链表的33,刚好3次")])]),v._v(" "),_("p",[v._v("Redis中数据结构查找的时间复杂度")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231015222058677.png",alt:"image-20231015222058677"}})]),v._v(" "),_("h4",{attrs:{id:"不同操作复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同操作复杂度"}},[v._v("#")]),v._v(" 不同操作复杂度")]),v._v(" "),_("p",[v._v("集合类型的操作类型很多，有读写单个集合元素的，例如HGET、HSET，也有操作多个元素的，例如SADD，还有对整个集合进行遍历操作的，例如SMEMBERS。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是我们选择集合类型的重要依据。")]),v._v(" "),_("p",[v._v("四字口诀，规避高复杂度操作")]),v._v(" "),_("ul",[_("li",[v._v("单元素操作是基础；")]),v._v(" "),_("li",[v._v("范围操作非常耗时；")]),v._v(" "),_("li",[v._v("统计操作通常高效；")]),v._v(" "),_("li",[v._v("例外情况只有几个。")])]),v._v(" "),_("p",[v._v("第一，"),_("strong",[v._v("单元素操作，是指每一种集合类型对单个数据实现的增删改查操作")]),v._v("。例如，Hash类型的HGET、HSET和HDEL，Set类型的SADD、SREM、SRANDMEMBER等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET和HDEL是对哈希表做操作，所以它们的复杂度都是O(1)；Set类型用哈希表作为底层数据结构时，它的SADD、SREM、SRANDMEMBER复杂度也是O(1)。")]),v._v(" "),_("blockquote",[_("p",[v._v("这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查，例如Hash类型的HMGET和HMSET，Set类型的SADD也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET增加M个元素时，复杂度就从O(1)变成O(M)了。")])]),v._v(" "),_("p",[v._v("第二，"),_("strong",[v._v("范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据")]),v._v("，比如Hash类型的HGETALL和Set类型的SMEMBERS，或者返回一个范围内的部分数据，比如List类型的LRANGE和ZSet类型的ZRANGE。"),_("strong",[v._v("这类操作的复杂度一般是O(N)，比较耗时，我们应该尽量避免")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("不过，Redis从2.8版本开始提供了SCAN系列操作（包括HSCAN，SSCAN和ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于HGETALL、SMEMBERS这类操作来说，就避免了一次性返回所有元素而导致的Redis阻塞。")])]),v._v(" "),_("p",[v._v("第三，统计操作，是指"),_("strong",[v._v("集合类型对集合中所有元素个数的记录")]),v._v("，例如LLEN和SCARD。这类操作复杂度只有O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。")]),v._v(" "),_("p",[v._v("第四，例外情况，是指某些数据结构的特殊记录，例如"),_("strong",[v._v("压缩列表和双向链表都会记录表头和表尾的偏移量")]),v._v("。这样一来，对于List类型的LPOP、RPOP、LPUSH、RPUSH这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有O(1)，可以实现快速操作。")]),v._v(" "),_("h2",{attrs:{id:"小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),_("p",[v._v("Redis之所以能快速操作键值对，一方面是因为O(1)复杂度的哈希表被广泛使用，包括String、Hash和Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set也采用了O(logN)复杂度的跳表。")]),v._v(" "),_("p",[v._v("**不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是O(N)。**这里，我的建议是："),_("strong",[v._v("用其他命令来替代")]),v._v("，例如可以用SCAN来代替，避免在Redis内部产生费时的全集合遍历操作。")]),v._v(" "),_("p",[v._v("当然，我们不能忘了复杂度较高的List类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是O(N)。因此，我的建议是："),_("strong",[v._v("因地制宜地使用List类型")]),v._v("。例如，既然它的POP/PUSH效率很高，那么就将它主要用于FIFO队列场景，而不是作为一个可以随机读写的集合。")]),v._v(" "),_("p",[v._v("Q&A：")]),v._v(" "),_("p",[v._v("1.整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么Redis还会把它们作为底层数据结构呢？")]),v._v(" "),_("p",[v._v("A："),_("strong",[v._v("整数数组和压缩列表的设计，充分体现了Redis“又快又省”特点中的“省”，也就是节省内存空间")]),v._v("。**整数数组和压缩列表都是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。因为元素是挨个连续放置的，**我们不用再通过额外的指针把元素串接起来，"),_("strong",[v._v("这就避免了额外指针带来的空间开销。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231020202418182.png",alt:"image-20231020202418182"}})]),v._v(" "),_("p",[v._v("Redis之所以采用不同的数据结构，其实是在性能和内存使用效率之间进行的平衡。")])])}),[],!1,null,null,null);_.default=a.exports}}]);