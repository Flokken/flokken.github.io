(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{414:function(v,_,t){"use strict";t.r(_);var o=t(4),s=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240331102543042.png",alt:"image-20240331102543042"}}),v._v(" "),_("h2",{attrs:{id:"虚拟内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[v._v("#")]),v._v(" 虚拟内存")]),v._v(" "),_("p",[v._v("我们都用过单片机，单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。")]),v._v(" "),_("p",[_("strong",[v._v("原因是单片机的 CPU 是直接操作内存的「物理地址」")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。")])]),v._v(" "),_("p",[v._v("关键的"),_("strong",[v._v("问题")]),v._v("是这两个程序都引用了绝对物理地址，我们应该避免这里情况")]),v._v(" "),_("p",[v._v("解决办法：")]),v._v(" "),_("p",[v._v("操作系统为每个进程分配独立的一套「"),_("strong",[v._v("虚拟地址")]),v._v("」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个"),_("strong",[v._v("前提是每个进程都不能访问物理地址。")])]),v._v(" "),_("p",[v._v("而"),_("strong",[v._v("虚拟地址落到物理地址的过程，由操作系统完成")]),v._v("，进程不用管（对进程来说是透明的）")]),v._v(" "),_("p",[v._v("操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址"),_("strong",[v._v("映射")]),v._v("起来。")]),v._v(" "),_("p",[v._v("这里就引出了两种地址的概念：")]),v._v(" "),_("ul",[_("li",[v._v("我们程序所使用的内存地址叫做"),_("strong",[v._v("虚拟内存地址")]),v._v("（"),_("em",[v._v("Virtual Memory Address")]),v._v("）")]),v._v(" "),_("li",[v._v("实际存在硬件里面的空间地址叫"),_("strong",[v._v("物理内存地址")]),v._v("（"),_("em",[v._v("Physical Memory Address")]),v._v("）。")])]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240331110837586.png",alt:"image-20240331110837586"}}),v._v(" "),_("p",[v._v("Q：操作系统如何管理虚拟地址和物理地址之间的关系？")]),v._v(" "),_("p",[v._v("主要有两种方式，分别是"),_("strong",[v._v("内存分段和内存分页")]),v._v("，分段是比较早提出的，我们先来看看内存分段。")]),v._v(" "),_("h3",{attrs:{id:"内存分段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存分段"}},[v._v("#")]),v._v(" 内存分段")]),v._v(" "),_("p",[v._v("程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。"),_("strong",[v._v("不同的段是有不同的属性的，所以就用分段（*Segmentation*）的形式把这些段分离出来。")])]),v._v(" "),_("blockquote",[_("p",[v._v("分段机制下，虚拟地址和物理地址是如何映射的？")])]),v._v(" "),_("p",[v._v("分段机制下的虚拟地址由两部分组成，"),_("strong",[v._v("段选择因子")]),v._v("和"),_("strong",[v._v("段内偏移量")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("内存分段的好处是一段内存的地址是连续的")]),v._v(" "),_("li",[v._v("内存段的大小可以不一样")])]),v._v(" "),_("p",[v._v("段选择因子和段内偏移量：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("段选择子")]),v._v("就保存在段寄存器里面。段选择子里面最重要的是"),_("strong",[v._v("段号")]),v._v("，用作段表的索引。"),_("strong",[v._v("段表")]),v._v("里面保存的是这个"),_("strong",[v._v("段的基地址、段的界限和特权等级")]),v._v("等。")]),v._v(" "),_("li",[v._v("虚拟地址中的"),_("strong",[v._v("段内偏移量")]),v._v("应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。")])]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240402164056739.png",alt:"image-20240402164056739"}}),v._v(" "),_("p",[_("strong",[v._v("内存分段存在的问题")]),v._v("：")]),v._v(" "),_("p",[_("strong",[v._v("内存碎片问题：")])]),v._v(" "),_("p",[v._v("假设有 1G 的物理内存，用户执行了多个程序，其中：")]),v._v(" "),_("ul",[_("li",[v._v("游戏占用了 512MB 内存")]),v._v(" "),_("li",[v._v("浏览器占用了 128MB 内存")]),v._v(" "),_("li",[v._v("音乐占用了 256 MB 内存。")])]),v._v(" "),_("p",[v._v("这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。")]),v._v(" "),_("p",[v._v("如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。")]),v._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240402164215902.png",alt:"image-20240402164215902"}}),v._v(" "),_("p",[v._v("内存碎片主要分为，内部内存碎片和外部内存碎片。")]),v._v(" "),_("p",[v._v("内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以"),_("strong",[v._v("不会出现内部内存碎片")]),v._v("。")]),v._v(" "),_("p",[v._v("但是由于每个段的长度不固定，"),_("strong",[v._v("所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存")]),v._v("，导致新的程序无法被装载，所以"),_("strong",[v._v("会出现外部内存碎片")]),v._v("的问题。")]),v._v(" "),_("blockquote",[_("p",[v._v("就像上面隔开的两段空间一样")])]),v._v(" "),_("p",[_("strong",[v._v("内存交换效率低问题")])]),v._v(" "),_("p",[v._v("解决「外部内存碎片」的问题就是"),_("strong",[v._v("内存交换")]),v._v("。可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。")]),v._v(" "),_("p",[v._v("内存交换空间，"),_("strong",[v._v("在 Linux 系统里，也就是我们常看到的 Swap 空间")]),v._v("，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。")]),v._v(" "),_("p",[v._v("对于多进程的系统来说，用"),_("strong",[v._v("分段的方式很容易产生内存碎片")]),v._v("，而产生内存碎片后就需要重新swap内存区域，因为磁盘访问速度比内存慢很多，所以这里显然的会有"),_("strong",[v._v("性能瓶颈")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"内存分页"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存分页"}},[v._v("#")]),v._v(" 内存分页")]),v._v(" "),_("p",[_("strong",[v._v("分段的好处就是能产生连续的内存空间")]),v._v("，但是会出现「外部内存碎片和内存交换的空间太大」的问题。")]),v._v(" "),_("p",[v._v("要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是"),_("strong",[v._v("内存分页")]),v._v("（"),_("em",[v._v("Paging")]),v._v("）。")]),v._v(" "),_("p",[_("strong",[v._v("分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小")]),v._v("。这样一个连续并且尺寸固定的内存空间，我们叫"),_("strong",[v._v("页")]),v._v("（"),_("em",[v._v("Page")]),v._v("）。")]),v._v(" "),_("ul",[_("li",[v._v("注意内存页是一个固定大小。在 Linux 下，每一页的大小为 "),_("code",[v._v("4KB")]),v._v("。")])]),v._v(" "),_("blockquote",[_("p",[v._v("Question:分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？")]),v._v(" "),_("p",[v._v("Answer: 内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而"),_("strong",[v._v("采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。")])])]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240402172052334.png",alt:"image-20240402172052334"}}),v._v(" "),_("p",[v._v("页表是存储在内存里的，"),_("strong",[v._v("内存管理单元")]),v._v(" （"),_("em",[v._v("MMU")]),v._v("）就做将虚拟内存地址转换成物理地址的工作。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个"),_("strong",[v._v("缺页异常")]),v._v("，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。")]),v._v(" "),_("p",[v._v("内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而"),_("strong",[v._v("采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。")])]),v._v(" "),_("p",[v._v("但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对"),_("strong",[v._v("内存分页机制会有内部内存碎片")]),v._v("的现象。")]),v._v(" "),_("p",[v._v("如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为"),_("strong",[v._v("换出")]),v._v("（"),_("em",[v._v("Swap Out")]),v._v("）。一旦需要的时候，再加载进来，称为"),_("strong",[v._v("换入")]),v._v("（"),_("em",[v._v("Swap In")]),v._v("）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，"),_("strong",[v._v("内存交换的效率就相对比较高。")])]),v._v(" "),_("h4",{attrs:{id:"多级页表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多级页表"}},[v._v("#")]),v._v(" 多级页表")]),v._v(" "),_("p",[v._v("在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 "),_("code",[v._v("4KB")]),v._v(" 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。")]),v._v(" "),_("p",[v._v("我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 "),_("code",[v._v("1024")]),v._v(" 个页表（二级页表），每个表（二级页表）中包含 "),_("code",[v._v("1024")]),v._v(" 个「页表项」，形成"),_("strong",[v._v("二级分页")]),v._v("。如下图所示：")]),v._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240402172228152.png",alt:"image-20240402172228152"}}),v._v(" "),_("h4",{attrs:{id:"段式内存管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#段式内存管理"}},[v._v("#")]),v._v(" 段式内存管理")]),v._v(" "),_("ul",[_("li",[v._v("先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；")]),v._v(" "),_("li",[v._v("接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；")])]),v._v(" "),_("p",[v._v("这样，地址结构就由"),_("strong",[v._v("段号、段内页号和页内位移")]),v._v("三部分组成。")]),v._v(" "),_("p",[v._v("用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240402172311880.png",alt:"image-20240402172311880"}})])])}),[],!1,null,null,null);_.default=s.exports}}]);