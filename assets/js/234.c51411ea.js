(window.webpackJsonp=window.webpackJsonp||[]).push([[234],{562:function(s,n,t){"use strict";t.r(n);var a=t(4),e=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("blockquote",[n("p",[s._v("开始学习这个课程的时候，我的心情很复杂，认真学习计算机知识最好的时间是大学本科，其次是现在。回过头去看，我发现自己基本上什么也不会。")]),s._v(" "),n("p",[s._v("本科时卷绩点，卷一些毫无用处的东西，浪费了时间，浪费了精力，也导致了我狭隘的目光。记得21年的时候看知乎，推荐去看国外的课程，那时候却不以为然，浪费了大把时间。如今已经到了23年了，真的马上就业了才想起了主动学习的重要性，才来恶补。")]),s._v(" "),n("p",[s._v("劝君莫惜金缕衣，劝君惜取少年时。如今回头看20年-22年的自己，的确是虚度了，时不我待啊。")])]),s._v(" "),n("p",[s._v("这里只介绍一些如果没做过项目，C++里可能不是很清楚的一些语法。")]),s._v(" "),n("blockquote",[n("p",[s._v("参考：https://subingwen.cn/cplusplus/")]),s._v(" "),n("p",[s._v("<<黑马教程C++>>")]),s._v(" "),n("p",[s._v("C++11")]),s._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"http://www.thegeekstuff.com/2016/02/c-plus-plus-11/",target:"_blank",rel:"noopener noreferrer"}},[s._v("short tutorial"),n("OutboundLink")],1)]),s._v(" "),n("li",[n("a",{attrs:{href:"https://en.cppreference.com/w/",target:"_blank",rel:"noopener noreferrer"}},[s._v("cppreference"),n("OutboundLink")],1)])]),s._v(" "),n("p",[s._v("调试工具：gdb")]),s._v(" "),n("p",[s._v("在ubuntun上装了很久失败，centos一个yum命令搞定，果然不能轴。。。。")])]),s._v(" "),n("h2",{attrs:{id:"内存分区模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存分区模型"}},[s._v("#")]),s._v(" 内存分区模型")]),s._v(" "),n("p",[s._v("C++程序在执行时，将内存大方向划分为"),n("strong",[s._v("4个区域")])]),s._v(" "),n("ul",[n("li",[s._v("代码区：存放函数体的二进制代码，由操作系统进行管理的")]),s._v(" "),n("li",[s._v("全局区：存放全局变量和静态变量以及常量")]),s._v(" "),n("li",[s._v("栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等")]),s._v(" "),n("li",[s._v("堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收")])]),s._v(" "),n("h3",{attrs:{id:"程序运行前"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#程序运行前"}},[s._v("#")]),s._v(" 程序运行前")]),s._v(" "),n("p",[s._v("在程序编译后，生成了exe可执行程序，"),n("strong",[s._v("未执行该程序前")]),s._v("分为两个区域")]),s._v(" "),n("p",[s._v("​\t"),n("strong",[s._v("代码区：")])]),s._v(" "),n("ul",[n("li",[n("p",[s._v("存放 CPU 执行的机器指令")])]),s._v(" "),n("li",[n("p",[s._v("代码区是"),n("strong",[s._v("共享")]),s._v("的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可")])]),s._v(" "),n("li",[n("p",[s._v("代码区是"),n("strong",[s._v("只读")]),s._v("的，使其只读的原因是防止程序意外地修改了它的指令")])])]),s._v(" "),n("p",[s._v("​\t"),n("strong",[s._v("全局区：")])]),s._v(" "),n("ul",[n("li",[n("p",[s._v("全局变量和静态变量")])]),s._v(" "),n("li",[n("p",[s._v('常量区： const修饰的全局常量  和 字符串常量比如（"aaaa"）')])]),s._v(" "),n("li",[n("p",[s._v("==该区域的数据在程序结束后由操作系统释放==.")])])]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//全局变量\nint g_a = 10;\nint g_b = 10;\n\n//全局常量\nconst int c_g_a = 10;\nconst int c_g_b = 10;\n\nint main() {\n\n\t//局部变量\n\tint a = 10;\n\tint b = 10;\n\n\t//打印地址\n\tcout << "局部变量a地址为： " << (int)&a << endl;\n\tcout << "局部变量b地址为： " << (int)&b << endl;\n\n\tcout << "全局变量g_a地址为： " <<  (int)&g_a << endl;\n\tcout << "全局变量g_b地址为： " <<  (int)&g_b << endl;\n\n\t//静态变量\n\tstatic int s_a = 10;\n\tstatic int s_b = 10;\n\n\tcout << "静态变量s_a地址为： " << (int)&s_a << endl;\n\tcout << "静态变量s_b地址为： " << (int)&s_b << endl;\n\n\tcout << "字符串常量地址为： " << (int)&"hello world" << endl;\n\tcout << "字符串常量地址为： " << (int)&"hello world1" << endl;\n\n\tcout << "全局常量c_g_a地址为： " << (int)&c_g_a << endl;\n\tcout << "全局常量c_g_b地址为： " << (int)&c_g_b << endl;\n\n\tconst int c_l_a = 10;\n\tconst int c_l_b = 10;\n\tcout << "局部常量c_l_a地址为： " << (int)&c_l_a << endl;\n\tcout << "局部常量c_l_b地址为： " << (int)&c_l_b << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br")])]),n("p",[s._v("打印结果：")]),s._v(" "),n("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231129144617000.png",alt:"image-20231129144617000"}}),s._v(" "),n("h3",{attrs:{id:"程序运行后"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#程序运行后"}},[s._v("#")]),s._v(" 程序运行后")]),s._v(" "),n("blockquote",[n("p",[s._v("这里和jvm运行时划分的堆和栈感觉很像")])]),s._v(" "),n("p",[n("strong",[s._v("栈区：")])]),s._v(" "),n("ul",[n("li",[n("p",[s._v("由编译器自动分配释放, 存放函数的参数值,局部变量等")])]),s._v(" "),n("li",[n("p",[s._v("注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放")])])]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('int * func()\n{\n\tint a = 10;\n\treturn &a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("p",[n("strong",[s._v("堆区：")])]),s._v(" "),n("ul",[n("li",[n("p",[s._v("由程序员分配释放,若程序员不释放,程序结束时由操作系统回收")])]),s._v(" "),n("li",[n("p",[n("strong",[s._v("在C++中主要利用new在堆区开辟内存")])])])]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('int* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n    \n\tsystem("pause");\n\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("h3",{attrs:{id:"new与delete操作符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new与delete操作符"}},[s._v("#")]),s._v(" new与delete操作符")]),s._v(" "),n("p",[s._v("C++中利用==new==操作符在堆区开辟数据（也就是申请空间），释放利用操作符 ==delete==（也就是释放空间）")]),s._v(" "),n("p",[s._v("语法："),n("code",[s._v("new 数据类型")])]),s._v(" "),n("p",[s._v("利用new创建的数据，会返回该数据对应的类型的指针")]),s._v(" "),n("p",[n("strong",[s._v("示例：开辟数组")])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//堆区开辟数组\nint main() {\n\n\tint* arr = new int[10];\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tarr[i] = i + 100;\n\t}\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n\t//释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br")])]),n("h3",{attrs:{id:"引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[s._v("#")]),s._v(" 引用")]),s._v(" "),n("p",[s._v("作用：在C++里就是给变量起别名。")]),s._v(" "),n("p",[s._v("语法："),n("code",[s._v("数据类型 &别名 = 原名")])]),s._v(" "),n("p",[s._v("本质：在C++内部实现是一个指针常量.")]),s._v(" "),n("blockquote",[n("p",[s._v("所以传引用和传指针是一个效果")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//编译器发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n    \n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint& ref = a; \n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n    \n\tcout << "a:" << a << endl;\n\tcout << "ref:" << ref << endl;\n    \n\tfunc(a);\n    \n    \n    //特殊，常量引用，引用不能直接赋常量，但是加了const可以，具体如下：\n    //int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br")])]),n("p",[s._v("注意事项：")]),s._v(" "),n("ul",[n("li",[s._v("引用必须初始化")]),s._v(" "),n("li",[s._v("引用在初始化后，不可以改变（因为是指针常量）")])]),s._v(" "),n("h2",{attrs:{id:"函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[s._v("#")]),s._v(" 函数")]),s._v(" "),n("h3",{attrs:{id:"默认参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#默认参数"}},[s._v("#")]),s._v(" 默认参数")]),s._v(" "),n("p",[s._v("在C++中，函数的形参列表中的形参是可以有默认值的。")]),s._v(" "),n("p",[s._v("语法："),n("code",[s._v("返回值类型 函数名 （参数= 默认值）{}")])]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('int func(int a, int b = 10, int c = 10) {\n\treturn a + b + c;\n}\n\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a = 10, int b = 10);\nint func2(int a, int b) {\n\treturn a + b;\n}\n\nint main() {\n\n\tcout << "ret = " << func(20, 20) << endl;\n\tcout << "ret = " << func(100) << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("h3",{attrs:{id:"占位参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#占位参数"}},[s._v("#")]),s._v(" 占位参数")]),s._v(" "),n("p",[s._v("C++中函数的形参列表里可以有占位参数，"),n("strong",[s._v("用来做占位，调用函数时必须填补该位置")])]),s._v(" "),n("p",[n("strong",[s._v("语法：")]),s._v(" "),n("code",[s._v("返回值类型 函数名 (数据类型){}")])]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) {\n\tcout << "this is func" << endl;\n}\n\nint main() {\n\n\tfunc(10,10); //占位参数必须填补\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("h3",{attrs:{id:"重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重载"}},[s._v("#")]),s._v(" 重载")]),s._v(" "),n("blockquote",[n("p",[s._v("和java重载基本一致，")])]),s._v(" "),n("p",[s._v("**作用：**函数名可以相同，提高复用性")]),s._v(" "),n("p",[n("strong",[s._v("函数重载满足条件：")])]),s._v(" "),n("ul",[n("li",[s._v("同一个作用域下")]),s._v(" "),n("li",[s._v("函数名称相同")]),s._v(" "),n("li",[s._v("函数参数"),n("strong",[s._v("类型不同")]),s._v("  或者 "),n("strong",[s._v("个数不同")]),s._v(" 或者 "),n("strong",[s._v("顺序不同")])])]),s._v(" "),n("p",[n("strong",[s._v("注意:")]),s._v("  函数的返回值不可以作为函数重载的条件")]),s._v(" "),n("h2",{attrs:{id:"面对对象设计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#面对对象设计"}},[s._v("#")]),s._v(" 面对对象设计")]),s._v(" "),n("p",[s._v("高级程序设计语言里的类和继承的概念都大差不差。C++面对对象的三大特性分别是："),n("strong",[s._v("封装，继承，多态")])]),s._v(" "),n("blockquote",[n("p",[s._v("C++也是一切皆对象，对象有其属性和行为")])]),s._v(" "),n("h3",{attrs:{id:"封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[s._v("#")]),s._v(" 封装")]),s._v(" "),n("ul",[n("li",[s._v("将属性和行为作为一个整体，表现生活中的事物")]),s._v(" "),n("li",[n("strong",[s._v("将属性和行为加以权限控制")])])]),s._v(" "),n("h3",{attrs:{id:"类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[s._v("#")]),s._v(" 类")]),s._v(" "),n("h4",{attrs:{id:"struct和class的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#struct和class的区别"}},[s._v("#")]),s._v(" Struct和class的区别")]),s._v(" "),n("p",[s._v("在C++中 struct和class唯一的"),n("strong",[s._v("区别")]),s._v("就在于 "),n("strong",[s._v("默认的访问权限不同")])]),s._v(" "),n("p",[s._v("区别：")]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("struct 默认权限为公共")])]),s._v(" "),n("li",[n("strong",[s._v("class   默认权限为私有")])])]),s._v(" "),n("h4",{attrs:{id:"构造函数与析构函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数与析构函数"}},[s._v("#")]),s._v(" 构造函数与析构函数")]),s._v(" "),n("ul",[n("li",[s._v("构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。")]),s._v(" "),n("li",[s._v("析构函数：主要作用在于对象"),n("strong",[s._v("销毁前")]),s._v("系统自动调用，执行一些清理工作。")])]),s._v(" "),n("p",[n("strong",[s._v("构造函数语法：")]),n("code",[s._v("类名(){}")])]),s._v(" "),n("ol",[n("li",[s._v("构造函数，没有返回值也不写void")]),s._v(" "),n("li",[s._v("函数名称与类名相同")]),s._v(" "),n("li",[s._v("构造函数可以有参数，因此可以发生重载")]),s._v(" "),n("li",[s._v("程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次")])]),s._v(" "),n("blockquote",[n("p",[s._v("构造函数处理无参构造函数，还有有参构造函数和拷贝构造函数")]),s._v(" "),n("p",[s._v("其中拷贝构造函数调用时机：")]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("使用一个已经创建完毕的对象来初始化一个新对象")])]),s._v(" "),n("li",[s._v("值传递的方式给函数参数传值")]),s._v(" "),n("li",[s._v("以值方式返回局部对象")])])]),s._v(" "),n("p",[n("strong",[s._v("析构函数语法：")]),s._v(" "),n("code",[s._v("~类名(){}")])]),s._v(" "),n("ol",[n("li",[s._v("析构函数，没有返回值也不写void")]),s._v(" "),n("li",[s._v("函数名称与类名相同,在名称前加上符号  ~")]),s._v(" "),n("li",[s._v("析构函数不可以有参数，因此不可以发生重载")]),s._v(" "),n("li",[s._v("程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次")])]),s._v(" "),n("p",[s._v("举例")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('//1、构造函数分类\n// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n// 按照类型分类分为 普通构造和拷贝构造\n\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << "无参构造函数!" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << "有参构造函数!" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << "拷贝构造函数!" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << "析构函数!" << endl;\n\t}\npublic:\n\tint age;\n};\n//2、构造函数的调用\n//调用无参构造函数\nvoid test01() {\n\tPerson p; //调用无参构造函数\n}\n//调用有参的构造函数\nvoid test02() {\n\t//2.1  括号法，常用\n\tPerson p1(10);\n\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t//所以无参构造函数直接这么写，Person p1；\n\t//2.2 显式法\n    //嗲用普通构造函数\n\tPerson p2 = Person(10); \n    //调用拷贝构造函数\n\tPerson p3 = Person(p2);\n    //2.3直接复制\n\tPerson p4 = 10; /0); \n    //注意这里，如果有指针类型变量，需要我们实现拷贝构造函数来实现深拷贝\n\tPerson p5 = p4;\n\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br")])]),n("p",[n("strong",[s._v("注意：")])]),s._v(" "),n("ul",[n("li",[s._v("如果没有实现构造函数或者析构函数，编译器会自动给这个类实现一个空的构造函数或者析构函数")]),s._v(" "),n("li",[s._v("如果类的成员中还有类，比如A类有成员变量B类，那么构造函数和析构函数顺序是\n"),n("ul",[n("li",[s._v("创建一个A类对象时，先调用B类构造方法，再调用A类构造方法")]),s._v(" "),n("li",[s._v("释放一个A类对象时，先调用A类析构方法，再调用B类析构方法")])])])]),s._v(" "),n("h5",{attrs:{id:"深拷贝和浅拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[s._v("#")]),s._v(" 深拷贝和浅拷贝")]),s._v(" "),n("blockquote",[n("p",[s._v("很经典的问题，需要掌握")])]),s._v(" "),n("p",[s._v("浅拷贝：简单的赋值拷贝操作，编译器会自己实现")]),s._v(" "),n("p",[s._v("深拷贝：在堆区重新申请空间，进行拷贝操作。其实就是要我们写一个拷贝构造函数。")]),s._v(" "),n("p",[s._v("区别："),n("strong",[s._v("在未定义拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝（不用自己构造），它能够完成成员的简单的值的拷贝一一复制。"),n("strong",[s._v("当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址（同一个堆区），"),n("strong",[s._v("当对象快结束时，会调用两次析构函数")]),s._v("（析构函数也无需自己构造，但想要知道析构函数的工作可以自己构造析构函数用输出来记录），而导致")]),s._v("指针悬挂")]),s._v("现象，所以，此时，必须采用深拷贝。")]),s._v(" "),n("p",[n("strong",[s._v("注：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题")])]),s._v(" "),n("blockquote",[n("p",[s._v("什么叫属性在堆开辟空间？我们知道java有引用类型，就是存在堆中的，这里C++里其实就是指针类型的属性，就需要在堆里开辟空间。")]),s._v(" "),n("p",[s._v("简而言之，"),n("strong",[s._v("如果我们类的属性有指针类型，就要我们必须实现一个拷贝构造函数。")])])]),s._v(" "),n("p",[s._v("示例:下面的person中就有一个属性"),n("code",[s._v("m_heigth")]),s._v("，那么我就需要实现拷贝构造函数来实现深拷贝")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << "无参构造函数!" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int age ,int height) {\n\t\tcout << "有参构造函数!" << endl;\n\t\tm_age = age;\n\t\tm_height = new int(height);\n\t\t\n\t}\n\t//拷贝构造函数  \n\tPerson(const Person& p) {\n\t\tcout << "拷贝构造函数!" << endl;\n\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题，然后造成指针悬挂\n\t\tm_age = p.m_age;\n\t\tm_height = new int(*p.m_height);\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << "析构函数!" << endl;\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete m_height;\n\t\t}\n\t}\npublic:\n\tint m_age;\n\tint* m_height;\n};\n\nvoid test01()\n{\n\tPerson p1(18, 180);\n\tPerson p2(p1);\n\tcout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;\n\tcout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br")])]),n("h5",{attrs:{id:"初始化列表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化列表"}},[s._v("#")]),s._v(" 初始化列表")]),s._v(" "),n("p",[s._v("C++提供了初始化列表语法，用来初始化属性。也就是更方便的构造函数")]),s._v(" "),n("p",[n("strong",[s._v("语法：")]),n("code",[s._v("构造函数()：属性1(值1),属性2（值2）... {}")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public:\n\t//传统方式初始化\n\tPerson(int a, int b, int c) {\n\t\tm_A = a;\n\t\tm_B = b;\n\t\tm_C = c;\n\t}\n\n\t//初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\n//Person p(1, 2, 3);调用时还是一样的\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("h4",{attrs:{id:"静态成员"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#静态成员"}},[s._v("#")]),s._v(" 静态成员")]),s._v(" "),n("p",[s._v("静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员")]),s._v(" "),n("p",[s._v("静态成员分为：")]),s._v(" "),n("ul",[n("li",[s._v("静态成员变量\n"),n("ul",[n("li",[s._v("所有对象共享同一份数据")]),s._v(" "),n("li",[s._v("在编译阶段分配内存")]),s._v(" "),n("li",[s._v("类内声明，类外初始化")])])]),s._v(" "),n("li",[s._v("静态成员函数\n"),n("ul",[n("li",[s._v("所有对象共享同一个函数")]),s._v(" "),n("li",[n("strong",[s._v("静态成员函数只能访问静态成员变量")])])])])]),s._v(" "),n("p",[s._v("静态函数与静态变量访问方式：")]),s._v(" "),n("ul",[n("li",[s._v("对象访问与类名访问")])]),s._v(" "),n("p",[s._v("举例")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class Person\n{\n\t\npublic:\n\tstatic int m_A; //静态成员变量\n\tstatic void func()\n\t{\t//只能访问静态成员变量\n\t\tcout << "func调用" << endl;\n\t\tm_A = 100;\n\t}\nprivate:\n\tstatic int m_B; //静态成员变量也是有访问权限的\n};\n//类里面声明，类外面初始化\nint Person::m_A = 10;\nint Person::m_B = 10;\nint main{\n   //1.对象访问\n    Person p1;\n\tcout << "p1.m_A = " << p1.m_A << endl;\n\t//2、通过类名\n\tcout << "m_A = " << Person::m_A << endl;\n    return 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br")])]),n("blockquote",[n("p",[s._v("除了静态成员，还有两种特殊的成员，遇到再来补充吧")]),s._v(" "),n("p",[n("strong",[s._v("常函数：")])]),s._v(" "),n("ul",[n("li",[s._v("成员函数后加const后我们称为这个函数为"),n("strong",[s._v("常函数")])]),s._v(" "),n("li",[s._v("常函数内不可以修改成员属性")]),s._v(" "),n("li",[s._v("成员属性声明时加关键字mutable后，在常函数中依然可以修改")])]),s._v(" "),n("p",[n("strong",[s._v("常对象：")])]),s._v(" "),n("ul",[n("li",[s._v("声明对象前加const称该对象为常对象")]),s._v(" "),n("li",[s._v("常对象只能调用常函数")])])]),s._v(" "),n("h4",{attrs:{id:"this指针"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this指针"}},[s._v("#")]),s._v(" this指针")]),s._v(" "),n("p",[s._v("记住："),n("strong",[s._v("C++的this指针指向被调用的成员函数所属的对象")])]),s._v(" "),n("h3",{attrs:{id:"多态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[s._v("#")]),s._v(" 多态")]),s._v(" "),n("p",[n("strong",[s._v("多态是C++面向对象三大特性之一")])]),s._v(" "),n("blockquote",[n("p",[s._v("有些名词会混用：")]),s._v(" "),n("p",[s._v("父类=基类，子类=派生类")])]),s._v(" "),n("p",[n("strong",[s._v("多态分为两类")])]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名")])]),s._v(" "),n("li",[n("strong",[s._v("动态多态: 派生类和虚函数实现运行时多态")])])]),s._v(" "),n("p",[s._v("静态多态和动态多态区别：")]),s._v(" "),n("ul",[n("li",[s._v("静态多态的函数地址早绑定  -  编译阶段确定函数地址")]),s._v(" "),n("li",[s._v("动态多态的函数地址晚绑定  -  运行阶段确定函数地址")])]),s._v(" "),n("h4",{attrs:{id:"虚函数与抽象类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚函数与抽象类"}},[s._v("#")]),s._v(" 虚函数与抽象类")]),s._v(" "),n("p",[s._v("在实现c++多态时会用到虚函数。"),n("strong",[s._v("虚函数使用的其核心目的是通过基类通过指针访问派生类定义的函数，但是不代表他不被实现。")])]),s._v(" "),n("p",[n("strong",[s._v("纯虚函数才代表这个函数没有被实现")]),s._v("，（纯虚函数可以理解为接口）")]),s._v(" "),n("blockquote",[n("p",[s._v("父类中实现虚函数是毫无意义的，"),n("strong",[s._v("主要都是调用子类重写的内容")]),s._v("，所以我们常常使用纯虚函数")])]),s._v(" "),n("p",[s._v("虚函数与纯虚函数区别：")]),s._v(" "),n("ul",[n("li",[s._v("虚函数：父类可以有实现也可以没有实现，子类可以实现他也可以不实现他")]),s._v(" "),n("li",[s._v("纯虚函数：父类只能被声明，只能在子类实现，并且必须实现。（类似于接口）")])]),s._v(" "),n("p",[s._v("纯虚函数语法："),n("code",[s._v("virtual 返回值类型 函数名 （参数列表）= 0 ;")]),n("strong",[s._v("当类中有了纯虚函数，这个类也称为==抽象类==")])]),s._v(" "),n("p",[n("strong",[s._v("抽象类特点")]),s._v("：")]),s._v(" "),n("ul",[n("li",[s._v("无法实例化对象")]),s._v(" "),n("li",[s._v("子类必须重写抽象类中的纯虚函数，否则也属于抽象类")])]),s._v(" "),n("p",[s._v("举例")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class Base\n{\npublic:\n\t//纯虚函数\n\t//类中只要有一个纯虚函数就称为抽象类\n\t//抽象类无法实例化对象\n\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() = 0;\n};\n\nclass Son :public Base\n{\npublic:\n    //实现了纯虚函数\n\tvirtual void func() \n\t{\n\t\tcout << "func调用" << endl;\n\t};\n};\n\nvoid test01()\n{\n\tBase * base = NULL;\n\t//base = new Base; // 错误，抽象类无法实例化对象\n\tbase = new Son;\n\tbase->func();//父类指针可以调用子类实现的函数，靠的就是多态，也是虚函数\n\tdelete base;//记得销毁\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br")])]),n("h4",{attrs:{id:"虚析构和纯虚析构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚析构和纯虚析构"}},[s._v("#")]),s._v(" 虚析构和纯虚析构")]),s._v(" "),n("p",[s._v("多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码")]),s._v(" "),n("p",[n("strong",[s._v("解决方式：将父类中的析构函数改为虚析构或者纯虚析构（就是加上virtual关键字）")])]),s._v(" "),n("p",[s._v("虚析构和纯虚析构共性：")]),s._v(" "),n("ul",[n("li",[s._v("可以解决父类指针释放子类对象")]),s._v(" "),n("li",[s._v("都需要有具体的函数实现")])]),s._v(" "),n("p",[s._v("虚析构和纯虚析构区别：")]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("如果是纯虚析构，该类属于抽象类，无法实例化对象（和纯虚函数一个特性，因为纯虚析构函数）")])])]),s._v(" "),n("p",[s._v("虚析构语法：")]),s._v(" "),n("p",[n("code",[s._v("virtual ~类名(){}")])]),s._v(" "),n("p",[s._v("纯虚析构语法：")]),s._v(" "),n("p",[n("code",[s._v("virtual ~类名() = 0;")])]),s._v(" "),n("p",[n("code",[s._v("类名::~类名(){}")])]),s._v(" "),n("p",[s._v("总结：")]),s._v(" "),n("p",[s._v("​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象")]),s._v(" "),n("p",[s._v("​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构")]),s._v(" "),n("p",[s._v("​\t3. 拥有纯虚析构函数的类也属于抽象类")]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class Animal {\npublic:\n\tAnimal()\n\t{\n\t\tcout << "Animal 构造函数调用！" << endl;\n\t}\n\tvirtual void Speak() = 0;\n\t//析构函数加上virtual关键字，变成虚析构函数\n\t//virtual ~Animal()\n\t//{\n\t//\tcout << "Animal虚析构函数调用！" << endl;\n\t//}\n\tvirtual ~Animal() = 0;\n};\n\nAnimal::~Animal()\n{\n\tcout << "Animal 纯虚析构函数调用！" << endl;\n}\n//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\nclass Cat : public Animal {\npublic:\n\tCat(string name)\n\t{\n\t\tcout << "Cat构造函数调用！" << endl;\n\t\tm_Name = new string(name);\n\t}\n\tvirtual void Speak()\n\t{\n\t\tcout << *m_Name <<  "小猫在说话!" << endl;\n\t}\n\t~Cat()\n\t{\n\t\tcout << "Cat析构函数调用!" << endl;\n\t\tif (this->m_Name != NULL) {\n\t\t\tdelete m_Name;\n\t\t\tm_Name = NULL;\n\t\t}\n\t}\npublic:\n\tstring *m_Name;\n};\nvoid test01()\n{\n\tAnimal *animal = new Cat("Tom");\n\tanimal->Speak();\n\n\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t//怎么解决？给基类增加一个虚析构函数\n\t//虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br")])]),n("h2",{attrs:{id:"模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模板"}},[s._v("#")]),s._v(" 模板")]),s._v(" "),n("blockquote",[n("p",[s._v("这里应该联想到java的泛型")])]),s._v(" "),n("p",[s._v("C++的模板"),n("strong",[s._v("是泛型编程的体现")]),s._v("，有两种模板机制：")]),s._v(" "),n("ul",[n("li",[s._v("函数模板")]),s._v(" "),n("li",[s._v("类模板")])]),s._v(" "),n("h3",{attrs:{id:"函数模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数模板"}},[s._v("#")]),s._v(" 函数模板")]),s._v(" "),n("p",[s._v("建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个"),n("strong",[s._v("虚拟的类型")]),s._v("来代表。")]),s._v(" "),n("p",[n("strong",[s._v("语法：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("template<typename T>\n函数声明或定义\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[n("strong",[s._v("解释：")])]),s._v(" "),n("p",[s._v("template  ---  声明创建模板")]),s._v(" "),n("p",[s._v("typename  --- 表面其后面的符号是一种数据类型，可以用class代替")]),s._v(" "),n("p",[s._v("T    ---   通用的数据类型，名称可以替换，通常为大写字母")]),s._v(" "),n("p",[s._v("总结：")]),s._v(" "),n("ul",[n("li",[s._v("函数模板利用关键字 template")]),s._v(" "),n("li",[s._v("使用函数模板有两种方式："),n("strong",[s._v("自动类型推导、显示指定类型")])]),s._v(" "),n("li",[s._v("模板的目的是为了提高复用性，将类型参数化")])]),s._v(" "),n("p",[s._v("注意：对于函数模板来说，"),n("strong",[s._v("使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型")]),s._v("，否则会失败，详见下面的例子")]),s._v(" "),n("p",[n("strong",[s._v("示例：利用模板实现元素交换")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//1。如果不用模板，我们对于不同类型的变量，需要分别写函数\n//交换整型函数\nvoid swapInt(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//交换浮点型函数\nvoid swapDouble(double& a, double& b) {\n\tdouble temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2.利用模板提供通用的交换函数（感觉就是不指定类型，用一个壳子来代指他们，和java泛型用起来一样，但是底层实现不一样）\ntemplate<typename T>\nvoid mySwap(T& a, T& b)\n{\n\tT temp = a;\n\ta = b;\n\tb = temp;\n}\n\nvoid test01()\n{\n\tint a = 10;\n\tint b = 20;\n    int c='c';\n\t//swapInt(a, b);\n\t//利用模板实现交换\n\t//1、自动类型推导\n\tmySwap(a, b);\n\t//2、显示指定类型\n\tmySwap<int>(a, b);\n    \n    //推导类型注意事项\n\t//自动推导不出一样的类型会失败\t\n//    mysSwap(a,c)\n//mySwap<int>(a,c)可以成功\n\n}\nint main() {\n\ttest01();\n\tsystem(\"pause\");\n\treturn 0;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br")])]),n("p",[s._v("在函数模板调用时，会有类型转化相关的疑问，可以对比普通函数类型转换来看：")]),s._v(" "),n("ul",[n("li",[s._v("普通函数调用时可以发生自动类型转换（隐式类型转换）")]),s._v(" "),n("li",[s._v("函数模板调用时，"),n("strong",[s._v("如果利用自动类型推导，不会发生隐式类型转换")])]),s._v(" "),n("li",[s._v("如果利用显示指定类型的方式，可以发生隐式类型转换,比如上面的"),n("code",[s._v("mySwap<int>(a,c)")]),s._v(",c是char类型，这里会强制转换为"),n("code",[s._v("int")])])]),s._v(" "),n("h4",{attrs:{id:"局限"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#局限"}},[s._v("#")]),s._v(" 局限")]),s._v(" "),n("h3",{attrs:{id:"类模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类模板"}},[s._v("#")]),s._v(" 类模板")]),s._v(" "),n("p",[s._v("类模板作用：")]),s._v(" "),n("ul",[n("li",[s._v("建立一个通用类，"),n("strong",[s._v("类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。")])])]),s._v(" "),n("p",[n("strong",[s._v("语法：")])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("template<typename T>\n类\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[n("strong",[s._v("解释：")])]),s._v(" "),n("p",[s._v("template  ---  声明创建模板")]),s._v(" "),n("p",[s._v("typename  --- 表面其后面的符号是一种数据类型，可以用class代替")]),s._v(" "),n("p",[s._v("T    ---   通用的数据类型，名称可以替换，通常为大写字母")]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('#include <string>\n//类模板\ntemplate<class NameType, class AgeType> \nclass Person\n{\npublic:\n\tPerson(NameType name, AgeType age)\n\t{\n\t\tthis->mName = name;\n\t\tthis->mAge = age;\n\t}\n\tvoid showPerson()\n\t{\n\t\tcout << "name: " << this->mName << " age: " << this->mAge << endl;\n\t}\npublic:\n    //看这里，类模板中这些元素没有一个确定的类型，而是自己定义的类型\n\tNameType mName;\n\tAgeType mAge;\n};\n\nvoid test01()\n{\n\t// 指定NameType 为string类型，AgeType 为 int类型\n\tPerson<string, int>P1("孙悟空", 999);\n\tP1.showPerson();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br")])]),n("p",[s._v("总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板")]),s._v(" "),n("h4",{attrs:{id:"类模板与函数模板区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类模板与函数模板区别"}},[s._v("#")]),s._v(" 类模板与函数模板区别")]),s._v(" "),n("p",[s._v("类模板与函数模板区别主要有两点：")]),s._v(" "),n("ol",[n("li",[s._v("类模板没有自动类型推导的使用方式（类模板必须指定类型）")]),s._v(" "),n("li",[s._v("类模板在模板参数列表中可以有默认参数")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('#include <string>\n//类模板\ntemplate<class NameType, class AgeType = int> \nclass Person\n{\npublic:\n\tPerson(NameType name, AgeType age)\n\t{\n\t\tthis->mName = name;\n\t\tthis->mAge = age;\n\t}\n\tvoid showPerson()\n\t{\n\t\tcout << "name: " << this->mName << " age: " << this->mAge << endl;\n\t}\npublic:\n\tNameType mName;\n\tAgeType mAge;\n};\n\n//1、类模板没有自动类型推导的使用方式\nvoid test01()\n{\n\t// Person p("孙悟空", 1000); // 错误 类模板使用时候，不可以用自动类型推导\n\tPerson <string ,int>p("孙悟空", 1000); //必须使用显示指定类型的方式，使用类模板\n\tp.showPerson();\n}\n//2、类模板在模板参数列表中可以有默认参数\nvoid test02()\n{\n\tPerson <string> p("猪八戒", 999); //类模板中的模板参数列表 可以指定默认参数\n\tp.showPerson();\n}\nint main() {\n\ttest01();\n\ttest02();\n\tsystem("pause");\n\treturn 0;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br")])]),n("h2",{attrs:{id:"智能指针"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#智能指针"}},[s._v("#")]),s._v(" 智能指针")]),s._v(" "),n("p",[s._v("在C++中没有垃圾回收机制，必须自己释放(delete)分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。")]),s._v(" "),n("p",[s._v("智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。"),n("strong",[s._v("智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。")])]),s._v(" "),n("blockquote",[n("p",[s._v("background：")]),s._v(" "),n("p",[s._v("C++栈上的内存可以编译器，编译器释放。堆上的内存是手动申请，手动释放。（手动释放很容易搞错，所以引入智能指针）")]),s._v(" "),n("p",[s._v("java：")]),s._v(" "),n("p",[s._v("释放内存都是自动的，因为有垃圾回收机制。")])]),s._v(" "),n("p",[s._v("分类：")]),s._v(" "),n("p",[s._v("C++11之前：auto_ptr")]),s._v(" "),n("p",[s._v("C++11之后：auto_ptr被弃用，引用三个智能指针，也是我们重点学习的")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("std::shared_ptr：共享的智能指针")])]),s._v(" "),n("li",[n("p",[s._v("std::unique_ptr：独占的智能指针")])]),s._v(" "),n("li",[n("p",[s._v("std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。")])])]),s._v(" "),n("h3",{attrs:{id:"shared-ptr"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#shared-ptr"}},[s._v("#")]),s._v(" shared_ptr")]),s._v(" "),n("p",[n("strong",[s._v("共享智能指针是指多个智能指针可以同时管理同一块有效的内存")]),s._v("，共享智能指针"),n("code",[s._v("shared_ptr")]),s._v(" 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。"),n("strong",[s._v("共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存")]),s._v("，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数"),n("code",[s._v("use_count")]),s._v("，函数原型如下：")]),s._v(" "),n("blockquote",[n("p",[s._v("这里要注意，共享指针的make_shared等拷贝构造函数来构造一个新共享指针时，其指向的底层数据是不会被复制的，共享指针和普通指针一样，也就是一个指针。")]),s._v(" "),n("p",[n("strong",[s._v("所以对于建个共享指针变量，如果都指向一个空间，其实就相当于起了个别名")])])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。\nlong use_count() const noexcept;\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("h4",{attrs:{id:"初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[s._v("#")]),s._v(" "),n("strong",[s._v("初始化")])]),s._v(" "),n("ul",[n("li",[s._v("构造函数初始化")]),s._v(" "),n("li",[s._v("通过std::make_shared初始化")]),s._v(" "),n("li",[s._v("通过拷贝和移动构造函数初始化")])]),s._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://subingwen.cn/cpp/shared_ptr/",target:"_blank",rel:"noopener noreferrer"}},[s._v("共享智能指针 | 爱编程的大丙 (subingwen.cn)"),n("OutboundLink")],1)])]),s._v(" "),n("p",[n("strong",[s._v("构造函数初始化和通过拷贝和移动构造函数初始化")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('#include <iostream>\n#include <memory>\nusing namespace std;\n\nint main()\n{\n    // 使用智能指针管理一块 int 型的堆内存\n    shared_ptr<int> ptr1(new int(520));\n    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;\n    //调用拷贝构造函数\n    shared_ptr<int> ptr2(ptr1);\n    //调用移动构造函数\n    shared_ptr<int> ptr4(std::move(ptr1));\n    // 创建智能指针对象, 不管理任何内存\n    shared_ptr<int> ptr3;\n    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;\n    // 创建智能指针对象, 初始化为空\n    shared_ptr<int> ptr4(nullptr);\n    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;\n\n    return 0;\n \n}\n//1\n//0\n//0\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br")])]),n("p",[s._v("注意：")]),s._v(" "),n("p",[s._v("如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个shared_ptr。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("int *p = new int;\nshared_ptr<int> p1(p);\nshared_ptr<int> p2(p);\t\t// error, 编译不会报错, 运行会出错\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("strong",[s._v("std::make_shared初始化")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("template< class T, class... Args >\nshared_ptr<T> make_shared( Args&&... args );\n\nT：模板参数的数据类型\nArgs&&... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[n("strong",[s._v("注意：")])]),s._v(" "),n("p",[s._v("使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理")]),s._v(" "),n("ul",[n("li",[s._v("如果申请的内存是普通类型，通过函数的（）可完成地址的初始化。")]),s._v(" "),n("li",[n("strong",[s._v("如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。")])])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class Test\n{\npublic:\n    Test(int x) \n    {\n        cout << "construct Test, x = " << x << endl;\n    }\n};\nint main(){\n// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1\n    shared_ptr<int> ptr1 = make_shared<int>(520);\n    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;\n\t//创建类类型对象\n    shared_ptr<Test> ptr3 = make_shared<Test>(520);\n    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])]),n("h4",{attrs:{id:"常用方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用方法"}},[s._v("#")]),s._v(" 常用方法")]),s._v(" "),n("table",[n("thead",[n("tr",[n("th",[s._v("方法")]),s._v(" "),n("th",[s._v("作用")])])]),s._v(" "),n("tbody",[n("tr",[n("td",[s._v("find()")]),s._v(" "),n("td",[s._v("容器类的方法，接受一个key，返回一个具有该可以迭代器")])]),s._v(" "),n("tr",[n("td",[s._v("end()")]),s._v(" "),n("td",[n("code",[s._v("C++容器类提供的成员函数之一。它返回一个迭代器，指向容器的末尾位置。在使用迭代器遍历容器时，通常将")]),s._v("end()`与迭代器进行比较，以判断是否已经到达容器的末尾。")])]),s._v(" "),n("tr",[n("td",[s._v("get()")]),s._v(" "),n("td",[s._v("get()"),n("code",[s._v("是")]),s._v("std::shared_ptr"),n("code",[s._v("类提供的成员函数。它返回指向被")]),s._v("std::shared_ptr"),n("code",[s._v("管理的对象的原始指针。")])])])])]),s._v(" "),n("h4",{attrs:{id:"删除器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#删除器"}},[s._v("#")]),s._v(" 删除器")]),s._v(" "),n("p",[s._v("当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('#include <iostream>\n#include <memory>\nusing namespace std;\n\n// 自定义删除器函数，释放int型内存\nvoid deleteIntPtr(int* p)\n{\n    delete p;\n    cout << "int 型内存被释放了...";\n}\n\nint main()\n{\n    shared_ptr<int> ptr(new int(250), deleteIntPtr);\n    //删除器也可以是lambda函数,其实就是匿名函数\n    shared_ptr<int> ptr(new int(250), [](int* p) {delete p; });\n\n    return 0;\n}\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("h3",{attrs:{id:"unique-ptr"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#unique-ptr"}},[s._v("#")]),s._v(" unique_ptr")]),s._v(" "),n("p",[s._v("std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。")]),s._v(" "),n("p",[n("strong",[s._v("初始化")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 通过构造函数初始化对象\nunique_ptr<int> ptr1(new int(10));\n// error, 不允许将一个unique_ptr赋值给另一个unique_ptr\nunique_ptr<int> ptr2 = ptr1;\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("相关方法：")]),s._v(" "),n("h4",{attrs:{id:"move-将指针所有权转移"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#move-将指针所有权转移"}},[s._v("#")]),s._v(" "),n("strong",[s._v("Move:将指针所有权转移")])]),s._v(" "),n("p",[s._v("std::unique_ptr不允许复制，但是可以通过函数返回给其他的std::unique_ptr，"),n("strong",[s._v("还可以通过std::move来转译给其他的std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("#include <iostream>\n#include <memory>\nusing namespace std;\n\nunique_ptr<int> func()\n{\n    return unique_ptr<int>(new int(520));\n}\nint main()\n{\n    // 通过构造函数初始化\n    unique_ptr<int> ptr1(new int(10));\n    // 通过转移所有权的方式初始化\n    unique_ptr<int> ptr2 = move(ptr1);\n    unique_ptr<int> ptr3 = func();\n\n    return 0;\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br")])]),n("p",[n("strong",[s._v("Reset")])]),s._v(" "),n("p",[n("strong",[s._v("使用reset方法可以让unique_ptr解除对原始内存的管理，也可以用来初始化一个独占的智能指针。")])]),s._v(" "),n("p",[n("code",[s._v("void reset( pointer ptr = pointer() ) noexcept;")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("int main()\n{\n    unique_ptr<int> ptr1(new int(10));\n    unique_ptr<int> ptr2 = move(ptr1);\n\t//解除对原始内存的管理\n    ptr1.reset();\n    //重新指定智能指针管理的原始内存\n    ptr2.reset(new int(250));\n    return 0;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[n("strong",[s._v("Get()")])]),s._v(" "),n("p",[s._v("获取独占智能指针管理的原始地址")]),s._v(" "),n("p",[n("code",[s._v("pointer get() const noexcept;")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\nint main()\n{\n    unique_ptr<int> ptr1(new int(10));\n    unique_ptr<int> ptr2 = move(ptr1);\n\n    ptr2.reset(new int(250));\n    cout << *ptr2.get() << endl;\t// 得到内存地址中存储的实际数值 250\n\n    return 0;\n}\n\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("h4",{attrs:{id:"删除器-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#删除器-2"}},[s._v("#")]),s._v(" "),n("strong",[s._v("删除器")])]),s._v(" "),n("p",[s._v("unique_ptr指定删除器和shared_ptr指定删除器是有区别的，"),n("strong",[s._v("unique_ptr指定删除器的时候需要确定删除器的类型,不能像shared_ptr那样直接指定删除器。")])]),s._v(" "),n("p",[s._v("举例如下：")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("shared_ptr<int> ptr1(new int(10), [](int*p) {delete p; });\t// ok\nunique_ptr<int> ptr1(new int(10), [](int*p) {delete p; });\t// error\n\nint main()\n{\n    using func_ptr = void(*)(int*);\n    unique_ptr<int, func_ptr> ptr1(new int(10), [](int*p) {delete p; });\n\n    return 0;\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("正确写法")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("int main()\n{\n    using func_ptr = void(*)(int*);\n    unique_ptr<int, function<void(int*)>> ptr1(new int(10), [&](int*p) {delete p; });\n    return 0;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("上面的代码中错误原因是这样的，在lambda表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("int main()\n{\n    using func_ptr = void(*)(int*);\n    unique_ptr<int, function<void(int*)>> ptr1(new int(10), [&](int*p) {delete p; });\n    return 0;\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("h2",{attrs:{id:"std-optinal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-optinal"}},[s._v("#")]),s._v(" std::optinal")]),s._v(" "),n("p",[n("code",[s._v("std::optional")]),s._v(" 是 C++17 中引入的标准库模板类。它提供了一种表示可选值的方式，也就是值可能存在，也可能不存在。它属于 "),n("code",[s._v("<optional>")]),s._v(" 头文件。")]),s._v(" "),n("p",[n("code",[s._v("std::optional")]),s._v(" 的主要目的是"),n("strong",[s._v("避免使用特殊的标志值（例如，空指针或魔法数）来表示缺少值")]),s._v("。相反，它封装了一个可选值，让您以更类型安全和表达性更强的方式处理它。")]),s._v(" "),n("p",[s._v("创建一个optinal对象，封装class类型")]),s._v(" "),n("p",[n("code",[s._v("std::optional<class>")])]),s._v(" "),n("p",[s._v("使用构造函数：")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("std::optional<int> opt_value1(42);   // 创建包含整数值的 std::optional 对象\nstd::optional<int> opt_value2;       // 创建空的 std::optional 对象\nstd::optional<int> opt_value3 = {};  // 同样是创建空的 std::optional 对象\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("使用工厂函数创建：")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("auto opt_value1 = std::make_optional<int>(42);  // 创建包含整数值的 std::optional 对象\nauto opt_value2 = std::make_optional<int>();     // 创建空的 std::optional 对象\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("h2",{attrs:{id:"std-move"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-move"}},[s._v("#")]),s._v(" std::move")]),s._v(" "),n("blockquote",[n("p",[s._v("参考:https://zhuanlan.zhihu.com/p/645258818")])]),s._v(" "),n("p",[s._v("在C++11中，标准库在"),n("utility",[s._v("中提供了一个有用的函数std::move，std::move并不能移动任何东西**，它唯一的功能是将一个"),n("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%B7%A6%E5%80%BC&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[s._v("左值"),n("OutboundLink")],1),s._v("强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义**。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);")])],1),s._v(" "),n("h3",{attrs:{id:"左值和右值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#左值和右值"}},[s._v("#")]),s._v(" "),n("strong",[s._v("左值和右值")])]),s._v(" "),n("p",[s._v("左值是表达式结束后依然存在的持久对象(代表一个在内存中占有确定位置的对象)")]),s._v(" "),n("p",[s._v("右值是表达式结束时不再存在的临时对象(不在内存中占有确定位置的表达式）")]),s._v(" "),n("p",[s._v("便携方法：对表达式取地址，如果能，则为左值，否则为右值")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("1. int val;\n2. val = 4; // 正确 \n3. 4 = val; // 错误 \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("上述例子中，由于在之前已经对变量val进行了定义，故在栈上会给val分配内存地址，运算符=要求等号左边是可修改的左值，")]),s._v(" "),n("p",[s._v("右边是临时参与运算的值，一般在寄存器上暂存，运算结束后在寄存器上移除该值")]),s._v(" "),n("p",[n("strong",[s._v("一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。")])]),s._v(" "),n("p",[n("strong",[s._v("引用")])]),s._v(" "),n("p",[s._v("**引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。**引用可以改变指针的指向，还可以改变指针所指向的值。")]),s._v(" "),n("p",[s._v("引用的基本规则：")]),s._v(" "),n("ol",[n("li",[s._v("声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义**；**")]),s._v(" "),n("li",[s._v("对引用的一切操作，就相当于对原对象的操作。")])]),s._v(" "),n("p",[n("strong",[s._v("左值引用")])]),s._v(" "),n("p",[s._v("左值引用的基本语法：type &引用名 = 左值表达式；")]),s._v(" "),n("p",[n("strong",[s._v("右值引用")])]),s._v(" "),n("p",[n("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[s._v("右值引用"),n("OutboundLink")],1),s._v("的基本语法type &&引用名 = 右值表达式；")]),s._v(" "),n("p",[s._v("​    "),n("strong",[s._v("右值引用在企业开发人员在代码优化方面会经常用到。")])]),s._v(" "),n("p",[s._v("​    右值引用的“&&”中间不可以有空格。")]),s._v(" "),n("h3",{attrs:{id:"std-move函数怎么用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-move函数怎么用"}},[s._v("#")]),s._v(" "),n("strong",[s._v("std::move函数怎么用")])]),s._v(" "),n("p",[s._v("可以将对象从左值变为右值，避免拷贝构造，只是将对象状态或者所有权从一个对象转移到另一个对象，"),n("strong",[s._v("没有涉及内存的搬迁或者内存拷贝，从而极大地提高代码效率。")])]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("std::move作用主要可以将一个左值转换成右值引用，从而可以调用C++11右值引用的拷贝构造函数")])]),s._v(" "),n("li",[n("strong",[s._v("std::move应该是针对你的对象中有在堆上分配内存这种情况而设置的")])])]),s._v(" "),n("p",[s._v("感觉很抽象，举一个例子来说明,接下来，我们以"),n("code",[s._v("std::vector<MyClass>")]),s._v("的相关操作为例，看一下std::move在工程中的具体应用：")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("int main() {\n    std::vector<MyClass> vec;\n    // 不使用移动语义\n    MyClass obj5(10);            // 调用默认构造函数\n    vec.push_back(obj5);         // 调用复制构造函数\n\n    // 使用移动语义\n    MyClass obj6(20);            // 调用默认构造函数\n    vec.push_back(std::move(obj6));                    // 调用拷贝+移动构造函数\n    for (auto &obj : vec) {\n        obj.PrintData();\n    }\n\n    return 0;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])]),n("p",[n("strong",[s._v("编译时构造函数调用截图")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231206171459571.png",alt:"image-20231206171459571"}})]),s._v(" "),n("p",[s._v("由上可知：首先，我们定义一个"),n("code",[s._v("std::vector<MyClass>")]),s._v("对象，并准备向其中push新元素。")]),s._v(" "),n("p",[s._v("传统做法是不使用移动语义的，这样会先调用默认构造函数创建新对象obj1，再通过拷贝构造函数将obj1的资源复制到vector新元素中，"),n("strong",[s._v("在拷贝构造函数中会涉及到开辟内存、资源复制等操作；")])]),s._v(" "),n("p",[s._v("当使用了移动语义之后，我们首先通过默认构造函数创建了对象obj2，然后通过std::move直接将obj2转换为右值传递给vector，将obj2的所有权转移给vector中的新元素，从运行结果也可以看出由于std::vector本身的实现机制，"),n("strong",[s._v("在所有权转移过程中调用了两次移动构造函数，但是均不会涉及内存开辟、资源复制等操作，提高了代码效率。")])]),s._v(" "),n("h2",{attrs:{id:"四种cast转换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四种cast转换"}},[s._v("#")]),s._v(" 四种cast转换")]),s._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://blog.csdn.net/Dontla/article/details/130792118",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考"),n("OutboundLink")],1)])]),s._v(" "),n("ol",[n("li",[n("p",[s._v("static_cast\n用于基本数据类型之间的转换，如int转换为double，"),n("strong",[s._v("也可以用于类层次结构中的向上转换（子类转换为父类）")]),s._v("，但不能用于向下转换（父类转换为子类）。")])]),s._v(" "),n("li",[n("p",[s._v("dynamic_cast\n用于类层次结构中的向下转换（父类转换为子类），但只能用于含有虚函数的类，且转换时会进行类型检查，如果转换失败则返回空指针。")])]),s._v(" "),n("li",[n("p",[s._v("reinterpret_cast\n用于将一个指针转换为另一个类型的指针，或将一个整数转换为指针类型，但不进行类型检查，慎用。")])]),s._v(" "),n("li",[n("p",[s._v("const_cast\n用于去除指针或引用类型的const属性，使其可以修改被指向的对象，但不能用于去除非const类型的const属性。")])])]),s._v(" "),n("h2",{attrs:{id:"size-t"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#size-t"}},[s._v("#")]),s._v(" size_t")]),s._v(" "),n("p",[s._v("size_t 是C标准库中定义的，它是一个基本的与机器相关的无符号整数的 C/C++ 类型， "),n("strong",[s._v("它是 sizeof 操作符返回的结果类型，该类型的大小可选择。其大小足以保证存储内存中对象的大小（简单理解为 unsigned int 就可以了，64 位系统中为 long unsigned int）。通常用 sizeof(X) 操作，这个操作所得到的结果就是 size_t 类型。")])]),s._v(" "),n("blockquote",[n("p",[s._v("参考:https://blog.csdn.net/m0_51913750/article/details/128351873")])]),s._v(" "),n("h2",{attrs:{id:"std-promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-promise"}},[s._v("#")]),s._v(" std::promise")]),s._v(" "),n("blockquote",[n("p",[s._v("[CPP Referrence]("),n("a",{attrs:{href:"https://en.cppreference.com/w/cpp/thread/promise",target:"_blank",rel:"noopener noreferrer"}},[s._v("std::promise - cppreference.com"),n("OutboundLink")],1),s._v(")")]),s._v(" "),n("p",[s._v("https://blog.csdn.net/sinat_31608641/article/details/124937401")])]),s._v(" "),n("p",[s._v("std::promise 是 C++11 标准库中提供的异步编程工具之一，它通常与 std::future 一起使用，"),n("strong",[s._v("用来实现线程间的"),n("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[s._v("异步通信"),n("OutboundLink")],1)]),s._v("。promise 提供了一个承诺（promise），表示在某个时间点一定会有一个值或一个异常被设置。")]),s._v(" "),n("p",[n("strong",[s._v("注意std::promise对象只能使用一次。")])]),s._v(" "),n("p",[s._v("promise 可以在一个线程中设置一个值，而另一个线程中可以通过 std::future 来访问这个值。")]),s._v(" "),n("p",[s._v("通常的做法是，创建一个 promise 对象，然后通过 promise 对象获取一个 future 对象，将 future 对象传递到另一个线程中去，另一个线程将值或异常设置到 promise 对象中，随后原线程可以通过 future 对象来获取值或异常。")]),s._v(" "),n("ul",[n("li",[s._v("std::promise"),n("class",{attrs:{T:""}},[s._v("    实例化一个对象")])],1),s._v(" "),n("li",[s._v("set_promise,设置promise的值，如果有关联的future对象，future会受到通知")]),s._v(" "),n("li",[s._v("std::future"),n("class",{attrs:{T:""}},[s._v(" future=promiseObject.get_future(),获取这个promise的future对象")])],1),s._v(" "),n("li",[s._v("futureObjetc.wait()，如果其关联的promise对象调用了"),n("code",[s._v("set_promise")]),s._v(",退出等待")])]),s._v(" "),n("p",[n("strong",[s._v("官方文档提供的实例:  异步求和")])]),s._v(" "),n("p",[s._v("在主函数（主线程）中声明 promise 及其对应的 future，在某个线程中传入 promise 并进行运算；\n在另一个线程中出入 future， 可利用get得到前一个线程中计算的结果；")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("#include <chrono>\n#include <future>\n#include <iostream>\n#include <numeric>\n#include <thread>\n#include <vector>\n \nvoid accumulate(std::vector<int>::iterator first,\n                std::vector<int>::iterator last,\n                std::promise<int> accumulate_promise)\n{\n    int sum = std::accumulate(first, last, 0);//调用标准库函数求和\n    //设置promise值，会通知到与之关联的future对象\n    accumulate_promise.set_value(sum); // Notify future\n    \n}\n \nvoid do_work(std::promise<void> barrier)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    barrier.set_value();\n}\n \nint main()\n{\n    // Demonstrate using promise<int> to transmit a result between threads.\n    std::vector<int> numbers = {1, 2, 3, 4, 5, 6};\n    std::promise<int> accumulate_promise;\n    std::future<int> accumulate_future = accumulate_promise.get_future();//主线程的std::promise<int> 和future关联\n    //使用 std::thread 创建了一个新线程 work_thread，并将 accumulate 函数作为线程函数执行，因此需要传递了numbers 向量的迭代器范围和 accumulate_promise 对象。\n    std::thread work_thread(accumulate, numbers.begin(), numbers.end(),\n                            std::move(accumulate_promise));\n \n    // future::get() will wait until the future has a valid result and retrieves it.\n    // Calling wait() before get() is not needed\n    // accumulate_future.wait(); // wait for result\n    std::cout << \"result=\" << accumulate_future.get() << '\\n';\n    work_thread.join(); // wait for thread completion，等待work_thread线程执行完成\n \n    // Demonstrate using promise<void> to signal state between threads.演示进程间的同步\n    std::promise<void> barrier;\n    std::future<void> barrier_future = barrier.get_future();\n    std::thread new_work_thread(do_work, std::move(barrier));\n    barrier_future.wait();//主线程阻塞，等待do_work执行完成\n    new_work_thread.join();//主线程阻塞，等待新线程执行完成\n    //这里主要想演示主线程等待子线程结束。\n}\n\n//output 21\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br")])]),n("h2",{attrs:{id:"std-future"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-future"}},[s._v("#")]),s._v(" std::future")])])}),[],!1,null,null,null);n.default=e.exports}}]);