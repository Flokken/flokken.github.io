(window.webpackJsonp=window.webpackJsonp||[]).push([[269],{599:function(t,s,a){"use strict";a.r(s);var n=a(4),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("主要是方法和函数的使用，为了刷算法题而使用，并不涉及源码。")]),t._v(" "),s("blockquote",[s("p",[t._v("资料来源于"),s("a",{attrs:{href:"http://m.biancheng.net/view/6675.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("C语言中文网STL教程"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("由于主要后面工作使用java，所以放弃stl，用java刷题去了。。。。")])]),t._v(" "),s("h2",{attrs:{id:"stl介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stl介绍"}},[t._v("#")]),t._v(" STL介绍")]),t._v(" "),s("p",[t._v("通常认为，"),s("a",{attrs:{href:"http://m.biancheng.net/stl/",target:"_blank",rel:"noopener noreferrer"}},[t._v("STL"),s("OutboundLink")],1),t._v(" 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("STL的组成")]),t._v(" "),s("th",[t._v("含义")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("容器")]),t._v(" "),s("td",[t._v("一些封装"),s("a",{attrs:{href:"http://m.biancheng.net/data_structure/",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构"),s("OutboundLink")],1),t._v("的模板类，例如 vector 向量容器、list 列表容器等。")])]),t._v(" "),s("tr",[s("td",[t._v("算法")]),t._v(" "),s("td",[t._v("STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件"),s("code",[t._v("<algorithm>")]),t._v(" 中，少部分位于头文件 "),s("code",[t._v("<numeric>")]),t._v(" 中。")])]),t._v(" "),s("tr",[s("td",[t._v("迭代器")]),t._v(" "),s("td",[t._v("在 "),s("a",{attrs:{href:"http://m.biancheng.net/cplus/",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++"),s("OutboundLink")],1),t._v(" STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。")])]),t._v(" "),s("tr",[s("td",[t._v("函数对象")]),t._v(" "),s("td",[t._v("如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。")])]),t._v(" "),s("tr",[s("td",[t._v("适配器")]),t._v(" "),s("td",[t._v("可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。")])]),t._v(" "),s("tr",[s("td",[t._v("内存分配器")]),t._v(" "),s("td",[t._v("为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。")])])])]),t._v(" "),s("h3",{attrs:{id:"stl容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stl容器"}},[t._v("#")]),t._v(" STL容器")]),t._v(" "),s("p",[t._v("简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。STL 提供有 3 类标准容器，分别是"),s("strong",[t._v("序列容器、排序容器和哈希容器")]),t._v("，其中后两类容器有时也统称为"),s("strong",[t._v("关联容器")]),t._v("。")]),t._v(" "),s("center",[t._v("表 容器分类")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("容器种类")]),t._v(" "),s("th",[t._v("功能")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("序列容器")]),t._v(" "),s("td",[t._v("主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。")])]),t._v(" "),s("tr",[s("td",[t._v("排序容器")]),t._v(" "),s("td",[t._v("包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。"),s("strong",[t._v("排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置")]),t._v("。所以关联容器在查找时具有非常好的性能。")])]),t._v(" "),s("tr",[s("td",[t._v("哈希容器")]),t._v(" "),s("td",[s("a",{attrs:{href:"http://m.biancheng.net/cplus/",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++"),s("OutboundLink")],1),t._v(" 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("注意，由于哈希容器直到 C++ 11 才被正式纳入 C++ 标准程序库，而在此之前，“民间”流传着 hash_set、hash_multiset、hash_map、hash_multimap 版本，不过该版本只能在某些支持 C++ 11 的编译器下使用（如 VS），有些编译器（如 gcc/g++）是不支持的。")]),t._v(" "),s("p",[t._v("机试用到序列容器和排序容器就OK了，一般也用不到C++11")])]),t._v(" "),s("h3",{attrs:{id:"迭代器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[t._v("#")]),t._v(" 迭代器")]),t._v(" "),s("p",[t._v("无论是序列容器还是关联容器，"),s("strong",[t._v("最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器")]),t._v("（iterator）”来实现。那么，迭"),s("strong",[t._v("代器到底是什么呢？")])]),t._v(" "),s("p",[t._v("尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。")]),t._v(" "),s("p",[t._v("既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，"),s("strong",[t._v("它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。")])]),t._v(" "),s("p",[t._v("这是泛型思维发展的必然结果，于是迭代器就产生了。"),s("strong",[t._v("简单来讲，迭代器和 "),s("a",{attrs:{href:"http://m.biancheng.net/cplus/",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++"),s("OutboundLink")],1),t._v(" 的"),s("a",{attrs:{href:"http://m.biancheng.net/c/80/",target:"_blank",rel:"noopener noreferrer"}},[t._v("指针"),s("OutboundLink")],1),t._v("非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。")])]),t._v(" "),s("p",[t._v("常用的迭代器按功能强弱分为输入迭代器、输出迭代器、"),s("strong",[t._v("前向迭代器、双向迭代器、随机访问迭代器 5 种。主要关注后面这 3 种迭代器。")])]),t._v(" "),s("blockquote",[s("p",[t._v("输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。有关这 2 个迭代器，我们会在后续章节做详细介绍。")])]),t._v(" "),s("h4",{attrs:{id:"分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),s("p",[s("strong",[t._v("1 前向迭代器（forward iterator）")]),t._v("\n假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个前向迭代器可以互相赋值。")]),t._v(" "),s("p",[s("strong",[t._v("2 双向迭代器（bidirectional iterator）")]),t._v("\n双向迭代器具有前向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（"),s("strong",[t._v("即一次向后移动一个位置")]),t._v("）。")]),t._v(" "),s("p",[s("strong",[t._v("3 随机访问迭代器（random access iterator")]),t._v("）\n随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：")]),t._v(" "),s("ul",[s("li",[t._v("p+=i：使得 p 往后移动 i 个元素。")]),t._v(" "),s("li",[t._v("p-=i：使得 p 往前移动 i 个元素。")]),t._v(" "),s("li",[t._v("p+i：返回 p 后面第 i 个元素的迭代器。")]),t._v(" "),s("li",[t._v("p-i：返回 p 前面第 i 个元素的迭代器。")]),t._v(" "),s("li",[t._v("**p[i]：返回 p 后面第 i 个元素的引用。**这个很常用，比如vector直接用下标访问")])]),t._v(" "),s("p",[t._v("此外，两个随机访问迭代器 p1、p2 还可以用 <、>、<=、>= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）")]),t._v(" "),s("center",[t._v("表 C++11标准中容器支持的迭代器")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("容器")]),t._v(" "),s("th",[t._v("对应的迭代器类型")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("array")]),t._v(" "),s("td",[t._v("随机访问迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("vector")]),t._v(" "),s("td",[t._v("随机访问迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("deque")]),t._v(" "),s("td",[t._v("随机访问迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("list")]),t._v(" "),s("td",[t._v("双向迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("set / multiset")]),t._v(" "),s("td",[t._v("双向迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("map / multimap")]),t._v(" "),s("td",[t._v("双向迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("forward_list")]),t._v(" "),s("td",[t._v("前向迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("unordered_map / unordered_multimap")]),t._v(" "),s("td",[t._v("前向迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("unordered_set / unordered_multiset")]),t._v(" "),s("td",[t._v("前向迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("stack")]),t._v(" "),s("td",[t._v("不支持迭代器")])]),t._v(" "),s("tr",[s("td",[t._v("queue")]),t._v(" "),s("td",[t._v("不支持迭代器")])])])]),t._v(" "),s("p",[t._v("尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如表 1 所示。")]),t._v(" "),s("h4",{attrs:{id:"定义方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义方式"}},[t._v("#")]),t._v(" 定义方式")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("迭代器定义方式")]),t._v(" "),s("th",[t._v("具体格式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("正向迭代器")]),t._v(" "),s("td",[t._v("容器类名::iterator 迭代器名;")])]),t._v(" "),s("tr",[s("td",[t._v("常量正向迭代器")]),t._v(" "),s("td",[t._v("容器类名::const_iterator 迭代器名;")])]),t._v(" "),s("tr",[s("td",[t._v("反向迭代器")]),t._v(" "),s("td",[t._v("容器类名::reverse_iterator 迭代器名;")])]),t._v(" "),s("tr",[s("td",[t._v("常量反向迭代器")]),t._v(" "),s("td",[t._v("容器类名::const_reverse_iterator 迭代器名;")])])])]),t._v(" "),s("blockquote",[s("p",[t._v('值得一提的是，表 2 中的反向迭代器全称为 "反向迭代器适配器"，后续章节会做详细讲解，这里读者只需要知道其用法即可。')])]),t._v(" "),s("p",[t._v("通过定义以上几种迭代器，就可以读取它指向的元素，"),s("code",[t._v("*迭代器名")]),t._v("就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：")]),t._v(" "),s("ul",[s("li",[t._v("对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；")]),t._v(" "),s("li",[t._v("而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。")])]),t._v(" "),s("blockquote",[s("p",[t._v("注意，虽然迭代器定义方式一样，但是容器支持的迭代器类型不一样，其就是支持的操作不一样")])]),t._v(" "),s("p",[t._v("先以vector为例，vector支持随机访问迭代器，因此可以支持迭代器的所有操作,")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('//遍历 vector 容器\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main()\n{\n    vector<int> v={1,2,3,4,5,6,7,8,9,10}; //v被初始化成有10个元素\n    \n    cout << "第一种遍历方法：" << endl;\n    //size返回元素个数\n    for (int i = 0; i < v.size(); ++i)\n        cout << v[i] <<" "; //像普通数组一样使用vector容器\n    \n    \n    //创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式\n       cout << endl << "第二种遍历方法：" << endl;\n       vector<int>::iterator i;\n    //用 != 比较两个迭代器\n    for (i = v.begin(); i != v.end(); ++i)\n        cout << *i << " ";\n    \n       cout << endl << "第三种遍历方法：" << endl;\n    for (i = v.begin(); i < v.end(); ++i) //用 < 比较两个迭代器\n        cout << *i << " ";\n   \n    \n       cout << endl << "第四种遍历方法：" << endl;\n    i = v.begin();\n    while (i < v.end()) { //间隔一个输出\n        cout << *i << " ";\n        i += 2; // 随机访问迭代器支持 "+= 整数"  的操作\n    }\n}\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br")])]),s("p",[t._v("再以list容器为例，list 容器的迭代器是双向迭代器。")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//创建一个 v list容器\nlist<int> v;\n//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。\nlist<int>::const_iterator i;\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("以下代码是合法的：")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("for(i = v.begin(); i != v.end(); ++i)    cout << *i;\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("以下代码则不合法，"),s("strong",[t._v("因为双向迭代器不支持用“<”进行比较：")])]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("for(i = v.begin(); i < v.end(); ++i)    cout << *i;\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("以下代码也不合法，"),s("strong",[t._v("因为双向迭代器不支持用下标随机访问元素：")])]),t._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("for(int i=0; i<v.size(); ++i)    cout << v[i];\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("blockquote",[s("p",[t._v("其实在 C++ 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，"),s("strong",[t._v("int * 类型的指针就是其迭代器")]),t._v("。则 a、a+1、a+2 都是 a 的迭代器。")])]),t._v(" "),s("h2",{attrs:{id:"关联容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关联容器"}},[t._v("#")]),t._v(" 关联容器")]),t._v(" "),s("h3",{attrs:{id:"pair类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pair类"}},[t._v("#")]),t._v(" pair类")]),t._v(" "),s("p",[t._v("我们知道，关联式容器存储的是“键值对（key-value）”形式的数据")]),t._v(" "),s("p",[t._v("考虑到“键值对”并不是普通类型数据，C++标准库提供了 pair 类模板，"),s("strong",[t._v("其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素"),s("code",[t._v("<first, second>")])])]),t._v(" "),s("p",[t._v("注意，pair 类模板定义在"),s("code",[t._v("<utility>")]),t._v("头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("#1) 默认构造函数，即创建空的 pair 对象\npair();\n#2) 直接使用 2 个元素初始化成 pair 对象\npair (const first_type& a, const second_type& b);\n#3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象\ntemplate<class U, class V> pair (const pair<U,V>& pr);\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("创建pair对象示例")]),t._v(" "),s("blockquote",[s("p",[t._v("最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。")])]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include <iostream>\n#include <utility>      // pair\n#include <string>       // string\nusing namespace std;\nint main() {\n    // 调用构造函数 1，也就是默认构造函数\n    pair <string, double> pair1;\n    // 调用第 2 种构造函数\n    pair <string, string> pair2("苹果","apple");  \n    // 调用拷贝构造函数\n    pair <string, string> pair3(pair2);\n    \n    //访问元素\n    cout<<pair2.first;//“苹果”\n    \n    //pair提供的swap\n     pair<string, string>pair4("香蕉","balana"); \n     pair2.swap(pair4);//交换两个pair，注意key和value对应的类型都要一样\n\n}\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br")])]),s("h3",{attrs:{id:"map容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map容器"}},[t._v("#")]),t._v(" Map容器")]),t._v(" "),s("p",[t._v("作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++基本数据类型（int、double 等）、使用结构体或类自定义的类型。")]),t._v(" "),s("blockquote",[s("p",[t._v("通常情况下，"),s("strong",[t._v("map 容器中存储的各个键值对都选用 string 字符串作为键的类型。")])])]),t._v(" "),s("p",[t._v("与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。")]),t._v(" "),s("p",[t._v("默认情况下，map 容器选用"),s("code",[t._v("std::less<T>")]),t._v("排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。")]),t._v(" "),s("blockquote",[s("p",[t._v("也就是map默认升序排序，不过可以自定义排序规则")])]),t._v(" "),s("p",[t._v("当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 "),s("a",{attrs:{href:"http://m.biancheng.net/stl/",target:"_blank",rel:"noopener noreferrer"}},[t._v("STL"),s("OutboundLink")],1),t._v(" 标准库中提供的其它排序规则（比如"),s("code",[t._v("std::greater<T>")]),t._v("），也可以自定义排序规则。")]),t._v(" "),s("p",[s("strong",[t._v("另外需要注意的是，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。")])]),t._v(" "),s("blockquote",[s("p",[t._v("前面提到，map 容器存储的都是 pair 类型的键值对元素，"),s("strong",[t._v("更确切的说，该容器存储的都是 pair<const K, T> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。")])])]),t._v(" "),s("p",[t._v("使用map")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("#include<map>\nusing namespace std;\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("map 容器提供的常用成员方法以及各自的功能。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("成员方法")]),t._v(" "),s("th",[t._v("功能")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("begin()")]),t._v(" "),s("td",[t._v("返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。")])]),t._v(" "),s("tr",[s("td",[t._v("end()")]),t._v(" "),s("td",[t._v("返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。")])]),t._v(" "),s("tr",[s("td",[t._v("rbegin()")]),t._v(" "),s("td",[t._v("返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。")])]),t._v(" "),s("tr",[s("td",[t._v("rend()")]),t._v(" "),s("td",[t._v("返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。")])]),t._v(" "),s("tr",[s("td",[t._v("cbegin()")]),t._v(" "),s("td",[t._v("和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。")])]),t._v(" "),s("tr",[s("td",[t._v("cend()")]),t._v(" "),s("td",[t._v("和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。")])]),t._v(" "),s("tr",[s("td",[t._v("crbegin()")]),t._v(" "),s("td",[t._v("和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。")])]),t._v(" "),s("tr",[s("td",[t._v("crend()")]),t._v(" "),s("td",[t._v("和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。")])]),t._v(" "),s("tr",[s("td",[t._v("find(key)(*)")]),t._v(" "),s("td",[t._v("在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；       "),s("br"),s("strong",[t._v("没有找到，则返回和 end() 方法一样的迭代器")]),t._v("。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。")])]),t._v(" "),s("tr",[s("td",[t._v("lower_bound(key)")]),t._v(" "),s("td",[t._v("返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。")])]),t._v(" "),s("tr",[s("td",[t._v("upper_bound(key)")]),t._v(" "),s("td",[t._v("返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。")])]),t._v(" "),s("tr",[s("td",[t._v("equal_range(key)")]),t._v(" "),s("td",[t._v("该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。")])]),t._v(" "),s("tr",[s("td",[t._v("empty()")]),t._v(" "),s("td",[t._v("若容器为空，则返回 true；否则 false。")])]),t._v(" "),s("tr",[s("td",[t._v("size()")]),t._v(" "),s("td",[t._v("返回当前 map 容器中存有键值对的个数。")])]),t._v(" "),s("tr",[s("td",[t._v("max_size()")]),t._v(" "),s("td",[t._v("返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。")])]),t._v(" "),s("tr",[s("td",[t._v("operator[]")]),t._v(" "),s("td",[t._v("map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。")])]),t._v(" "),s("tr",[s("td",[t._v("at(key)")]),t._v(" "),s("td",[t._v("找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。")])]),t._v(" "),s("tr",[s("td",[t._v("insert()")]),t._v(" "),s("td",[t._v("向 map 容器中插入键值对。注意，用这个的话要先定义一个键值对，再插入，比较麻烦")])]),t._v(" "),s("tr",[s("td",[t._v("erase()")]),t._v(" "),s("td",[t._v("删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。")])]),t._v(" "),s("tr",[s("td",[t._v("swap()")]),t._v(" "),s("td",[t._v("交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。")])]),t._v(" "),s("tr",[s("td",[t._v("clear()")]),t._v(" "),s("td",[t._v("清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。")])]),t._v(" "),s("tr",[s("td",[t._v("emplace()(*)")]),t._v(" "),s("td",[t._v("在当前 map 容器中的指定位置处构造新键值对并插入。其效果和插入键值对一样，但效率更高，更方便")])]),t._v(" "),s("tr",[s("td",[t._v("emplace_hint()")]),t._v(" "),s("td",[t._v("在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。")])]),t._v(" "),s("tr",[s("td",[t._v("count(key)")]),t._v(" "),s("td",[t._v("在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。")])])])]),t._v(" "),s("p",[t._v("使用示例")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include <iostream>\n#include <map>      // map\n#include <string>       // string\nusing namespace std;\n\nint main() {\n    //创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序\n    map<string, string, greater<string>>myMap;\n    //调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对,因为是hash，所以这个位置是系统自己指定\n    myMap.emplace("C语言教程","http://c.biancheng.net/c/");\n    \n    //输出当前 myMap 容器存储键值对的个数\n    cout << "myMap size==" << myMap.size() << endl;\n    \n    //判断当前 myMap 容器是否为空\n    if (!myMap.empty()) {\n        //借助 myMap 容器迭代器，将该容器的键值对逐个输出\n        for (auto i = myMap.begin(); i != myMap.end(); ++i) {\n            cout << i->first << " " << i->second << endl;\n        }\n    }  \n    map<int,int>test;\n    int x=1,y=2;\n    //插入\n    test[x]=y;\n    test.emplace(x,y);\n    \n    //迭代器\n    map<int,int>::iterator tmp;\n    //查询\n    tmp=test.find(x);\n    return 0;\n}\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br")])]),s("h2",{attrs:{id:"适配器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#适配器"}},[t._v("#")]),t._v(" 适配器")]),t._v(" "),s("h3",{attrs:{id:"stack适配器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stack适配器"}},[t._v("#")]),t._v(" stack适配器")]),t._v(" "),s("p",[t._v("stack 栈适配器是一种单端开口的容器，实际上该容器模拟的就是栈存储结构，即无论是向里存数据还是从中取数据，都只能从这一个开口实现操作。")]),t._v(" "),s("p",[t._v("栈核心就四个操作**，栈长，取栈顶，pop,push**")]),t._v(" "),s("blockquote",[s("p",[t._v("后进先出")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/2-1P913101Q4T2.jpg",alt:"stack适配器示意图"}})]),t._v(" "),s("p",[s("strong",[t._v("成员函数")])]),t._v(" "),s("center",[t._v("表stack容器适配器支持的成员函数 ")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("成员函数")]),t._v(" "),s("th",[t._v("功能")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("empty()")])]),t._v(" "),s("td",[t._v("当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("size()")])]),t._v(" "),s("td",[t._v("返回 stack 栈中存储元素的个数。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("top()")])]),t._v(" "),s("td",[t._v("返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("push(const T& val)")])]),t._v(" "),s("td",[t._v("先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。")])]),t._v(" "),s("tr",[s("td",[t._v("push(T&& obj)")]),t._v(" "),s("td",[t._v("以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("pop()")])]),t._v(" "),s("td",[t._v("弹出栈顶元素。")])]),t._v(" "),s("tr",[s("td",[t._v("emplace(arg...)")]),t._v(" "),s("td",[t._v("arg... 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。")])]),t._v(" "),s("tr",[s("td",[t._v("swap(stack"),s("T",[t._v(" & other_stack)")])],1),t._v(" "),s("td",[t._v("将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。")])])])]),t._v(" "),s("p",[s("strong",[t._v("举例")])]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("#include <stack>\nusing namespace std;\n//创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器（底层）\nstack<int> values={ 1, 2, 3 };\n//指定底层是list的stack\n//list<int> values {1, 2, 3};\n//stack<int,list<int>> my_stack (values);\n\n//遍历栈\n while (!values.empty())\n    {  \n        cout << values.top() << endl;\n        //将栈顶元素弹栈\n        values.pop();\n    }\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("p",[t._v("Q：为什么要叫stack适配器？")]),t._v(" "),s("p",[t._v("A："),s("code",[t._v("stack<T,Container=deque<T>>")]),t._v(" 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用出 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即.")]),t._v(" "),s("p",[t._v("序列式容器中同时包含这 5 个成员函数的，"),s("strong",[t._v("有 vector、deque(默认底层) 和 list 这 3 个容器")]),t._v("。因此，stack 适配器的基础容器可以是它们 3 个中任何一个。例如，下面展示了如何定义一个使用 list 基础容器的 stack 适配器：")]),t._v(" "),s("h2",{attrs:{id:"algorithm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[t._v("#")]),t._v(" Algorithm")]),t._v(" "),s("p",[t._v("这里对常用的STL中的algorithm总结")]),t._v(" "),s("p",[s("strong",[t._v("排序")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("函数名")]),t._v(" "),s("th",[t._v("用法")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("sort (first, last)")]),t._v(" "),s("td",[t._v("对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。")])]),t._v(" "),s("tr",[s("td",[t._v("stable_sort (first, last)")]),t._v(" "),s("td",[t._v("和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。")])])])]),t._v(" "),s("p",[t._v("用法")]),t._v(" "),s("p",[t._v("sort() 函数有 2 种用法，其语法格式分别为：")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//对 [first, last) 区域内的元素做默认的升序排序\nvoid sort (RandomAccessIterator first, RandomAccessIterator last);\n//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序\nvoid sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\n//示例\nvector<int> myvector{ 32, 71, 12, 45, 26, 80, 53, 33 };\n//排序一部分\nsort(myvector.begin(), myvector.begin() + 4);//(12 32 45 71) 26 80 53 33，注意这里是左闭右开\n//全部排序\nsort(myvector.begin(), myvector.end());\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：")]),t._v(" "),s("ol",[s("li",[t._v("容器支持的迭代器类型必须为随机访问迭代器。这意味着，"),s("strong",[t._v("sort() 只对 array、vector、deque 这 3 个容器提供支持。")])]),t._v(" "),s("li",[t._v("如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持"),s("code",[t._v("<")]),t._v("小于运算符；同样，如果选用标准库提供的其它排序规则，"),s("strong",[t._v("元素类型也必须支持该规则底层实现所用的比较运算符；")])]),t._v(" "),s("li",[t._v("sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是"),s("strong",[t._v("自定义的类对象")]),t._v("，"),s("strong",[t._v("则该类的内部必须提供移动构造函数和移动赋值运算符。")])])]),t._v(" "),s("p",[t._v("还有就是自定义排序功能")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("#include <iostream>   \n#include <algorithm>   \n#include <vector>       \nusing namespace std;\n//以普通函数的方式实现自定义排序规则\nbool cmp(int i, int j) {\n    return (i < j);\n}\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])])],1)}),[],!1,null,null,null);s.default=e.exports}}]);