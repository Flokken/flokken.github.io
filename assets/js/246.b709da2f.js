(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{575:function(e,a,s){"use strict";s.r(a);var t=s(4),_=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"task1-extendible-hash-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task1-extendible-hash-table"}},[e._v("#")]),e._v(" Task1 Extendible Hash Table")]),e._v(" "),a("p",[e._v("实现可扩容的通用hash表，当然增删改查的api也需要实现")]),e._v(" "),a("p",[e._v("这个hash表会随着使用，根据使用需求而自动的实现扩容。")]),e._v(" "),a("p",[a("strong",[e._v("数据结构")])]),e._v(" "),a("div",{staticClass:"language-C++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//Extendible Hash Table \nint global_depth_;    // The global depth of the directory,全局位深度\nsize_t bucket_size_;  // The size of a bucket\nint num_buckets_;     // The number of buckets in the hash table\nmutable std::mutex latch_;\n std::vector<std::shared_ptr<Bucket>> dir_;  // The directory of the hash table,目录，存放index的地方\n\n//Bucket\nsize_t size_;//当前bucket的大小\nint depth_;//局部位深度\nstd::list<std::pair<K, V>> list_;//kv数据对存储的地方，实际上就是一个数组\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("这里首先的得实现Bucket的增删查,也很简单")]),e._v(" "),a("div",{staticClass:"language-C++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('auto ExtendibleHashTable<K, V>::Bucket::Find(const K &key, V &value) -> bool {\n  //UNREACHABLE("not implemented");\n  for(auto item:list_){\n    if(item.first==key){\n      value = item.second;//通过引用返回value\n      return true;\n    }\n  }\n  return false;\n}\n\ntemplate <typename K, typename V>\nauto ExtendibleHashTable<K, V>::Bucket::Remove(const K &key) -> bool {\n  for(auto item:list_){\n    if(item.first==key){\n      this->list_.remove(item);\n      return true;\n    }\n  }\n  return false;\n}\n\ntemplate <typename K, typename V>\nauto ExtendibleHashTable<K, V>::Bucket::Insert(const K &key, const V &value) -> bool {\n  //UNREACHABLE("not implemented");\n  if(IsFull())  return false;\n  list_.template emplace_back(key,value);\n  return true;\n\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br"),a("span",{staticClass:"line-number"},[e._v("28")]),a("br"),a("span",{staticClass:"line-number"},[e._v("29")]),a("br"),a("span",{staticClass:"line-number"},[e._v("30")]),a("br")])]),a("blockquote",[a("p",[e._v("这里提一嘴，在bucket的插入中，是在list尾部插入数据，推荐用"),a("code",[e._v("emplace_back()")]),e._v("效率更高")]),e._v(" "),a("p",[e._v("emplace_back通常在"),a("strong",[e._v("性能上优于")]),e._v("push_back，因为它可以"),a("strong",[e._v("避免不必要的复制或移动操作")]),e._v("。")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("push_back( )")]),e._v(" 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）")]),e._v(" "),a("li",[a("strong",[e._v("emplace_back( )")]),e._v(" 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。")])])]),e._v(" "),a("p",[a("strong",[e._v("Insert()")])]),e._v(" "),a("p",[e._v("其中难点在于实现扩容，很复杂，我把其逻辑写到[L6-哈希表]中了，这里不讲")]),e._v(" "),a("p",[a("strong",[e._v("锁")])]),e._v(" "),a("p",[e._v("这里还是简单的给每个读写函数都加一个范围锁")]),e._v(" "),a("h2",{attrs:{id:"task2-实现lru-k"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task2-实现lru-k"}},[e._v("#")]),e._v(" Task2 实现LRU-K")]),e._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://dl.acm.org/doi/epdf/10.1145/170036.170081",target:"_blank",rel:"noopener noreferrer"}},[e._v("LRU-K论文"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/AntiO2/article/details/128439155",target:"_blank",rel:"noopener noreferrer"}},[e._v("一篇比较详细的博客"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/jjclove/article/details/124511119",target:"_blank",rel:"noopener noreferrer"}},[e._v("比较简述的博客"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("这里说一下大概LRU-K的实现。这里先看一下他的简介")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with less than k historical accesses is given +inf as its backward k-distance. When multipe frames have +inf backward k-distance, the replacer evicts the frame with the earliest timestamp.\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("大意是说，LRU-K算法的Replacer会选择具有最大的"),a("code",[e._v("backward k-distance")]),e._v("的frame移除，"),a("code",[e._v("backward k-distance")]),e._v("等于当"),a("strong",[e._v("前时间减去第k次访问访问时间")]),e._v("。")]),e._v(" "),a("p",[e._v("其实LRU-K的核心就是：")]),e._v(" "),a("ul",[a("li",[e._v("只有某个页的记录到了k次以上，才会考虑让他留的久一点，把他加入缓存队列，然后根据"),a("code",[e._v("backward k-distance")]),e._v("删除\n"),a("ul",[a("li",[e._v("当要删除缓存队列的page时，"),a("strong",[e._v("当前now是固定的，而"),a("code",[e._v("backward k-distance")]),e._v("与第k次访问时间负相关，也就是越早访问的页，他的"),a("code",[e._v("backward k-distance")]),e._v("越大，所以先删除，所以此时实际上就已经退化了成LRU了。")])])])]),e._v(" "),a("li",[e._v("如果某页的访问次数不到k次，直接给他的"),a("code",[e._v("backward k-distance")]),e._v("加上"),a("code",[e._v("inf")]),e._v(",也就是让其丢弃优先级最高（因为最大的先丢弃）。\n"),a("ul",[a("li",[e._v("如果有多个"),a("code",[e._v("inf")]),e._v("的页，那么删除其"),a("code",[e._v("timestamp")]),e._v("最早的那个，其实就是FIFO")])])])]),e._v(" "),a("blockquote",[a("p",[e._v("所以LRU算法其实就是LRU-k的k等于1时的特殊情况。")]),e._v(" "),a("p",[e._v("如果有inf就删inf的，没有的话就按照lru删除缓存队列的")])]),e._v(" "),a("p",[e._v("数据结构：")]),e._v(" "),a("p",[e._v("两个队列")]),e._v(" "),a("ul",[a("li",[e._v("一个历史队列维护页的访问历史，即"),a("code",[e._v("history_list")]),e._v(" "),a("ul",[a("li",[e._v("为了方便操作，我们还需定义一个map，存储id到队列位置的映射")])])]),e._v(" "),a("li",[e._v("一个缓存队列维护访问次数达到k的索引。即"),a("code",[e._v("cache_list")]),e._v(" "),a("ul",[a("li",[e._v("为了方便操作，我们还需定义一个map，存储id到队列位置的映射")])])])]),e._v(" "),a("div",{staticClass:"language-C++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   size_t curr_size_{0};//当前存放的可驱除的页面数量\n   size_t replacer_size_;//整个主存的大小\n   size_t k_;  //lru-k中k的值\n\n\n   std::mutex latch_;\n   std::unordered_map<frame_id_t,size_t>access_count_;//记录所有页的访问次数\n\n   std::list<frame_id_t>history_list_;//访问次数不到k次的页\n   //这个页面的id对应的上面这个队列迭代器的map\n   std::unordered_map<frame_id_t, std::list<frame_id_t>::iterator> history_map_;\n\n   std::list<frame_id_t>cache_list_;//访问次数到达k次的页\n    //这个页面的id对应的上面这个队列迭代器的map\n   std::unordered_map<frame_id_t,std::list<frame_id_t>::iterator>cache_map_;\n\n   std::unordered_map<frame_id_t,bool> is_evictable_;//记录页是否可以被驱除\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br")])]),a("p",[e._v("算法流程:")]),e._v(" "),a("ul",[a("li",[e._v("数据第一次被访问，加入到访问历史列表；")]),e._v(" "),a("li",[e._v("如果数据在访问历史列表里后没有达到K次访问，则按照FIFO淘汰；")]),e._v(" "),a("li",[e._v("当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；")]),e._v(" "),a("li",[e._v("缓存数据队列中被再次访问后，需要更新其优先级")]),e._v(" "),a("li",[e._v("需要淘汰数据时，首先淘汰历史队列中的数据，历史队列数据为空，才淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。")])]),e._v(" "),a("p",[a("strong",[e._v("这里注意，维护缓存队列时，我们可以只在队头进行插入，队尾出队，来保证队列元素的顺序，从而避免排序")]),e._v("，具体来说")]),e._v(" "),a("ul",[a("li",[e._v("我们插入数据时，插入到队头，那么后面的元素就被移动到队尾，就达到了最早访问的元素优先级最低的要求（最先出队）")])]),e._v(" "),a("p",[a("strong",[e._v("维护历史队列，也是一样的道理")])]),e._v(" "),a("ul",[a("li",[e._v("我们插入数据时，插入到队头，那么队尾就是最早访问的元素，出队队尾就满足算法要求的多个inf，时间最早的最先出队")])]),e._v(" "),a("p",[e._v("这里让我们实现的是各种功能函数。并且还要实现并发控制。")]),e._v(" "),a("p",[e._v("本地测试之前需要删除Test前面的"),a("code",[e._v("Distabled")]),e._v(",也就是改成这样")]),e._v(" "),a("p",[a("code",[e._v("TEST(LRUKReplacerTest, SampleTest) {......}")])]),e._v(" "),a("h3",{attrs:{id:"lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lock"}},[e._v("#")]),e._v(" Lock")]),e._v(" "),a("p",[e._v("这里统一用一个大锁锁起来，每个函数都一样，调用玩这个函数后，自动释放")]),e._v(" "),a("div",{staticClass:"language-C++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  std::scoped_lock<std::mutex>lock(latch_);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"evict"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#evict"}},[e._v("#")]),e._v(" Evict()")]),e._v(" "),a("p",[e._v("根据LRU-K算法，我们首先移除"),a("code",[e._v("history_list")]),e._v("里的元素；如果没有，再去移除"),a("code",[e._v("cache_list")]),e._v("里的元素。")]),e._v(" "),a("p",[e._v("这里由于我们插入的时候维护其顺序，所以我们直接出队队尾即可（队尾就是优先级最低的元素）。不过由于还有"),a("code",[e._v("is_evict")]),e._v("这东西限制，所以我们得从后往前遍历，移除第一个"),a("code",[e._v("is_evict==true")]),e._v("的元素。")]),e._v(" "),a("p",[e._v("注意这个函数还要求我们修改传入的引用来返回此处移除的id，也即是"),a("code",[e._v("frame_id")]),e._v("时传入的参数，"),a("code",[e._v("frame")]),e._v("是我们这次移除的")]),e._v(" "),a("p",[a("code",[e._v("*frame_id = frame;")])]),e._v(" "),a("h3",{attrs:{id:"recordaccess"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recordaccess"}},[e._v("#")]),e._v(" RecordAccess()")]),e._v(" "),a("p",[e._v("记录访问时间")]),e._v(" "),a("p",[e._v("这里由于我们不维护时间戳，而是通过队列的特性实现，所以稍微麻烦一点。")]),e._v(" "),a("p",[e._v("首先记录"),a("code",[e._v("access_count")]),e._v(",根据出现次数与k的关系，有")]),e._v(" "),a("ul",[a("li",[e._v("大于k，刷新cache_list中对应page的优先级（具体做法是先移除，再加到队首）")]),e._v(" "),a("li",[e._v("==k,移除history_list,加入cache_list")]),e._v(" "),a("li",[e._v("小于k，直接加入history_list")])]),e._v(" "),a("h3",{attrs:{id:"setevictable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setevictable"}},[e._v("#")]),e._v(" SetEvictable")]),e._v(" "),a("p",[e._v("将指定的frame的属性设置为evictable。")]),e._v(" "),a("p",[e._v("需要注意这个frame原先的属性是否与要设置的属性相同，如果不同，需要更新curr_size_。")]),e._v(" "),a("h3",{attrs:{id:"remove"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remove"}},[e._v("#")]),e._v(" Remove")]),e._v(" "),a("p",[e._v("直接删除指定的frame。"),a("strong",[e._v("删除时需要判断对应的frame是否存在")]),e._v("，如果存在，检测其evictable属性，来更新curr_size_。")]),e._v(" "),a("p",[e._v("如果不存在，抛出错误")]),e._v(" "),a("h3",{attrs:{id:"size"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#size"}},[e._v("#")]),e._v(" Size")]),e._v(" "),a("p",[e._v("返回current.size()")]),e._v(" "),a("h2",{attrs:{id:"task3-buffer-pool-manager-instance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task3-buffer-pool-manager-instance"}},[e._v("#")]),e._v(" Task3 Buffer pool Manager  Instance")]),e._v(" "),a("p",[e._v("BufferPoolManager 负责从 DiskManager 获取数据库页并将其存储在内存中。当BufferPoolManager 还需要实现"),a("code",[e._v("evict pages")]),e._v(" 以及写入脏页到disk的功能")]),e._v(" "),a("p",[e._v("我们要知道系统的所有内存都由"),a("code",[e._v("page")]),e._v("表示，"),a("code",[e._v("page")]),e._v("是基本的容器，对应一个固定大小的内存块，用于缓存从disk读取的数据。由于page中的数据的换入换出，同一个page对象可能对应不同的物理块。"),a("code",[e._v("page_id")]),e._v("记录page包含的物理page，如果一个page不含物理页，必须标注为"),a("code",[e._v("INVALID_PAGE_ID")]),e._v("。")]),e._v(" "),a("blockquote",[a("p",[e._v("内存的页叫frame，disk的页才是page，frame拿来装page的，这里为了方便没有特别写出来")])]),e._v(" "),a("p",[a("code",[e._v("Pin")]),e._v(":表示固定，具体来说，每个 Page 对象还维护一个计数器，用于记录“固定”该页面的线程数。我感觉可以理解成"),a("strong",[e._v("引用计数")]),e._v("，有一个地方用了这个页，"),a("code",[e._v("pin_count+1")])]),e._v(" "),a("p",[a("code",[e._v("Dirty page")]),e._v(":每个"),a("code",[e._v("page")]),e._v("还会记录是否为脏页（这是我们要实现从，记录这个page被pin时有没有被修改），如果是的话，必须将脏页写回disk，才能重用这个"),a("code",[e._v("page")])]),e._v(" "),a("p",[a("strong",[e._v("数据结构")]),e._v("：BufferManager类里面都给了，并且有注释。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("pages")]),e._v("连续的空间（数组形式）表示当前所有的frame，pages是数组首地址（或者说指针）")]),e._v(" "),a("li",[a("code",[e._v("free_list_")]),e._v("记录没有装page的frame")]),e._v(" "),a("li",[a("code",[e._v("page_table_")]),e._v("记录page_id到frame的映射")])]),e._v(" "),a("blockquote",[a("p",[e._v("page定义在"),a("code",[e._v("src/include/storage/page/page.h")]),e._v("，我们可以用他的方法")]),e._v(" "),a("p",[e._v("其中"),a("code",[e._v("isdirty_")]),e._v(","),a("code",[e._v("resetmemory()")]),e._v("等等我们都会调用")])]),e._v(" "),a("p",[e._v("每个函数代码里都有提示。下面基本是翻译和一些细节")]),e._v(" "),a("p",[a("strong",[e._v("锁")])]),e._v(" "),a("p",[e._v("依然一个加一个大锁，即函数范围锁")]),e._v(" "),a("p",[a("strong",[e._v("Replacer")])]),e._v(" "),a("p",[e._v("这里我们操作是利用之前实现的LRU-K来驱除page，所以我们进行对应操作时也要更新对应的状态，比如"),a("code",[e._v("RecordAccess")]),e._v("等等")]),e._v(" "),a("h3",{attrs:{id:"newpage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#newpage"}},[e._v("#")]),e._v(" NewPage")]),e._v(" "),a("p",[e._v("获取一个页")]),e._v(" "),a("blockquote",[a("p",[e._v("利用已经提供的"),a("code",[e._v("AllocatePage()")]),e._v("获取"),a("code",[e._v("page_id")]),e._v("，这里并不是指去申请内存，而是从已有的frame中取出可用的，或者替换出一个页，并给予一个新的"),a("code",[e._v("page_id")])]),e._v(" "),a("p",[e._v("diskManager代码在"),a("code",[e._v("src/storage/disk/disk_manager.cpp")])])]),e._v(" "),a("ul",[a("li",[e._v("如果所有的"),a("code",[e._v("pin_count")]),e._v("都不为0，表明没有可用的frame，返回"),a("code",[e._v("nullptr")])]),e._v(" "),a("li",[e._v("如果有没有被引用的页，那么从"),a("code",[e._v("free_list_")]),e._v("中取一个空闲的"),a("code",[e._v("frame")]),e._v(",")]),e._v(" "),a("li",[e._v("如果没有空闲的页，那么我们可以通过LRU-K Replacer的 Evicit方法获取一个可以驱除的"),a("code",[e._v("frame_id")]),e._v("，并\n"),a("ul",[a("li",[e._v("如果不是脏页，清空，本质上来说清空就是把那个frame的内存设为初始值。\n"),a("ul",[a("li",[a("code",[e._v("inline void ResetMemory() { memset(data_, OFFSET_PAGE_START, BUSTUB_PAGE_SIZE); }")])])])]),e._v(" "),a("li",[e._v("如果是脏页，调用disk manager的方法写回disk。")])])]),e._v(" "),a("li",[e._v("最后都需要删除原来的那个pageid到frame的映射，然后给新得到的"),a("code",[e._v("page")]),e._v("的"),a("code",[e._v("pin_count=1")]),e._v(",并且在"),a("code",[e._v("page_table")]),e._v("中建立"),a("code",[e._v("frame_id")]),e._v("和"),a("code",[e._v("page_id")]),e._v("的映射。并且设置这个页为不可移除\n"),a("ul",[a("li",[e._v("这里为什么一定要pin=1?并且设置为不可移除?")])])])]),e._v(" "),a("h3",{attrs:{id:"fetchpage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fetchpage"}},[e._v("#")]),e._v(" FetchPage")]),e._v(" "),a("p",[e._v("寻找一个页，如果没有，从磁盘读一个函数放到"),a("code",[e._v("frame")]),e._v("，有以下情况")]),e._v(" "),a("ol",[a("li",[e._v("BufferPool中已经存在这个page，不需要读入，直接令其pin_count加一，replacer_更新访问时间，设为不可驱除。如果没有，向下执行")])]),e._v(" "),a("p",[e._v("不存在，那么下面的过程和newPage基本一样，区别是不需要获取新page_id,因为这是寻找某个page，id已知")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("有空闲frame，那么就先读入到空闲的frame里面。设置相应的meta-data(id,dirty,pin_count)等等,然后调用diskmanageer将对应page读入frame，后利用Replacer设置为不可移除。并且page_table添加frame_id与page_id的映射。")])]),e._v(" "),a("li",[a("p",[e._v("有可替换frame，检查该frame里的page是否dirty，是的话要写回。然后将frame里的page清空，之后操作与1相同。page_table需要先移除旧的映射，然后添加新的映射。")])]),e._v(" "),a("li",[a("p",[e._v("如果所有的"),a("code",[e._v("pin_count")]),e._v("都不为0，表明没有可用的frame，返回"),a("code",[e._v("nullptr")]),e._v("，这代表无法读入新的page。")])])]),e._v(" "),a("h3",{attrs:{id:"unpinpage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unpinpage"}},[e._v("#")]),e._v(" UnpinPage")]),e._v(" "),a("p",[e._v("这个函数，需要在Buffer Pool中找到对应的page，将其pin_count减一，并还会设置其"),a("code",[e._v("dirty")]),e._v("标志。还需要根据情况修改一些标志位")]),e._v(" "),a("ul",[a("li",[e._v("找不到对应的page，那么直接返回。")]),e._v(" "),a("li",[e._v("找到了对应的page，但是它的pin_count已经为0，那么也直接返回。")]),e._v(" "),a("li",[e._v("找到了对应的page，且pin_count不为0，那么将其减一，然后检查pin_count是否为0，"),a("strong",[e._v("如果为0就要再调用Replacer将其设置为可移除。")]),e._v(" "),a("ul",[a("li",[e._v("还需要设置page的drity标志，如果本身就是dirty，那么无论传入什么，都不能改变它的dirty性质。如果不为dirty，则设置成与入参一致。")])])])]),e._v(" "),a("h3",{attrs:{id:"flushpage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flushpage"}},[e._v("#")]),e._v(" FlushPage")]),e._v(" "),a("blockquote",[a("p",[e._v("好像不用加锁?")])]),e._v(" "),a("p",[e._v("强制将某个页写回磁盘，并且重置其dirty标志。")]),e._v(" "),a("ul",[a("li",[e._v("如果没有这个页，或者这个页是"),a("code",[e._v("invalid_page_id")]),e._v(",返回false")])]),e._v(" "),a("h3",{attrs:{id:"deletepage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deletepage"}},[e._v("#")]),e._v(" DeletePage")]),e._v(" "),a("p",[e._v("删除一个页（只有这个页的pin_count==0的时候），需要调用已经提供的"),a("code",[e._v("DeallocatePage()")]),e._v("去释放资源。")]),e._v(" "),a("ul",[a("li",[e._v("扫描buffer pool，没找到返回，"),a("strong",[e._v("什么也不干返回true，表示已经删除")])]),e._v(" "),a("li",[e._v("如果找到了，但是pin_count,不能删除，返回false")]),e._v(" "),a("li",[e._v("如果找到了，并且pin_count==0，那么删除他，并且设置"),a("code",[e._v("pages_")]),e._v("对应frame的一些元数据(pin_count,dirty)，并且设置"),a("code",[e._v("page_id=INVALID_PAGE_ID")]),e._v(" "),a("ul",[a("li",[e._v("然后page_table删除映射，DeallocatePage()释放资源")]),e._v(" "),a("li",[e._v("还需要把释放的frame加到"),a("code",[e._v("free_list")]),e._v("中")])])])]),e._v(" "),a("h3",{attrs:{id:"flushallpage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flushallpage"}},[e._v("#")]),e._v(" FlushAllPage")]),e._v(" "),a("blockquote",[a("p",[e._v("这里肯定要加锁，这里有个问题，就是这里加大锁，那么FlushPage加不加锁呢")])])])}),[],!1,null,null,null);a.default=_.exports}}]);