(window.webpackJsonp=window.webpackJsonp||[]).push([[247],{574:function(e,t,a){"use strict";a.r(t);var r=a(4),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("https://www.51cto.com/article/721581.html")]),e._v(" "),t("p",[e._v("https://www.yii666.com/blog/478861.html")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/nullzx/p/8729425.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("B+树插入，删除等操作"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"task1-b-tree-pages"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#task1-b-tree-pages"}},[e._v("#")]),e._v(" Task1:B+ Tree pages")]),e._v(" "),t("p",[e._v("第一个Task需要完成三个page，分别是B+Tree Page，B+ Tree Internal Page，B+Tree Leaf Page。")]),e._v(" "),t("h3",{attrs:{id:"b-tree-page"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-page"}},[e._v("#")]),e._v(" B+ Tree Page")]),e._v(" "),t("p",[e._v("这个类是InternalPage与LeafPage的基类，主要是完成一些Get/Set方法。\n最后需要注意一点，GetMinSize()这个方法，"),t("strong",[e._v("中间节点的GetMinSize()是上取整的，而叶子节点的是下取整的。比如说MaxSize=3，那么中间节点的半满被认为是2，而叶子节点的半满被认为是1。")])]),e._v(" "),t("h3",{attrs:{id:"b-tree-internal-page"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-internal-page"}},[e._v("#")]),e._v(" B+ Tree Internal Page")]),e._v(" "),t("p",[e._v("由于存储key-value pair的数组是这个类的私有成员，将来我们在B+树中使用中间节点时，无法访问到里面的数据，所以需要视情况自己增加一些想完成某些操作的函数在里面，因为从B+树那边是无法直接修改页面里的数据的。\n中间节点的第一个key总是设置为空，因为中间节点的key数量比指向儿子节点的指针少1.")]),e._v(" "),t("h3",{attrs:{id:"b-tree-leaf-page"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-leaf-page"}},[e._v("#")]),e._v(" B+ Tree Leaf Page")]),e._v(" "),t("p",[t("strong",[e._v("叶子节点的key-value数量一致，所以第一个key不用设置为空")]),e._v("。")]),e._v(" "),t("p",[e._v("需要注意的点类似于中间节点，叶子节点的value是指向tuple的指针，而中间节点的value是指向叶节点的指针。")]),e._v(" "),t("h2",{attrs:{id:"task2-b-tree-insert-getvalue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#task2-b-tree-insert-getvalue"}},[e._v("#")]),e._v(" Task2:B+ Tree Insert/GetValue")]),e._v(" "),t("p",[e._v("B+树的插入，首先我们需要从根节点，一路前进到对应的叶节点。中间路径上的节点需要保存下来的，方便我们找到父节点，保存可以使用project里自带的Context类，里面有两个双端队列可以用来保存路径上的节点。")]),e._v(" "),t("p",[e._v("一旦到达指定的根节点，就要检测是否存在重复的key，不存在才可以进行插入。\n然后检查该节点是否还能容纳这个key，如果能，直接插入就结束了。如果不能，那么需要先构造一个较大的临时数组，把所有的key-value放进来，在加上需要插入的那个key-value，然后进行排序。排序完之后一分为二，左半部分的给原先的叶节点，右半部分的给新建的叶节点。之后设置好兄弟指针，然后将中间节点插入到父节点。（中间节点指向新叶节点，递归插入父节点，因为父节点也可能引起分裂）")]),e._v(" "),t("p",[e._v("至于查询，前半部分和插入一样，到达叶节点后，直接检查存不存在对应key即可，存在的话直接返回，不涉及任何修改操作，较为简单。")])])}),[],!1,null,null,null);t.default=s.exports}}]);