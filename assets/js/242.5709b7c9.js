(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{569:function(t,a,o){"use strict";o.r(a);var s=o(4),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("我们之前讨论的数据结构都是单线程的，但是我们也需要通过附加的CPU核，允许多线程并发安全的访问我们的数据结构，减少磁盘I/O的等待。")]),t._v(" "),a("blockquote",[a("p",[t._v("注意下面列举的数据库是单线程的，比如redis，所以不要考虑多线程问题")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214094534065.png",alt:"image-20231214094534065"}}),t._v(" "),a("h2",{attrs:{id:"concurrency-contrrol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrency-contrrol"}},[t._v("#")]),t._v(" Concurrency   Contrrol")]),t._v(" "),a("p",[t._v("当存在shared  object时，DBMS的的并发控制协议就确保最终有一个正确并发结构的机制。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214100622461.png",alt:"image-20231214100622461"}})]),t._v(" "),a("h2",{attrs:{id:"latches-overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#latches-overview"}},[t._v("#")]),t._v(" Latches  Overview")]),t._v(" "),a("p",[t._v("Lock一般被事务持有，一般是逻辑，宏观的，比如事务中lock  某行")]),t._v(" "),a("p",[t._v("Latches一般才是用来保护数据库内部一个具体的数据结构的，是一个具体的物理的锁。")]),t._v(" "),a("ul",[a("li",[t._v("常常称为mutex")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214100701675.png",alt:"image-20231214100701675"}}),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214100806878.png",alt:"image-20231214100806878"}}),t._v(" "),a("h3",{attrs:{id:"lacth-mode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lacth-mode"}},[t._v("#")]),t._v(" Lacth  Mode")]),t._v(" "),a("p",[t._v("读锁和写锁，这个很常见。只有读锁和读锁可以兼容，")]),t._v(" "),a("ul",[a("li",[t._v("读锁也叫共享锁")]),t._v(" "),a("li",[t._v("写锁页叫")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214100839942.png",alt:"image-20231214100839942"}}),t._v(" "),a("h3",{attrs:{id:"latch-implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#latch-implementation"}},[t._v("#")]),t._v(" Latch Implementation")]),t._v(" "),a("h4",{attrs:{id:"blocking-os-mutex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blocking-os-mutex"}},[t._v("#")]),t._v(" Blocking Os  Mutex")]),t._v(" "),a("p",[t._v("利用OS Latch为底层实现的锁，比如C++的"),a("code",[t._v("std::mutex")]),t._v("。")]),t._v(" "),a("p",[t._v("具体来说，就是我有一个线程对一个变量申请了锁，那么他会在"),a("strong",[t._v("用户态")]),t._v("给他加个锁，这样导致其他线程访问这个变量的时候，就会被"),a("strong",[t._v("系统态")]),t._v("sleep。")]),t._v(" "),a("ul",[a("li",[t._v("如果这个锁释放了，Os唤醒其他等待的线程")]),t._v(" "),a("li",[t._v("优点是方便，线程等待时避免了线程竞争资源浪费。   缺点是需要系统来操作线程（比如睡眠，唤醒），而操作线程很耗时间")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214101207267.png",alt:"image-20231214101207267"}}),t._v(" "),a("h4",{attrs:{id:"test-and-set-spin-latch-tas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-and-set-spin-latch-tas"}},[t._v("#")]),t._v(" Test and Set Spin  Latch(TAS)")]),t._v(" "),a("p",[t._v("**自旋锁，**这个也非常好理解，就是一个线程锁住了变量，那么其他线程就进入死循环，一直问这个变量锁解开没有，解开了跳出。")]),t._v(" "),a("ul",[a("li",[t._v("例如"),a("code",[t._v("std::atomic<T>")]),t._v("，"),a("strong",[t._v("需要变量是原子操作")])]),t._v(" "),a("li",[t._v("缺点：会增大开销，因为线程一直在竞争资源")])]),t._v(" "),a("p",[a("strong",[t._v("这个的特点就是多个线程一直竞争某个锁")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214101939424.png",alt:"image-20231214101939424"}}),t._v(" "),a("h4",{attrs:{id:"reader-writer-latches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reader-writer-latches"}},[t._v("#")]),t._v(" Reader-Writer  Latches")]),t._v(" "),a("p",[t._v("读写锁是在系统锁或者自旋锁基础上实现的")]),t._v(" "),a("ul",[a("li",[t._v("允许并发读")]),t._v(" "),a("li",[t._v("需要管理读写锁加锁的顺序，不然可能导致"),a("code",[t._v("starvation")]),t._v("（锁饥饿问题，比如一个线程一直得不到写锁）")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214102213133.png",alt:"image-20231214102213133"}}),t._v(" "),a("h2",{attrs:{id:"hash-table-latches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-table-latches"}},[t._v("#")]),t._v(" Hash Table  Latches")]),t._v(" "),a("p",[t._v("Hash表比较容易支持并发，比如之前的开放地址哈希，由于他的数据都是向下移动的，并且一次只操作一个slot")]),t._v(" "),a("ul",[a("li",[t._v("当hash表扩容时，应该加一个全局锁")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214103645304.png",alt:"image-20231214103645304"}}),t._v(" "),a("h3",{attrs:{id:"page-latches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#page-latches"}},[t._v("#")]),t._v(" Page Latches")]),t._v(" "),a("p",[t._v("这里这个page也可以解释成桶，或者一段，反正就是指锁住的一个范围内的数据")]),t._v(" "),a("blockquote",[a("p",[t._v("java里面的并发哈希表就是Page Latches，而不是slot Latches，")]),t._v(" "),a("p",[t._v("因为Page 粒度已经够了，再低可能系统压力太大")])]),t._v(" "),a("p",[t._v("下面的例子中中T1是查询请求，T2是插入请求。")]),t._v(" "),a("blockquote",[a("p",[t._v("注意读写锁是互斥的，一个位置有读锁，就不能加写锁，反过来也是这样")])]),t._v(" "),a("p",[t._v("T1首先给1号桶，加了一个读锁，此时T2就等待")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214110335676.png",alt:"image-20231214110335676"}}),t._v(" "),a("p",[t._v("T1发现1号桶里面没有D，所以释放读锁，并去2号桶查找D，加读锁；T2尝试插入E，所以给1号桶加读锁。")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214110603181.png",alt:"image-20231214110603181"}}),t._v(" "),a("p",[t._v("T1发现2号桶中有D，所以查找完释放了读锁；T2发现1号桶中没有位置了，所以向下找到2号桶（已经没有读锁了），所以加了一个写锁。")]),t._v(" "),a("p",[t._v("由于有一个空位，所以最后成功插入了E，并最终释放写锁。")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214110821496.png",alt:"image-20231214110821496"}}),t._v(" "),a("h3",{attrs:{id:"slot-latches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slot-latches"}},[t._v("#")]),t._v(" Slot Latches")]),t._v(" "),a("p",[t._v("这里的solt就是hash槽。")]),t._v(" "),a("p",[t._v("这里的slot，粒度更小，但是一般用的少，粒度太小了")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214111049700.png",alt:"image-20231214111049700"}}),t._v(" "),a("h3",{attrs:{id:"compare-and-swap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compare-and-swap"}},[t._v("#")]),t._v(" Compare and swap")]),t._v(" "),a("p",[t._v("hash表的并发插入可以是无锁的，如何实现的? 有一种方法叫"),a("strong",[t._v("先比较再设置")]),t._v("。")]),t._v(" "),a("p",[t._v("比如两个线程同时写一个变量20为30，但是需要先判断其是否为20.那么实际执行时，肯定是一个线程先执行，20->30,后一个线程执行时发现是30，那么啥也不干返回失败。")]),t._v(" "),a("blockquote",[a("p",[t._v("感觉还是利用了操作系统的锁，线程操作的原子性，不过不用自己加锁")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214103337345.png",alt:"image-20231214103337345"}}),t._v(" "),a("h2",{attrs:{id:"b-tree-concurrency-control"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-concurrency-control"}},[t._v("#")]),t._v(" B+ Tree  Concurrency   Control")]),t._v(" "),a("p",[t._v("如果我们想并发操作B+树，需要考虑的问题有：")]),t._v(" "),a("ul",[a("li",[t._v("节点内部的数据需要考虑并发安全")]),t._v(" "),a("li",[t._v("如果一个线程在遍历B+树，但是其他线程在分裂/合并B+树的节点")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214111405504.png",alt:"image-20231214111405504"}}),t._v(" "),a("p",[t._v("Example：T2查找的41所在那个节点，而T1删除操作，引发了节点的合并，原来41的节点移动了，那么T2到达原来节点时，没数据了！")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214111853666.png",alt:"image-20231214111853666"}}),t._v(" "),a("h3",{attrs:{id:"latch-crabbing-coupling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#latch-crabbing-coupling"}},[t._v("#")]),t._v(" Latch  Crabbing /Coupling")]),t._v(" "),a("p",[t._v("怎么办呢，对于一个树，我们知道有孩子节点和父亲节点，如果我们已经操作孩子节点，那"),a("strong",[t._v("么如果父亲节点是安全的，就可以释放")])]),t._v(" "),a("p",[t._v("安全节点定义：安全节点当更新时不会分裂/合并的节点")]),t._v(" "),a("ul",[a("li",[t._v("not full")]),t._v(" "),a("li",[t._v("more than half -full")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214112033871.png",alt:"image-20231214112033871"}}),t._v(" "),a("p",[t._v("具体来说，")]),t._v(" "),a("ul",[a("li",[t._v("对于查询操作，先给根节点加读锁，然后一路加读锁，每次释放上一个节点的读锁")]),t._v(" "),a("li",[t._v("对于写/删除操作，先给根节点加写锁，然后一路加写锁，如果上一个节点是安全的，才可以给他释放锁，否则等操作完了再给他释放")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214112401892.png",alt:"image-20231214112401892"}}),t._v(" "),a("p",[t._v("举例")]),t._v(" "),a("p",[t._v("这里我们删除38,在35时，我们发现删除38可能导致35被合并，所以不能释放锁")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214112847306.png",alt:"image-20231214112847306"}}),t._v(" "),a("p",[t._v("当我们到达C时，我们发现删掉38不会发生合并，所以解开上面两个A，B的锁。然后给下一个child加写锁")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214113007547.png",alt:"image-20231214113007547"}}),t._v(" "),a("p",[t._v("上一个节点是安全节点，所以可以释放，删除叶子节点中的35后也释放最后的锁")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214113111257.png",alt:"image-20231214113111257"}}),t._v(" "),a("h4",{attrs:{id:"observation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#observation"}},[t._v("#")]),t._v(" Observation")]),t._v(" "),a("p",[t._v("1.根节点总是加锁，是"),a("code",[t._v("bottleneck")]),t._v("（瓶颈）")]),t._v(" "),a("p",[a("strong",[t._v("这里引出了悲观锁和乐观锁，我们上面一直加锁的方法是悲观锁")])]),t._v(" "),a("blockquote",[a("p",[t._v("我们操作叶子节点，一般不会影响根节点，但是我们一直加锁，这是悲观。")])]),t._v(" "),a("h4",{attrs:{id:"乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[t._v("#")]),t._v(" 乐观锁")]),t._v(" "),a("ul",[a("li",[t._v("查询加锁方式不变。")]),t._v(" "),a("li",[t._v("写操作："),a("strong",[t._v("前面加读锁，叶子节点再加写锁。")]),t._v(" "),a("ul",[a("li",[t._v("一路加写锁，导致读锁也进不来，所以并发冲突很严重。加读锁提高效率，但也有问题。所以也是trade-off")])])])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214113901924.png",alt:"image-20231214113901924"}}),t._v(" "),a("h3",{attrs:{id:"leaf-node-scan"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leaf-node-scan"}},[t._v("#")]),t._v(" Leaf node Scan")]),t._v(" "),a("p",[a("strong",[t._v("上面我们的讨论情况中，B+树都是从顶往下遍历，但是B+树也支持直接遍历叶子节点,这种情况怎么加锁?")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214114540842.png",alt:"image-20231214114540842"}}),t._v(" "),a("p",[t._v("这种情况下，需要考虑很多问题，比如这样做不能支持死锁检测，只能通过自己设计规避")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214114627578.png",alt:"image-20231214114627578"}}),t._v(" "),a("h2",{attrs:{id:"conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),a("ul",[a("li",[t._v("并发比单线程难的多的多")]),t._v(" "),a("li",[t._v("我们重点关注B+树的并发控制，因为他的思想在其他数据结构页很多使用的")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214114739938.png",alt:"image-20231214114739938"}})])}),[],!1,null,null,null);a.default=r.exports}}]);