(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{410:function(v,_,t){"use strict";t.r(_);var a=t(4),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"cpu如何执行程序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cpu如何执行程序"}},[v._v("#")]),v._v(" CPU如何执行程序？")]),v._v(" "),_("h3",{attrs:{id:"冯诺依曼模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#冯诺依曼模型"}},[v._v("#")]),v._v(" 冯诺依曼模型")]),v._v(" "),_("p",[_("strong",[v._v("冯诺依曼")]),v._v("定义计算机基本结构为 5 个部分，分别是"),_("strong",[v._v("运算器、控制器、存储器、输入设备、输出设备")]),v._v("，这 5 个部分也被称为"),_("strong",[v._v("冯诺依曼模型")]),v._v("。")]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240328131503987.png",alt:"image-20240328131503987"}}),v._v(" "),_("p",[v._v("存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：")]),v._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240328131450225.png",alt:"image-20240328131450225"}}),v._v(" "),_("p",[_("strong",[v._v("内存")])]),v._v(" "),_("p",[v._v("我们的程序和数据都是存储在内存，存储的区域是线性的。")]),v._v(" "),_("p",[v._v("在计算机数据存储中，存储数据的基本单位是"),_("strong",[v._v("字节（*byte*）")]),v._v("，1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。")]),v._v(" "),_("p",[v._v("内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。")]),v._v(" "),_("p",[_("strong",[v._v("中央处理器")])]),v._v(" "),_("p",[v._v("中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：")]),v._v(" "),_("ul",[_("li",[v._v("32 位 CPU 一次可以计算 4 个字节；")]),v._v(" "),_("li",[v._v("64 位 CPU 一次可以计算 8 个字节；")])]),v._v(" "),_("p",[v._v("这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。")]),v._v(" "),_("p",[v._v("之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 "),_("code",[v._v("0~255")]),v._v(" 范围内的数值，这样就无法一次完成计算 "),_("code",[v._v("10000 * 500")]),v._v(" ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 "),_("code",[v._v("4294967295")]),v._v("。")]),v._v(" "),_("p",[v._v("CPU 内部还有一些组件，常见的有"),_("strong",[v._v("寄存器、控制单元和逻辑运算单元")]),v._v("等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。")]),v._v(" "),_("p",[v._v("CPU 中的寄存器主要作用是存储计算时的数据，你可能好奇为什么有了内存还需要寄存器？原因很简单，因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。")]),v._v(" "),_("p",[v._v("常见的寄存器种类：")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("通用寄存器")]),v._v("，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。")]),v._v(" "),_("li",[_("em",[v._v("程序计数器")]),v._v("，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。")]),v._v(" "),_("li",[_("em",[v._v("指令寄存器")]),v._v("，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。")])]),v._v(" "),_("p",[_("strong",[v._v("总线")])]),v._v(" "),_("p",[v._v("总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：")]),v._v(" "),_("ul",[_("li",[_("em",[v._v("地址总线")]),v._v("，用于指定 CPU 将要操作的内存地址；")]),v._v(" "),_("li",[_("em",[v._v("数据总线")]),v._v("，用于读写内存的数据；")]),v._v(" "),_("li",[_("em",[v._v("控制总线")]),v._v("，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；")])]),v._v(" "),_("p",[v._v("当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：")]),v._v(" "),_("ul",[_("li",[v._v("首先要通过「地址总线」来指定内存的地址；")]),v._v(" "),_("li",[v._v("然后通过「控制总线」控制是读或写命令；")]),v._v(" "),_("li",[v._v("最后通过「数据总线」来传输数据；")])]),v._v(" "),_("p",[_("strong",[v._v("输入、输出设备")])]),v._v(" "),_("p",[v._v("输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。")]),v._v(" "),_("h3",{attrs:{id:"线路位宽与cpu位宽"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线路位宽与cpu位宽"}},[v._v("#")]),v._v(" 线路位宽与CPU位宽")]),v._v(" "),_("p",[v._v("数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。")]),v._v(" "),_("p",[v._v("如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。")]),v._v(" "),_("p",[v._v("这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。")]),v._v(" "),_("p",[_("strong",[v._v("线路位宽：")])]),v._v(" "),_("p",[_("strong",[v._v("为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址")]),v._v("。")]),v._v(" "),_("p",[v._v("CPU 想要操作「内存地址」就需要「地址总线」：")]),v._v(" "),_("ul",[_("li",[v._v("如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内")])]),v._v(" "),_("p",[v._v("那么，想要 "),_("strong",[v._v("CPU 操作 4G 大的内存，那么就需要 32 条地址总线")]),v._v("，因为 "),_("code",[v._v("2 ^ 32 = 4G")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("CPU 位宽：")])]),v._v(" "),_("p",[v._v("CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，"),_("strong",[v._v("因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了")]),v._v(" "),_("li",[v._v("对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，")])]),v._v(" "),_("p",[v._v("但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以"),_("strong",[v._v("如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来")]),v._v("。")]),v._v(" "),_("p",[v._v("Question：32位CPU和64位有什么区别？")]),v._v(" "),_("p",[v._v("这里的位一般就是线路位宽，32位cpu可以寻址4G的空间，64位可以寻址"),_("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[_("mjx-math",{staticClass:"MJX-TEX"},[_("mjx-msup",[_("mjx-mn",{staticClass:"mjx-n"},[_("mjx-c",{attrs:{c:"2"}})],1),_("mjx-script",{staticStyle:{"vertical-align":"0.363em"}},[_("mjx-TeXAtom",{attrs:{size:"s"}},[_("mjx-mn",{staticClass:"mjx-n"},[_("mjx-c",{attrs:{c:"6"}}),_("mjx-c",{attrs:{c:"4"}})],1)],1)],1)],1)],1)],1),v._v("大小的内存。")],1),v._v(" "),_("p",[v._v("并且32位CPU"),_("strong",[v._v("一次")]),v._v("只能处理32位长度数字，64位一次能处理64位长数字")]),v._v(" "),_("h3",{attrs:{id:"程序执行基本过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序执行基本过程"}},[v._v("#")]),v._v(" 程序执行基本过程")]),v._v(" "),_("p",[v._v("程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。")]),v._v(" "),_("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240328140830332.png",alt:"image-20240328140830332"}}),v._v(" "),_("p",[v._v("举例：a=1+2的执行过程")]),v._v(" "),_("p",[v._v("知道了基本的程序执行过程后，接下来用 "),_("code",[v._v("a = 1 + 2")]),v._v(" 的作为例子，进一步分析该程序在冯诺伊曼模型的执行过程。")]),v._v(" "),_("p",[v._v("CPU 是不认识 "),_("code",[v._v("a = 1 + 2")]),v._v(" 这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成"),_("strong",[v._v("汇编语言")]),v._v("的程序，这个过程称为编译成汇编代码。")]),v._v(" "),_("p",[v._v("针对汇编代码，我们还需要用汇编器翻译成机器码，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的"),_("strong",[v._v("计算机指令")]),v._v("，这个才是 CPU 能够真正认识的东西。")]),v._v(" "),_("p",[v._v("下面来看看 "),_("code",[v._v("a = 1 + 2")]),v._v(" 在 32 位 CPU 的执行过程。")]),v._v(" "),_("p",[v._v("程序编译过程中，编译器通过分析代码，发现 1 和 2 是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是「数据段」。如下图，数据 1 和 2 的区域位置：")]),v._v(" "),_("ul",[_("li",[v._v("数据 1 被存放到 0x200 位置；")]),v._v(" "),_("li",[v._v("数据 2 被存放到 0x204 位置；")])]),v._v(" "),_("p",[v._v("注意，数据和指令是分开区域存放的，存放指令区域的地方称为「正文段」。")]),v._v(" "),_("p",[v._v("编译器会把 "),_("code",[v._v("a = 1 + 2")]),v._v(" 翻译成 4 条指令，存放到正文段中。如图，这 4 条指令被存放到了 0x100 ~ 0x10c 的区域中：")]),v._v(" "),_("ul",[_("li",[v._v("0x100 的内容是 "),_("code",[v._v("load")]),v._v(" 指令将 0x200 地址中的数据 1 装入到寄存器 "),_("code",[v._v("R0")]),v._v("；")]),v._v(" "),_("li",[v._v("0x104 的内容是 "),_("code",[v._v("load")]),v._v(" 指令将 0x204 地址中的数据 2 装入到寄存器 "),_("code",[v._v("R1")]),v._v("；")]),v._v(" "),_("li",[v._v("0x108 的内容是 "),_("code",[v._v("add")]),v._v(" 指令将寄存器 "),_("code",[v._v("R0")]),v._v(" 和 "),_("code",[v._v("R1")]),v._v(" 的数据相加，并把结果存放到寄存器 "),_("code",[v._v("R2")]),v._v("；")]),v._v(" "),_("li",[v._v("0x10c 的内容是 "),_("code",[v._v("store")]),v._v(" 指令将寄存器 "),_("code",[v._v("R2")]),v._v(" 中的数据存回数据段中的 0x208 地址中，这个地址也就是变量 "),_("code",[v._v("a")]),v._v(" 内存中的地址；")])]),v._v(" "),_("p",[v._v("编译完成后，具体执行程序的时候，程序计数器会被设置为 0x100 地址，然后依次执行这 4 条指令。")]),v._v(" "),_("p",[v._v("上面的例子中，由于是在 32 位 CPU 执行的，因此一条指令是占 32 位大小，所以你会发现每条指令间隔 4 个字节。")]),v._v(" "),_("p",[v._v("而数据的大小是根据你在程序中指定的变量类型，比如 "),_("code",[v._v("int")]),v._v(" 类型的数据则占 4 个字节，"),_("code",[v._v("char")]),v._v(" 类型的数据则占 1 个字节。")]),v._v(" "),_("h3",{attrs:{id:"q-a"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[v._v("#")]),v._v(" Q&A")]),v._v(" "),_("p",[v._v("1.前面我们知道了CPU有32位和64位的区别，那么软件的32位和64位有什么区别？")]),v._v(" "),_("p",[v._v("answer:  64位和 32 位软件，实际上代表指令是 64 位还是 32 位的：")]),v._v(" "),_("ul",[_("li",[v._v("如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是"),_("strong",[v._v("如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令")]),v._v("；")]),v._v(" "),_("li",[v._v("操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。")])]),v._v(" "),_("p",[v._v("总之，硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽。")]),v._v(" "),_("h2",{attrs:{id:"存储器层次结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储器层次结构"}},[v._v("#")]),v._v(" 存储器层次结构")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240330134234198.png",alt:"image-20240330134234198"}})]),v._v(" "),_("p",[_("strong",[v._v("寄存器")])]),v._v(" "),_("p",[v._v("最靠近 CPU 的控制单元和逻辑计算单元的存储器，就是寄存器了，它使用的材料速度也是最快的，因此价格也是最贵的，那么数量不能很多。")]),v._v(" "),_("p",[v._v("寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据。比如：")]),v._v(" "),_("ul",[_("li",[v._v("32 位 CPU 中大多数寄存器可以存储 "),_("code",[v._v("4")]),v._v(" 个字节；")]),v._v(" "),_("li",[v._v("64 位 CPU 中大多数寄存器可以存储 "),_("code",[v._v("8")]),v._v(" 个字节。")])]),v._v(" "),_("p",[_("strong",[v._v("CPU Cache")])]),v._v(" "),_("p",[v._v("CPU Cache 用的是一种叫 "),_("strong",[v._v("SRAM（*Static Random-Access* Memory，静态随机存储器）")]),v._v(" 的芯片。")]),v._v(" "),_("p",[v._v("SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。")]),v._v(" "),_("p",[v._v("CPU 的高速缓存，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。")]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240330134405155.png",alt:"image-20240330134405155"}}),v._v(" "),_("p",[_("strong",[v._v("内存")])]),v._v(" "),_("p",[v._v("内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 "),_("strong",[v._v("DRAM （*Dynamic Random Access Memory*，动态随机存取存储器）")]),v._v(" 的芯片。")]),v._v(" "),_("p",[v._v("相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。")]),v._v(" "),_("p",[_("strong",[v._v("SSD/HDD 硬盘")])]),v._v(" "),_("p",[v._v("SSD（"),_("em",[v._v("Solid-state disk")]),v._v("） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都")]),v._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\\L2\\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构。")]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240330135333259.png",alt:"image-20240330135333259"}}),v._v(" "),_("p",[v._v("你可以看到 L1 Cache 的访问延时是 1 纳秒，而内存已经是 100 纳秒了，相比 L1 Cache 速度慢了 "),_("code",[v._v("100")]),v._v(" 倍。另外，机械硬盘的访问延时更是高达 10 毫秒，相比 L1 Cache 速度慢了 "),_("code",[v._v("10000000")]),v._v(" 倍，差了好几个数量级别。")]),v._v(" "),_("p",[v._v("在价格上，每生成 MB 大小的 L1 Cache 相比内存贵了 "),_("code",[v._v("466")]),v._v(" 倍，相比机械硬盘那更是贵了 "),_("code",[v._v("175000")]),v._v(" 倍。")]),v._v(" "),_("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20240330135412023.png",alt:"image-20240330135412023"}}),v._v(" "),_("ul",[_("li",[v._v("SSD 比机械硬盘快 70 倍左右；")]),v._v(" "),_("li",[v._v("内存比机械硬盘快 100000 倍左右；")]),v._v(" "),_("li",[v._v("CPU L1 Cache 比机械硬盘快 10000000 倍左右；")])])])}),[],!1,null,null,null);_.default=s.exports}}]);