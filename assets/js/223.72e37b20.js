(window.webpackJsonp=window.webpackJsonp||[]).push([[223],{551:function(s,e,a){"use strict";a.r(e);var _=a(4),t=Object(_.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"引言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[s._v("#")]),s._v(" 引言")]),s._v(" "),e("p",[s._v("使用Redis时，我们经常会遇到这样一个问题：明明做了数据删除，数据量已经不大了，为什么使用top命令查看时，还会发现Redis占用了很多内存呢？")]),s._v(" "),e("p",[s._v("实际上，这是因为，当数据删除后**，Redis释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给Redis分配了大量内存。**")]),s._v(" "),e("p",[s._v("这往往会伴随一个潜在的风险点：Redis释放的内存空间可能并不是连续的，那么，这些不连续的内存空间很有可能处于一种闲置的状态。这就会导致一个问题：虽然有空闲空间，Redis却无法用来保存数据，不仅会减少Redis能够实际保存的数据量，还会降低Redis运行机器的成本回报率。")]),s._v(" "),e("h2",{attrs:{id:"什么是内存碎片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存碎片"}},[s._v("#")]),s._v(" 什么是内存碎片？")]),s._v(" "),e("p",[s._v("通常情况下，内存空间闲置，往往是因为操作系统发生了较为严重的内存碎片。那么，什么是内存碎片呢？")]),s._v(" "),e("p",[s._v("为了方便你理解，我还是借助高铁的车厢座位来进行解释。假设一个车厢的座位总共有60个，现在已经卖了57张票，你和2个小伙伴要乘坐高铁出门旅行，刚好需要三张票。不过，你们想要坐在一起，这样可以在路上聊天。但是，在选座位时，你们却发现，已经买不到连续的座位了。于是，你们只好换了一趟车。这样一来，你们需要改变出行时间，而且这趟车就空置了三个座位。")]),s._v(" "),e("p",[s._v("其实，这趟车的空座位是和你们的人数相匹配的，只是这些空座位是分散的，如下图所示：")]),s._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231103213714593.png",alt:"image-20231103213714593"}}),s._v(" "),e("p",[s._v("我们可以把这些分散的空座位叫作“车厢座位碎片”，知道了这一点，操作系统的内存碎片就很容易理解了**。虽然操作系统的剩余内存空间总量足够，但是，应用申请的是一块连续地址空间的N字节，但在剩余的内存空间中，没有大小为N字节的连续空间了，那么，这些剩余空间就是内存碎片**（比如上图中的“空闲2字节”和“空闲1字节”，就是这样的碎片）。")]),s._v(" "),e("h2",{attrs:{id:"内存碎片是如何形成的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片是如何形成的"}},[s._v("#")]),s._v(" 内存碎片是如何形成的？")]),s._v(" "),e("p",[s._v("其实，内存碎片的形成有内因和外因两个层面的原因。简单来说，内因是操作系统的内存分配机制，外因是Redis的负载特征。")]),s._v(" "),e("h3",{attrs:{id:"内因-内存分配器的分配策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内因-内存分配器的分配策略"}},[s._v("#")]),s._v(" 内因：内存分配器的分配策略")]),s._v(" "),e("p",[s._v("内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，"),e("strong",[s._v("内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。")])]),s._v(" "),e("p",[s._v("Redis可以使用libc、jemalloc、tcmalloc多种内存分配器来分配内存，默认使用jemalloc。")]),s._v(" "),e("p",[e("strong",[s._v("jemalloc的分配策略之一，是按照一系列固定的大小划分内存空间，例如8字节、16字节、32字节、48字节，…, 2KB、4KB、8KB等。当程序申请的内存最接近某个固定值时，jemalloc会给它分配相应大小的空间。")])]),s._v(" "),e("p",[s._v("这样的分配方式本身是为了减少分配次数。例如，Redis申请一个20字节的空间保存数据，jemalloc就会分配32字节，此时，如果应用还要写入10字节的数据，Redis就不用再向操作系统申请空间了，因为刚才分配的32字节已经够用了，这就避免了一次分配操作。")]),s._v(" "),e("blockquote",[e("p",[s._v("因此，如果Redis每次向分配器申请的内存空间大小不一样，这种分配方式就会有形成碎片的风险，这也正是外因。")])]),s._v(" "),e("h3",{attrs:{id:"外因-键值对大小不一样和删改操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#外因-键值对大小不一样和删改操作"}},[s._v("#")]),s._v(" 外因：键值对大小不一样和删改操作")]),s._v(" "),e("p",[s._v("Redis通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在Redis中，"),e("strong",[s._v("这就会带来不同大小的键值对。这样一来，Redis申请内存空间分配时，本身就会有大小不一的空间需求。这是第一个外因。")])]),s._v(" "),e("p",[s._v("但是咱们刚刚讲过，内存分配器只能按固定大小分配内存，所以，分配的内存空间一般都会比申请的空间大一些，不会完全一致，这本身就会造成一定的碎片，降低内存空间存储效率。")]),s._v(" "),e("p",[s._v("比如说，应用A保存6字节数据，jemalloc按分配策略分配8字节。"),e("strong",[s._v("如果应用A不再保存新数据，那么，这里多出来的2字节空间就是内存碎片了。")])]),s._v(" "),e("p",[e("strong",[s._v("第二个外因是，这些键值对会被修改和删除，这会导致空间的扩容和释放")]),s._v("。具体来说，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。")]),s._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231103214241012.png",alt:"image-20231103214241012"}}),s._v(" "),e("blockquote",[e("p",[s._v("一开始，应用A、B、C、D分别保存了3、1、2、4字节的数据，并占据了相应的内存空间。然后，应用D删除了1个字节，这个1字节的内存空间就空出来了。紧接着，应用A修改了数据，从3字节变成了4字节。为了保持A数据的空间连续性，操作系统就需要把B的数据拷贝到别的空间，比如拷贝到D刚刚释放的空间中。此时，应用C和D也分别删除了2字节和1字节的数据，整个内存空间上就分别出现了2字节和1字节的空闲碎片。")]),s._v(" "),e("p",[e("strong",[s._v("此时，如果应用E想要一个3字节的连续空间，显然是不能得到满足的。因为，虽然空间总量够，但却是碎片空间，并不是连续的。")])])]),s._v(" "),e("h2",{attrs:{id:"如何判断是否有内存碎片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何判断是否有内存碎片"}},[s._v("#")]),s._v(" 如何判断是否有内存碎片？")]),s._v(" "),e("p",[s._v("大量内存碎片的存在，会造成Redis的内存实际利用率变低。")]),s._v(" "),e("p",[s._v("Redis是内存数据库，内存利用率的高低直接关系到Redis运行效率的高低。为了让用户能监控到实时的内存使用情况，Redis自身提供了INFO命令")]),s._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[s._v("INFO memory\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Memory")]),s._v("\nused_memory:1073741736\nused_memory_human:1024.00M\nused_memory_rss:1997159792\nused_memory_rss_human:1.86G\n…\nmem_fragmentation_ratio:1.86\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("这里有一个mem_fragmentation_ratio的指标，它表示的就是Redis当前的内存碎片率。其等于"),e("code",[s._v("used_memory_rss/used_memory")]),s._v("。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("mem_fragmentation_ratio = used_memory_rss/ used_memory\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("used_memory_rss是操作系统实际分配给Redis的物理内存空间，里面就包含了碎片；而used_memory是Redis为了保存数据实际申请使用的空间。")]),s._v(" "),e("p",[s._v("例如，Redis申请使用了100字节（used_memory），操作系统实际分配了128字节（used_memory_rss），此时，mem_fragmentation_ratio就是1.28。")]),s._v(" "),e("p",[e("strong",[s._v("一些经验阈值：")])]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("mem_fragmentation_ratio 大于1但小于1.5")]),s._v("。这种情况是合理的。这是因为，刚才我介绍的那些因素是难以避免的。毕竟，内因的内存分配器是一定要使用的，分配策略都是通用的，不会轻易修改；而外因由Redis负载决定，也无法限制。所以，存在内存碎片也是正常的。")]),s._v(" "),e("li",[e("strong",[s._v("mem_fragmentation_ratio 大于 1.5")]),s._v(" 。这表明内存碎片率已经超过了50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。")])]),s._v(" "),e("h2",{attrs:{id:"如何清理内存碎片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何清理内存碎片"}},[s._v("#")]),s._v(" 如何清理内存碎片？")]),s._v(" "),e("p",[s._v("当Redis发生内存碎片后，一个“简单粗暴”的方法就是"),e("strong",[s._v("重启Redis实例")]),s._v("。当然，这并不是一个“优雅”的方法，毕竟，"),e("strong",[s._v("重启Redis会带来两个后果：")])]),s._v(" "),e("ul",[e("li",[s._v("如果Redis中的数据没有持久化，那么，数据就会丢失；")]),s._v(" "),e("li",[s._v("即使Redis数据持久化了，我们还需要通过AOF或RDB进行恢复，恢复时长取决于AOF或RDB的大小，如果只有一个Redis实例，恢复阶段无法提供服务。")])]),s._v(" "),e("p",[s._v("除此之外怎么清理？")]),s._v(" "),e("p",[s._v("从4.0-RC3版本以后，"),e("strong",[s._v("Redis自身提供了一种内存碎片自动清理的方法，")])]),s._v(" "),e("blockquote",[e("p",[s._v("有点像java的GC")])]),s._v(" "),e("p",[s._v('Redis的内存碎片清理，就是"搬家让位，合并空间"')]),s._v(" "),e("p",[s._v("当有数据把一块连续的内存空间分割成好几块不连续的空间时，操作系统就会把数据拷贝到别处。"),e("strong",[s._v("此时，数据拷贝需要能把这些数据原来占用的空间都空出来，把原本不连续的内存空间变成连续的空间。否则，如果数据拷贝后，并没有形成连续的内存空间，这就不能算是清理了。")])]),s._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231103220945991.png",alt:"image-20231103220945991"}}),s._v(" "),e("blockquote",[e("p",[s._v("在进行碎片清理前，这段10字节的空间中分别有1个2字节和1个1字节的空闲空间，只是这两个空间并不连续。操作系统在清理碎片时，会先把应用D的数据拷贝到2字节的空闲空间中，并释放D原先所占的空间。然后，再把B的数据拷贝到D原来的空间中。这样一来，这段10字节空间的最后三个字节就是一块连续空间了。到这里，碎片清理结束。")])]),s._v(" "),e("p",[e("strong",[s._v("碎片清理是有代价的")]),s._v("，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为Redis是单线程，在数据拷贝时，Redis只能等着，这就导致Redis无法及时处理请求，性能就会降低。而且，有的时候，数据拷贝还需要注意顺序，就像刚刚说的清理内存碎片的例子，操作系统需要先拷贝D，并释放D的空间后，才能拷贝B。这种对顺序性的要求，会进一步增加Redis的等待时间，导致性能降低。")]),s._v(" "),e("p",[s._v("为了缓解这个问题，"),e("strong",[s._v("Redis专门为自动内存碎片清理功机制设置的参数")]),s._v("了。我们可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的CPU比例，从而减少碎片清理对Redis本身请求处理的性能影响。")]),s._v(" "),e("p",[s._v("首先，Redis需要启用自动内存碎片清理，可以把activedefrag配置项设置为yes，命令如下：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("config set activedefrag yes\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("这个命令只是启用了自动清理功能，但是，具体什么时候清理，会受到下面这两个参数的控制。这两个参数分别设置了触发内存清理的一个条件，如果同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理。")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("active-defrag-ignore-bytes 100mb")]),s._v("：表示内存碎片的字节数达到100MB时，开始清理；")]),s._v(" "),e("li",[e("strong",[s._v("active-defrag-threshold-lower 10")]),s._v("：表示内存碎片空间占操作系统分配给Redis的总空间比例达到10%时，开始清理。")])]),s._v(" "),e("p",[s._v("为了尽可能减少碎片清理对Redis正常请求处理的影响，自动内存碎片清理功能在执行时，还会监控清理操作占用的CPU时间，而且还设置了两个参数，分别用于控制清理操作占用的CPU时间比例的上、下限，既保证清理工作能正常进行，又避免了降低Redis性能。这两个参数具体如下：")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("active-defrag-cycle-min 25")]),s._v("： 表示自动清理过程所用CPU时间的比例不低于25%，保证清理能正常开展；")]),s._v(" "),e("li",[e("strong",[s._v("active-defrag-cycle-max 75")]),s._v("：表示自动清理过程所用CPU时间的比例不高于75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞Redis，导致响应延迟升高。")])]),s._v(" "),e("p",[s._v("自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑了碎片的空间占比、对Redis内存使用效率的影响，还考虑了清理机制本身的CPU时间占比、对Redis性能的影响。而且，清理机制还提供了4个参数，让我们可以根据实际应用中的数据量需求和性能要求灵活使用，建议你在实践中好好地把这个机制用起来。")]),s._v(" "),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),e("p",[s._v("这节课了解了Redis的内存空间效率问题，这里面的一个关键技术点就是要识别和处理内存碎片。简单来说，就是“三个一”：")]),s._v(" "),e("ul",[e("li",[s._v("info memory命令是一个"),e("strong",[s._v("好工具")]),s._v("，可以帮助你查看碎片率的情况；")]),s._v(" "),e("li",[s._v("碎片率阈值是一个"),e("strong",[s._v("好经验")]),s._v("，可以帮忙你有效地判断是否要进行碎片清理了；")]),s._v(" "),e("li",[s._v("内存碎片自动清理是一个"),e("strong",[s._v("好方法")]),s._v("，可以避免因为碎片导致Redis的内存实际利用率降低，提升成本收益率。")])]),s._v(" "),e("p",[s._v("内存碎片并不可怕，我们要做的就是了解它，重视它，并借用高效的方法解决它。")]),s._v(" "),e("p",[s._v("最后，我再给你提供一个小贴士：**内存碎片自动清理涉及内存拷贝，这对Redis而言，是个潜在的风险。**如果你在实践过程中遇到Redis性能变慢，记得通过日志看下是否正在进行碎片清理。如果Redis的确正在清理碎片，那么，我建议你调小active-defrag-cycle-max的值，以减轻对正常请求处理的影响。")]),s._v(" "),e("h2",{attrs:{id:"q-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[s._v("#")]),s._v(" Q&A：")]),s._v(" "),e("p",[s._v("1.使用mem_fragmentation_ratio来判断Redis当前的内存碎片率是否严重，我给出的经验阈值都是大于1的。那么，我想请你来聊一聊，如果mem_fragmentation_ratio小于1了，Redis的内存使用是什么情况呢？会对Redis的性能和内存空间利用率造成什么影响呢？")])])}),[],!1,null,null,null);e.default=t.exports}}]);