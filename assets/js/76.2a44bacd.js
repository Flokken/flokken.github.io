(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{405:function(t,a,r){"use strict";r.r(a);var _=r(4),o=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("本系列笔记来自于"),a("a",{attrs:{href:"https://www.bilibili.com/video/BV1D341177SV/?t=2&spm_id_from=333.1350.jump_directly&vd_source=d005def162a369d30cf8c241225a9395",target:"_blank",rel:"noopener noreferrer"}},[t._v("小傅哥的设计模式讲解"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/BV1D341177SV/?t=2&spm_id_from=333.1350.jump_directly&vd_source=d005def162a369d30cf8c241225a9395",target:"_blank",rel:"noopener noreferrer"}},[t._v("教科书"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.runoob.com/design-pattern/design-pattern-tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("菜鸟设计模式"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("设计模式是什么？")]),t._v(" "),a("p",[t._v("设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。")]),t._v(" "),a("blockquote",[a("p",[t._v("再说白一点就是怎么来写出好代码的一些套路")])]),t._v(" "),a("h2",{attrs:{id:"设计模式的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的分类"}},[t._v("#")]),t._v(" 设计模式的分类")]),t._v(" "),a("p",[t._v("设计模式的三个分类")]),t._v(" "),a("p",[a("strong",[t._v("创建型模式")]),t._v("：对象实例化的模式，创建型模式用于解耦对象的实例化过程。这类模式提供创建对象的机制， 能够提升已有代码的灵活性和可复⽤性。")]),t._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227151303954.png",alt:"image-20231227151303954"}}),t._v(" "),a("p",[a("strong",[t._v("结构型模式")]),t._v("：把类或对象结合在一起形成一个更大的结构。这类模式介绍如何将对象和类组装成较⼤的结构， 并同时保持结构的灵活和⾼效。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227151332845.png",alt:"image-20231227151332845"}})]),t._v(" "),a("p",[a("strong",[t._v("行为型模式")]),t._v("：类和对象如何交互，及划分责任和算法。这类模式负责对象间的⾼效沟通和职责委派。")]),t._v(" "),a("img",{staticStyle:{zoom:"100%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227151416208.png",alt:"image-20231227151416208"}}),t._v(" "),a("p",[a("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227151407066.png",alt:"image-20231227151407066"}})]),t._v(" "),a("h2",{attrs:{id:"设计模式六大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式六大原则"}},[t._v("#")]),t._v(" 设计模式六大原则")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("单⼀职责( ⼀个类和⽅法只做⼀件事 )")]),t._v(" "),a("p",[t._v("也叫单一功能原则，是面对对象五大基本原则之一。")])]),t._v(" "),a("li",[a("p",[t._v("⾥⽒替换( 多态，⼦类可扩展⽗类 )")])])]),t._v(" "),a("p",[t._v("里氏替换原则：继承必须保证超类的性质在子类中依然成立")]),t._v(" "),a("p",[t._v("比如下面这个例子，子类继承了父类的所有性质，但是又多了一些新的性质")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231227154941702.png",alt:"image-20231227154941702"}}),t._v(" "),a("ul",[a("li",[t._v("依赖 倒置( 细节依赖抽象，下层依赖上层 )")])]),t._v(" "),a("p",[t._v("程序要依赖于抽象接口编程，不要依赖于具体实现，以此降低客户与实现模块之间的耦合。")]),t._v(" "),a("blockquote",[a("p",[t._v("其实接口就是一种依赖倒置?  可以有不同的实现类")]),t._v(" "),a("p",[t._v("表比如我们写了一个程序，可以根据用户的指令选取权重抽奖和随机抽奖，写在了一个文件里。现在我可以写一个抽奖的接口，然后写权重抽奖和随机抽奖的实现类。")])]),t._v(" "),a("ul",[a("li",[t._v("接⼝隔离( 建⽴单⼀接⼝ )")])]),t._v(" "),a("p",[t._v("要求将庞大的接口拆分为更小更具体的接口，让接口中只包含用户感兴趣的部分。")]),t._v(" "),a("p",[t._v("举例：假设王者荣耀有隐身，沉默，击飞，眩晕四种类型技能。如果这四个写一起是一个接口，那么英雄就都得实现这四个，所以可以把他拆成四个接口来定义（当然，也要结合实际场景分析）")]),t._v(" "),a("ul",[a("li",[t._v("迪⽶特原则( 最少知道，降低耦合 )")])]),t._v(" "),a("p",[t._v("这个原则核心是尽量让模块之间独立开，降低耦合，这样整个系统的功能模块独立开来，互相之间不存在（或者很少）有依赖关系。")]),t._v(" "),a("ul",[a("li",[t._v("开闭 原则( 抽象架构，扩展实现 )")])]),t._v(" "),a("p",[t._v("软件中的对象（类，模块，函数等等）应该是对于拓展是开放的，但是对于修改时封闭的。")]),t._v(" "),a("blockquote",[a("p",[t._v("具体来说就是，假设有A，B两个模块，B要使用A的功能，并且想在上面加点功能，那么你不应该改动A的代码（显然的，如果你改了，后面只使用到A时就麻烦了），而是写个新模块继承他的功能并且拓展这个新模块")])])])}),[],!1,null,null,null);a.default=o.exports}}]);