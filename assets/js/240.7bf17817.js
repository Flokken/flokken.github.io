(window.webpackJsonp=window.webpackJsonp||[]).push([[240],{570:function(a,t,s){"use strict";s.r(t);var e=s(4),i=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"access-methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#access-methods"}},[a._v("#")]),a._v(" Access Methods")]),a._v(" "),t("p",[a._v("首先我们看一下cmu这个课的体系，我们之前已经学习了disk manager和buffer pool manager。")]),a._v(" "),t("p",[a._v("那么我们现在就需要去找到一种东西支持我们去读写页页上的数据，这种支持是什么呢，就是数据结构。")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:/Users/28788/AppData/Roaming/Typora/typora-user-images/image-20231211095105965.png",alt:"image-20231211095105965"}}),a._v(" "),t("p",[t("strong",[a._v("重点是两种数据结构")])]),a._v(" "),t("ul",[t("li",[a._v("Hash Tables")]),a._v(" "),t("li",[a._v("Trees")])]),a._v(" "),t("h2",{attrs:{id:"hash-table"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash-table"}},[a._v("#")]),a._v(" Hash Table")]),a._v(" "),t("p",[a._v("我们设计的hash表重点关注两个方面：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("DataOrganization")]),a._v("：如何在内存/pages中布局数据，并且存储那些数据来支持有效的读取")]),a._v(" "),t("li",[t("strong",[a._v("Concurrency")]),a._v("：我们需要允许多个进程并发读写hash表\n"),t("ul",[t("li",[a._v("这里可以提一嘴java的concurrentHashTable。就能支持并发读写hash表")])])])]),a._v(" "),t("p",[a._v("Hash表我们很熟悉，通过一个hash函数，将key映射到value")]),a._v(" "),t("p",[a._v("比如  对于长度为n的数组，我们选取hash函数是 i%n,这样就能得打一个hash表。")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211100318553.png",alt:"image-20231211100318553"}}),a._v(" "),t("p",[a._v("这里注意，value不一定存的就是value，也可以是"),t("strong",[a._v("value的地址的指针")]),a._v("。同时，我们还注意到一个问题，就是hash函数对不同的可以映射之后的value可能一样，这回导致"),t("strong",[a._v("hash冲突")]),a._v("。  比如上面的取模hash函数，假设n=100,那么key105,205时就会产生hash碰撞")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211100809000.png",alt:"image-20231211100809000"}})]),a._v(" "),t("p",[a._v("复杂度:")]),a._v(" "),t("ul",[t("li",[a._v("时间复杂度：  O(n)")]),a._v(" "),t("li",[a._v("空间复杂度：平均是O(1),最差是O(n)")])]),a._v(" "),t("h3",{attrs:{id:"hash-function"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash-function"}},[a._v("#")]),a._v(" Hash Function")]),a._v(" "),t("ul",[t("li",[a._v("hash函数：对于一个输入的key，返回一个整数代表这个key")]),a._v(" "),t("li",[a._v("我们不想使用加密算法去算hash值\n"),t("ul",[t("li",[a._v("开销太大")]),a._v(" "),t("li",[a._v("不能反译")])])]),a._v(" "),t("li",[t("strong",[a._v("我们希望他尽量快，尽量少发送hash碰撞")])])]),a._v(" "),t("p",[a._v("这是一些出名的hash函数的表现")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211101822938.png",alt:"image-20231211101822938"}}),a._v(" "),t("h3",{attrs:{id:"statci-hashing-schemes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#statci-hashing-schemes"}},[a._v("#")]),a._v(" Statci Hashing Schemes")]),a._v(" "),t("p",[a._v("课上介绍了三种静态hash函数")]),a._v(" "),t("blockquote",[t("p",[a._v("了解即可，并不常用")])]),a._v(" "),t("h4",{attrs:{id:"liner-probe-hashing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#liner-probe-hashing"}},[a._v("#")]),a._v(" Liner Probe Hashing")]),a._v(" "),t("blockquote",[t("p",[a._v("线性探测hash，也翻译成开放地址hash")]),a._v(" "),t("p",[a._v("重点看看这个")])]),a._v(" "),t("p",[a._v("原理非常简单，就是我有一个hash数据，然后经过一个线性的函数进行映射（比如ax+b）到hash数组。")]),a._v(" "),t("ul",[t("li",[a._v("如果value对应的地方是空的，可以直接存")]),a._v(" "),t("li",[a._v("如果发生碰撞，就从碰撞的地方往下移，直到没数据的地方再存起来")])]),a._v(" "),t("p",[a._v("我们查询的时候呢，如果发现当前位置不是自己对应的value，就往下探（这其实也有问题，查key的时候就已经知道val了，还查什么）")]),a._v(" "),t("blockquote",[t("p",[a._v("这里假设，Hash(A)=Hash(C),    ,然后来讨论一些问题")])]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211102551787.png",alt:"image-20231211102551787"}}),a._v(" "),t("p",[a._v("删除的时候。举例，我们删除C的hash值。但是我们注意C存的地方是被移动过的，存在了D本来该被存的位置。")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211102746742.png",alt:"image-20231211102746742"}}),a._v(" "),t("p",[a._v("这时候引起一个很棘手的问题，我们如果查询D，我们发现D的位置没有东西了，那么我们只能认为当前数据没有了，只能重新插入")]),a._v(" "),t("p",[a._v("解决办法一个是墓碑。就是弄一个死亡标记，让D往下接着查")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211102906946.png",alt:"image-20231211102906946"}}),a._v(" "),t("p",[a._v("还有一个就是每次删除后整理hash表，让他对的上（但是这也很困难，有很多工作要做）")]),a._v(" "),t("h4",{attrs:{id:"robin-hood-hashing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#robin-hood-hashing"}},[a._v("#")]),a._v(" Robin HooD Hashing")]),a._v(" "),t("blockquote",[t("p",[a._v("均富方法。这个方法核心就是尽量减少value的移动次数。")])]),a._v(" "),t("p",[a._v("这个方法是基于上面的开放地址hash进行了一点改进。")]),a._v(" "),t("p",[a._v("这里假设，Hash(A)=Hash(E)=Hahs(C)  来讨论问题。  val表示从hash碰撞位置开始移动的次数。")]),a._v(" "),t("p",[a._v("这里我们插入E时，后面再下移动每个位置的对应移动次数。")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211104036858.png",alt:"image-20231211104036858"}}),a._v(" "),t("p",[a._v("发现D移动次数比我们移到这里小，所以把他挤下去，然后插入。")]),a._v(" "),t("p",[a._v("这样D和E移动次数都是2了")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211104217511.png",alt:"image-20231211104217511"}}),a._v(" "),t("h4",{attrs:{id:"cuckoo-hashing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cuckoo-hashing"}},[a._v("#")]),a._v(" CUCKOO  Hashing")]),a._v(" "),t("blockquote",[t("p",[a._v("杜鹃鸟算法，杜鹃鸟经常把蛋下到别人窝里。")])]),a._v(" "),t("p",[a._v("这个算法有两个hash表，在两个hash表上，key对应的位置应该不一样。如果一个表冲突，就插入到另一个表，如果两个都冲突，比如下面的情况：")]),a._v(" "),t("p",[a._v("我们C两个都冲突")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211104821888.png",alt:"image-20231211104821888"}}),a._v(" "),t("p",[a._v("于是C就把B的位置占了，然后把B丢到#1表里，但是B又占了A的位置，于是把A丢到#2,这时候终于不碰撞，完成了。")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211105029694.png",alt:"image-20231211105029694"}}),a._v(" "),t("h4",{attrs:{id:"observation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#observation"}},[a._v("#")]),a._v(" Observation")]),a._v(" "),t("p",[a._v("上面几种静态的hash函数都有一个问题，"),t("strong",[a._v("他们的容量一开始就已经定了")]),a._v("，也即是我们一开始就得知道有多少个key。")]),a._v(" "),t("h3",{attrs:{id:"chained-hashing-重要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chained-hashing-重要"}},[a._v("#")]),a._v(" Chained  Hashing（重要）")]),a._v(" "),t("blockquote",[t("p",[a._v("链式hash")]),a._v(" "),t("p",[a._v("上面的静态hash并不常用，链式hash很多地方都在用，比如java的hashmap")])]),a._v(" "),t("p",[t("strong",[a._v("核心思想是引入"),t("code",[a._v("bucket")]),a._v("即桶，一个桶可以存一个数据也可以多个数据（容量固定），如果碰撞了，就继续开一个桶（链表连起来）接着存。")])]),a._v(" "),t("p",[t("strong",[a._v("发生hash冲突时")])]),a._v(" "),t("ul",[t("li",[a._v("如果桶里有空位置，就存空位置")]),a._v(" "),t("li",[a._v("如果桶满了，就再开一个桶，并且把他们和上一个桶连起来")])]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211105425798.png",alt:"image-20231211105425798"}}),a._v(" "),t("blockquote",[t("p",[a._v("拓展：")]),a._v(" "),t("p",[a._v("java中的hashmap就是上面这种思想,")]),a._v(" "),t("p",[a._v("bucket大小是1，如果发生碰撞就在来一个bucket来存。")]),a._v(" "),t("p",[a._v("如果碰撞数超过10，后面用红黑树来存。")])]),a._v(" "),t("h4",{attrs:{id:"extendibale-hashing-重要-带实验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extendibale-hashing-重要-带实验"}},[a._v("#")]),a._v(" Extendibale  hashing（重要+带实验）")]),a._v(" "),t("blockquote",[t("p",[a._v("可扩容的的hash，常用")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/q2453303961/article/details/128153709",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("a",{attrs:{href:"https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/",target:"_blank",rel:"noopener noreferrer"}},[a._v("很长很详细的讲解"),t("OutboundLink")],1)])]),a._v(" "),t("p",[t("strong",[a._v("这里核心思想就是如果运行过程中发现bucket太小了，bucket的链表可能会很长，那就把bucket的容量提高，避免太长的链表出现。")])]),a._v(" "),t("blockquote",[t("p",[a._v("因为在链表查找一个数是O(n)的复杂度，如果碰撞太多，出现很长的链表显然是不行滴")])]),a._v(" "),t("p",[a._v("要完成这个 task 首先要明确 可拓展散列 的概念，其中有 几 个关键名词，"),t("strong",[a._v("目录，桶，全局位深度和局部位深度")])]),a._v(" "),t("blockquote",[t("p",[a._v("这个数据结构还是有点绕，耐心理解一下")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("首先是目录(directory)，目录就是存放着桶指针的表")]),a._v(" "),t("ul",[t("li",[a._v("所以这里的扩容实际上这个目录也会扩张，扩张的办法就是多增加一个二进制位（double）")]),a._v(" "),t("li",[t("strong",[a._v("注意这里的一个索引指向一个bucket，而不是一条记录。也就是不同的key，对应的索引有可能一样")])]),a._v(" "),t("li",[a._v("index的计算方式，直接截断hash(key)的前i位（   i.e.  globaldepth=2,mask=11）")]),a._v(" "),t("li",[t("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214173043552.png"}})])])]),a._v(" "),t("li",[t("p",[a._v("桶(bucket)，就是用来存放数据的。桶应该有一个固定大小S。")])]),a._v(" "),t("li",[t("p",[a._v("全局位深度(global depth)，这里写作 G ,可以看作目录中最多有 2 的 G 次方个桶。")]),a._v(" "),t("ul",[t("li",[a._v("同时注意，给定一个key**，需要用global depth取出这个key的低n位的二进制值**。例如，一个key的二进制是10111，如果global depth是3，通过"),t("code",[a._v("IndexOf(key)")]),a._v("函数，得到返回值的二进制值是111，即为7。这个值用来索引directory[111]位置的bucket。")])])]),a._v(" "),t("li",[t("p",[a._v("局部位深度(local depth)，这里写作 L ,是桶特有的，每个桶独自保存一个 L。在当前的bucket之下，每个元素的key的低n位都是相同的（。")]),a._v(" "),t("ul",[t("li",[a._v("这里的低是自己定义的，可以前n位也可以是后n位")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("根据global depth  和local depth的关系，插入时的行为不同：")])]),a._v(" "),t("ul",[t("li",[a._v("对于一个bucket来说，"),t("strong",[a._v("如果当前的global depth等于local depth，那说明这个bucket只有一个指针指向它。")]),a._v(" "),t("ul",[t("li",[a._v("如果是这个情况下满了，目录加倍，分裂成两个bucket，GlobalDepth++,localdepth++")])])]),a._v(" "),t("li",[a._v("如果当前的global depth大于local depth，必定不止一个指针指向它。\n"),t("ul",[t("li",[a._v("如果是这个情况下满了，目录不会加倍,分裂成两个bucket，localdepth++")])])]),a._v(" "),t("li",[a._v("计算当前bucket有几个指针指向他的公式是"),t("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[t("mjx-math",{staticClass:"MJX-TEX"},[t("mjx-msup",[t("mjx-mn",{staticClass:"mjx-n"},[t("mjx-c",{attrs:{c:"2"}})],1),t("mjx-script",{staticStyle:{"vertical-align":"0.363em"}},[t("mjx-TeXAtom",{attrs:{size:"s"}},[t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"g"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"l"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"o"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"b"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"a"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"l"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"D"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"e"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"p"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"t"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"h"}})],1),t("mjx-mo",{staticClass:"mjx-n"},[t("mjx-c",{attrs:{c:"2212"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"l"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"o"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"c"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"a"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"l"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"D"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"e"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"p"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"t"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"h"}})],1)],1)],1)],1)],1)],1),a._v("（对于实现好像没什么用）")],1)])])]),a._v(" "),t("p",[a._v("find和remove很简单，这里只涉及"),t("code",[a._v("Inset(k,v)")]),a._v("。")]),a._v(" "),t("blockquote",[t("p",[a._v("复习一下移位运算，"),t("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[t("mjx-math",{staticClass:"MJX-TEX"},[t("mjx-mn",{staticClass:"mjx-n"},[t("mjx-c",{attrs:{c:"1"}})],1),t("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[t("mjx-c",{attrs:{c:"226A"}})],1),t("mjx-mi",{staticClass:"mjx-i",attrs:{space:"4"}},[t("mjx-c",{attrs:{c:"n"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"u"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"m"}})],1)],1)],1),a._v(",1左移num位，"),t("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[t("mjx-math",{staticClass:"MJX-TEX"},[t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"n"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"u"}})],1),t("mjx-mi",{staticClass:"mjx-i"},[t("mjx-c",{attrs:{c:"m"}})],1),t("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[t("mjx-c",{attrs:{c:"226A"}})],1),t("mjx-mn",{staticClass:"mjx-n",attrs:{space:"4"}},[t("mjx-c",{attrs:{c:"1"}})],1)],1)],1),a._v(",num左移一位")],1)]),a._v(" "),t("p",[a._v("首先我们初始时，只有一个桶，目录深度也是0.并且value没有意义，所以我们这里讨论的都是hash(key)或者索引")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214174549089.png",alt:"image-20231214174549089"}})]),a._v(" "),t("p",[a._v("此时我们插入a,b,即"),t("code",[a._v("Insert(a,v1)")]),a._v(","),t("code",[a._v("Insert(b,v2)")])]),a._v(" "),t("blockquote",[t("p",[a._v("假设，Hash(a)=0010，Hash(b)=1100，")]),a._v(" "),t("p",[a._v("那么此时的Index中mask =0，Index (a)=0&0010=0,Index(b)=1&1100=0，所以都会索引到B1这个桶")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214174835084.png",alt:"image-20231214174835084"}})]),a._v(" "),t("p",[a._v("我们继续插入,"),t("code",[a._v("Insert(c,v3)")]),a._v(",此时还是索引到B1（因为G还是0），但是此时就会发现B1满了")]),a._v(" "),t("blockquote",[t("p",[a._v("Hash(c)=1111，由于此时mask=0,索引还是索引到0")])]),a._v(" "),t("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214175757569.png",alt:"image-20231214175757569"}}),a._v(" "),t("p",[a._v("此时就需要扩容，我们根据上面的逻辑**，此时G和L相等，所以目录加倍，分裂成两个bucket，GlobalDepth++,localdepth++**")]),a._v(" "),t("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231214175624271.png",alt:"image-20231214175624271"}}),a._v(" "),t("p",[a._v("首先是目录扩容，扩容后，"),t("strong",[a._v("目录索引的bucket关系需要保留，具体做法就是复制原有的dir到新增的那一部分即可")])]),a._v(" "),t("blockquote",[t("p",[a._v("为什么扩容时原来的i+capacity?因为indexof中，我们多取了一位，所以我们要把多一位的那个地方也要存过去，保证新计算的index能正确查到值。")]),a._v(" "),t("p",[a._v("这里实际上是在新增的capacity中，映射了原有的过去，为什么?")]),a._v(" "),t("p",[a._v("假设hash(a)=0111, 如果 取一位，indexof得到索引就是1，取两位indexof得到是11,而11=1+01，正好是上一次的索引+capacity。")]),a._v(" "),t("p",[a._v("如果是hash(b)=0101,如果 取一位，indexof得到索引就是1，取两位indexof得到是01,但是我们让11也指向原来的桶了？这样会有错吗？")]),a._v(" "),t("p",[a._v("其实不会，我们只要保证新增索引位后，索引变了的也要能正常访问即可。")]),a._v(" "),t("p",[a._v("因为新增位数后，索引不变的，他就算指向了一个新桶，没影响啊，因为查询时会返回false，不影响正确性！")])]),a._v(" "),t("div",{staticClass:"language-C++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("if(target_bucket->GetDepth() == GetGlobalDepthInternal()){\n      global_depth_++;\n      int capacity = dir_.size();\n      dir_.resize(capacity<<1);//翻倍大小\n      for(int i=0;i<capacity;i++){\n        dir_[i+capacity]=dir_[i];//复制原有的到新增的dir_中\n      }\n    }\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br")])]),t("p",[a._v("分裂其实就是按照索引，把这个满了的bucket给他重新索引一下")]),a._v(" "),t("div",{staticClass:"language-C++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("    int mask = 1<<target_bucket->GetDepth();\n    auto bucket_0 = std::make_shared<Bucket>(bucket_size_, target_bucket->GetDepth() + 1);\n    auto bucket_1 = std::make_shared<Bucket>(bucket_size_, target_bucket->GetDepth() + 1);\n\n    for(const auto & item :target_bucket->GetItems()){//将原来的满了的bucket的item分配到两个新桶里\n      size_t hash_key = std::hash<K>()(item.first);\n      // int mask = (1 << global_depth_) - 1;\n      //  return std::hash<K>()(key) & mask;//截取前glocalth二进制位\n      if((hash_key&mask)!=0U){\n        bucket_1->Insert(item.first,item.second);\n      }else{\n        bucket_0->Insert(item.first,item.second);\n      }\n    }\n//下面给bucket插入新加的hash(c)那条记录\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br")])]),t("blockquote",[t("p",[t("strong",[a._v("java go也有类似的思想，进行hash扩容")]),a._v("，比如java差不多就是发现hash表容量到了75%左右就会进行扩容，")])]),a._v(" "),t("h4",{attrs:{id:"linear-hashing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linear-hashing"}},[a._v("#")]),a._v(" Linear Hashing")]),a._v(" "),t("blockquote",[t("p",[a._v("用的少，不记录了")])]),a._v(" "),t("p",[a._v("这个方法的核心是觉得上面的方面，一次直接扩容，扩容导致的重新hash操作，"),t("strong",[a._v("会导致比较长的等待时间")]),a._v("，所以应该慢慢的扩容。")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211111653483.png",alt:"image-20231211111653483"}}),a._v(" "),t("h4",{attrs:{id:"conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[a._v("#")]),a._v(" Conclusion")]),a._v(" "),t("p",[a._v("Hash表好处是不管多少数据基本可以是O(1)的查询速度。")]),a._v(" "),t("p",[t("strong",[a._v("但是hash表一般不能当数据库索引，因为不能范围查询")])]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211111904587.png",alt:"image-20231211111904587"}}),a._v(" "),t("h3",{attrs:{id:"non-unique-keys"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#non-unique-keys"}},[a._v("#")]),a._v(" NON-UniQue Keys")]),a._v(" "),t("p",[a._v("hash理论上不准key重复，但是我们知道数据库经常有重复的可以，如果有重复的key怎么办？")]),a._v(" "),t("p",[a._v("有两种方法：")]),a._v(" "),t("ul",[t("li",[a._v("第一种是把相同key的value的值用链表给链接起来")]),a._v(" "),t("li",[a._v("第二种是存的时候把key存上，存key-value当value")])]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://typora-1309665611.cos.ap-nanjing.myqcloud.com/typora/image-20231211103240074.png",alt:"image-20231211103240074"}})])}),[],!1,null,null,null);t.default=i.exports}}]);